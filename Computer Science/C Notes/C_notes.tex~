% Created 2019-08-05 Mon 19:27
% Intended LaTeX compiler: pdflatex
\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[margin=1in] {geometry}
\usepackage{parskip}
\linespread {1.5}
\setcounter{tocdepth} {6}
\setcounter{secnumdepth} {6}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.2 (Org mode 9.2.3)}, 
 pdflang={English}}
\begin{document}

\tableofcontents

\section{C Basics}
\label{sec:org39a42be}
\subsubsection{Some Facts}
\label{sec:org6b9f7cc}
\begin{itemize}
\item assignments associate from right to left.
\item arithemetic operators associate left to right
\item relational operators have lower precedence than arithmetic operators
\item expressions connected by \texttt{\&\&} or \texttt{||} are evaluated left to right. \texttt{\&\&} has a higher precedence than \texttt{||}, both are lower than relational and equality operators. (higher than assignment operators?)
\item printable characters are always positive
\item The standard headers \texttt{<limits.h>} and \texttt{<float.h>} contain symbolic constants for all of the sizes of basic data types, along with other properties of the machine and compiler.
\item a leading 0 (zero) on an integer constant means octal
\item a leading \texttt{0x} or \texttt{0X} (zero x) means hexadecimal.
\item you can use escape sequence to represent number. Check it at p51. The complete set of escape sequences are in p52.
\item \texttt{strlen()} function and other string functions are declared in the standard header \texttt{<string.h>}.
\item external and static variables are initialized to zero by default.
\item for portability, specify \texttt{signed} or \texttt{unsigned} if non-character data is to be stored in \texttt{char} variables. (p58)
\item to perform a type conversion:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
double a = 2.5;
printf("%d", (int) a);  
\end{minted}
result will be \texttt{2}.
\item unary operator associate right to left (like \texttt{*}, \texttt{++}, \texttt{-{}-})
\end{itemize}

place holder.

\subsubsection{headers}
\label{sec:orgb4147eb}
\begin{itemize}
\item \texttt{<stdio.h>}: contains input/output functions
\item \texttt{<ctype.h>}: some functions regarding to characters
\end{itemize}

\subsubsection{\texttt{printf()} formatting}
\label{sec:org107fb15}
Check p26-p27 of the textbook.

Use \texttt{\%} with symbols to print the variables in different format.
Example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
printf("%c", a)  //print a in format of character
printf("%s", a)  //print a in format of character string
printf("%nc", a)  //print a in format of character, using a character width of size n (at least)
printf("%f", a)  //print a in format of float
printf("%nf", a)  //print a in format of float, using a width of size n
printf("%n.0f", a)  //print a in format of float, using a character width of size n, with no decimal point and no fraction digits
printf("%n.mf", a)  //print a in format of float, using a character width of size n, with decimal point and m fraction digits
printf("%0.mf", a)  //print a in format of float, with decimal point and m fraction digits. The width is not constrained.
printf("%d", a)  //print a in format of integer
printf("%o", a)  //print a in format of octal integer
printf("%x", a)  //print a in format of hexadecimal integer
\end{minted}
\subsubsection{Symbolic Constants}
\label{sec:org63ca3f7}
A \texttt{\#define} line defines a symbolic name or symbolic constants to be a particular string of characters. You use it like: \texttt{\#define} \emph{name} \emph{replacement text}. You put this at the head of your code (outside scope of any function to make it globally). Example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdio.h>

#define LOWER 0
#define UPPER 300
#define STEP 20

int main() {

  for (int i = LOWER; i <= UPPER; i += STEP) {
    printf("%5d\t%20f", i, 5 * (i - 32) / 9.0);
    printf("\n");
  }

  return 0;
}
\end{minted}
Pay attention that symbolic name or symbolic constants are not variables. They are conventionally written in upper case. No semicolon at the end of a \texttt{\#define} line.
\subsubsection{Character Input and Output}
\label{sec:orga12c1c3}
\begin{itemize}
\item \texttt{getchar()}: it reads the next input character from a text stream and returns that (from the buffer?).
\item \texttt{putchar()}: it prints a character each time it is called and passed a char into.
\end{itemize}

Pay attention that a character written between single quotes represents an integer value equal to the numerical value of the character in the machine's character set. This is called a character constant. For example, \texttt{'a'} is actually \texttt{97}.
\subsubsection{Arrays}
\label{sec:org1451c58}
The syntax is similar with C++. For example, to define an array of integers with a size of 100, you do:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int nums[100];
\end{minted}
Remember to initialize each slot:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
for (int i = 0; i < 100; i++)
  nums[i] = 0;
\end{minted}

You can also to use assignment operator and \texttt{\{ \}} to initialize the array when defining. For example, the following C-string is initialized when being defined:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int main() {
  char s[] = {'a', 'b', 'c' };
  printf("%s", s);
  return 0;
}
\end{minted}
\subsubsection{Enumeration constant}
\label{sec:org92d1af8}
An enumeration is a list of constant integer values. For example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
enum boolean { NO, YES };
\end{minted}
The first name in an \texttt{enum} has value 0, the next 1, and so on, unless explicit values are specified:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
enum boolean { YES = 1, NO = 0 };
\end{minted}

If not all values are specified, unspecified values continue the progression from the last specified value:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
enum months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };
// FEB is 2, MAR is 3, etc.
\end{minted}

Names in different enumerations must be distinct. Values need not be distinct in the same enumeration. Enumeration works like using \texttt{\#define} to associate constant values with names:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#define JAN 1
#define FEB 2
// etc
\end{minted}
\subsubsection{type-cast an expression}
\label{sec:org0bb84eb}
Explicit type conversions can be forced ("coerced") in any expression. For example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int main() {
  int n = 2;
  printf("%f", (float) n);
  return 0;
}
\end{minted}
In the above example, when being printed, the type of \texttt{n} has been modified to \texttt{float}. Notice that \texttt{n} itself is not altered. This is called a \emph{cast}, it is an unary operator, has the same high precedence as other unary operators.
\subsubsection{Bitwise operators}
\label{sec:org15bf781}
p62

There are 6 bitwise operators for bit manipulation. They may be applied to integral operands only.

They are:
\begin{itemize}
\item \texttt{\&}  : bitwise AND
\item \texttt{|}  : bitwise inclusive OR
\item \texttt{\textasciicircum{}}  : bitwise exclusive OR
\item \texttt{<<} : left shift
\item \texttt{>>} : right shift
\item \texttt{\textasciitilde{}}  : one's complement (unary)
\end{itemize}

The precedence of the bitwise operators \texttt{\&}, \texttt{\textasciicircum{}} and \texttt{|} is lower than \texttt{==} and \texttt{!=}.
\subsubsection{Operators can be used with assignment operators}
\label{sec:org76013b3}
p64

\texttt{+, -, *, /, \%, <<, >>, \&, \textasciicircum{}, |}
\subsubsection{External Variables}
\label{sec:org76252c7}
If an external variables is to be referred to before it is defined, or if it is defined in a different source file from the one where it is being used, then an \texttt{extern} declaration is mandatory. For example, a function using external variables in a different source file can declare these variables in following manner:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int addNum(int a) {
  extern int ADDAMOUNT;  // variable ADDAMOUNT is in different source file

  return a + ADDAMOUNT;
}
\end{minted}
Array sizes must be specified with the definition, but are optional with an \texttt{extern} declaration.
\subsubsection{Command-line Arguments}
\label{sec:org5ad8084}
p128 in CPL.

We can pass command-line arguments or parameters to a program when it begins executing. An example is the echo program. On the command prompt, you enter \texttt{ehco}, followed by a series of arguments:
\begin{verbatim}
$ echo hello world
\end{verbatim}
then press enter. The command line window will repeat the inputed arguments:
\begin{verbatim}
$ echo hello world
$ hello world
\end{verbatim}
The two strings \texttt{"hello"} and \texttt{"world"} are two arguments passed in echo program.

Basically, when \texttt{main()} is called, it is called with two arguments: \texttt{argc} and \texttt{argv}.
\begin{itemize}
\item \texttt{argc}: stands for argument count. It is the number of command-line arguments when the program was invoked (i.e. how many strings are there in the line that invoked the program). In the above echo example, \texttt{argc == 3}, the three strings are: "echo", "hello" and "world", respectively.
\item \texttt{argv}: stands for argument vector. It is a pointer to an array of character strings that contain the actual arguments, one per string. You can imagine when you type in command line to invoke a program, what you typed in was stored somewhere in an array of character strings. Additionally, the standard requires that \texttt{argv[argc]} be a null pointer. In the echo example, you typed "echo hello world", and following array of characters was stored:
\begin{verbatim}
["echo", "hello", "world", 0]
\end{verbatim}
\end{itemize}

Knowing this, we can write a program that mimic the \texttt{echo} function.
\end{document}
