% Created 2019-08-18 Sun 19:43
% Intended LaTeX compiler: pdflatex
\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[margin=1in] {geometry}
\usepackage{parskip}
\linespread {1.5}
\setcounter{tocdepth} {6}
\setcounter{secnumdepth} {6}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.2 (Org mode 9.2.3)}, 
 pdflang={English}}
\begin{document}

\tableofcontents


\section{Generals}
\label{sec:org69d40bd}
\subsection{Some Facts}
\label{sec:orgfa05534}
Below are some general facts about C language.
\begin{itemize}
\item assignments associate from right to left.
\item arithemetic operators associate left to right
\item relational operators have lower precedence than arithmetic operators
\item expressions connected by \texttt{\&\&} or \texttt{||} are evaluated left to right. \texttt{\&\&} has a higher precedence than \texttt{||}, both are lower than relational and equality operators. (higher than assignment operators?)
\item printable characters are always positive
\item The standard headers \texttt{<limits.h>} and \texttt{<float.h>} contain symbolic constants for all of the sizes of basic data types, along with other properties of the machine and compiler.
\item a leading 0 (zero) on an integer constant means octal
\item a leading \texttt{0x} or \texttt{0X} (zero x) means hexadecimal.
\item you can use escape sequence to represent number. Check it at p51. The complete set of escape sequences are in p52.
\item \texttt{strlen()} function and other string functions are declared in the standard header \texttt{<string.h>}.
\item external and static variables are initialized to zero by default.
\item for portability, specify \texttt{signed} or \texttt{unsigned} if non-character data is to be stored in \texttt{char} variables. (p58)
\item to perform a type conversion:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
double a = 2.5;
printf("%d", (int) a);  
\end{minted}
result will be \texttt{2}.
\item unary operator associate right to left (like \texttt{*}, \texttt{++}, \texttt{-{}-})
\item strcpy() function in C needs a pointer to a character array! A pointer to character will cause segmentation fault
\end{itemize}

Place holder.

\subsection{headers}
\label{sec:orgc296512}
\begin{itemize}
\item \texttt{<stdio.h>}: contains input/output functions
\item \texttt{<ctype.h>}: some functions regarding to characters
\end{itemize}

\subsection{\texttt{printf()} formatting}
\label{sec:orgac90b10}
Check p26-p27 of the textbook.

Use \texttt{\%} with symbols to print the variables in different format.
Example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
printf("%c", a)  //print a in format of character
printf("%s", a)  //print a in format of character string
printf("%nc", a)  //print a in format of character, using a character width of size n (at least)
printf("%f", a)  //print a in format of float
printf("%nf", a)  //print a in format of float, using a width of size n
printf("%n.0f", a)  //print a in format of float, using a character width of size n, with no decimal point and no fraction digits
printf("%n.mf", a)  //print a in format of float, using a character width of size n, with decimal point and m fraction digits
printf("%0.mf", a)  //print a in format of float, with decimal point and m fraction digits. The width is not constrained.
printf("%d", a)  //print a in format of integer
printf("%o", a)  //print a in format of octal integer
printf("%x", a)  //print a in format of hexadecimal integer
\end{minted}
\subsection{Symbolic Constants}
\label{sec:org1cf8acf}
A \texttt{\#define} line defines a symbolic name or symbolic constants to be a particular string of characters. You use it like: \texttt{\#define} \emph{name} \emph{replacement text}. You put this at the head of your code (outside scope of any function to make it globally). Example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdio.h>

#define LOWER 0
#define UPPER 300
#define STEP 20

int main() {

  for (int i = LOWER; i <= UPPER; i += STEP) {
    printf("%5d\t%20f", i, 5 * (i - 32) / 9.0);
    printf("\n");
  }

  return 0;
}
\end{minted}
Pay attention that symbolic name or symbolic constants are not variables. They are conventionally written in upper case. No semicolon at the end of a \texttt{\#define} line.
\subsection{Character Input and Output}
\label{sec:org7da847b}
\begin{itemize}
\item \texttt{getchar()}: it reads the next input character from a text stream and returns that (from the buffer?).
\item \texttt{putchar()}: it prints a character each time it is called and passed a char into.
\end{itemize}

Pay attention that a character written between single quotes represents an integer value equal to the numerical value of the character in the machine's character set. This is called a character constant. For example, \texttt{'a'} is actually \texttt{97}.
\subsection{Arrays}
\label{sec:orgf64a9de}
The syntax is similar with C++. For example, to define an array of integers with a size of 100, you do:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int nums[100];
\end{minted}
Remember to initialize each slot:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
for (int i = 0; i < 100; i++)
  nums[i] = 0;
\end{minted}

You can also to use assignment operator and \texttt{\{ \}} to initialize the array when defining. For example, the following C-string is initialized when being defined:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int main() {
  char s[] = {'a', 'b', 'c' };
  printf("%s", s);
  return 0;
}
\end{minted}
\subsection{Enumeration constant}
\label{sec:org9f04c87}
An enumeration is a list of constant integer values. For example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
enum boolean { NO, YES };
\end{minted}
The first name in an \texttt{enum} has value 0, the next 1, and so on, unless explicit values are specified:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
enum boolean { YES = 1, NO = 0 };
\end{minted}

If not all values are specified, unspecified values continue the progression from the last specified value:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
enum months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };
// FEB is 2, MAR is 3, etc.
\end{minted}

Names in different enumerations must be distinct. Values need not be distinct in the same enumeration. Enumeration works like using \texttt{\#define} to associate constant values with names:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#define JAN 1
#define FEB 2
// etc
\end{minted}
\subsection{type-cast an expression}
\label{sec:orge18f903}
Explicit type conversions can be forced ("coerced") in any expression. For example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int main() {
  int n = 2;
  printf("%f", (float) n);
  return 0;
}
\end{minted}
In the above example, when being printed, the type of \texttt{n} has been modified to \texttt{float}. Notice that \texttt{n} itself is not altered. This is called a \emph{cast}, it is an unary operator, has the same high precedence as other unary operators.
\subsection{Bitwise operators}
\label{sec:orge59a959}
p62

There are 6 bitwise operators for bit manipulation. They may be applied to integral operands only.

They are:
\begin{itemize}
\item \texttt{\&}  : bitwise AND
\item \texttt{|}  : bitwise inclusive OR
\item \texttt{\textasciicircum{}}  : bitwise exclusive OR
\item \texttt{<<} : left shift
\item \texttt{>>} : right shift
\item \texttt{\textasciitilde{}}  : one's complement (unary)
\end{itemize}

The precedence of the bitwise operators \texttt{\&}, \texttt{\textasciicircum{}} and \texttt{|} is lower than \texttt{==} and \texttt{!=}.
\subsection{Operators can be used with assignment operators}
\label{sec:org60a9a0b}
p64

\texttt{+, -, *, /, \%, <<, >>, \&, \textasciicircum{}, |}
\subsection{External Variables}
\label{sec:org4af5759}
If an external variables is to be referred to before it is defined, or if it is defined in a different source file from the one where it is being used, then an \texttt{extern} declaration is mandatory. For example, a function using external variables in a different source file can declare these variables in following manner:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int addNum(int a) {
  extern int ADDAMOUNT;  // variable ADDAMOUNT is in different source file

  return a + ADDAMOUNT;
}
\end{minted}
Array sizes must be specified with the definition, but are optional with an \texttt{extern} declaration.
\subsection{Command-line Arguments}
\label{sec:org48e349b}
p128 in CPL.

We can pass command-line arguments or parameters to a program when it begins executing. An example is the echo program. On the command prompt, you enter \texttt{ehco}, followed by a series of arguments:
\begin{verbatim}
$ echo hello world
\end{verbatim}
then press enter. The command line window will repeat the inputed arguments:
\begin{verbatim}
$ echo hello world
$ hello world
\end{verbatim}
The two strings \texttt{"hello"} and \texttt{"world"} are two arguments passed in echo program.

Basically, when \texttt{main()} is called, it is called with two arguments: \texttt{argc} and \texttt{argv}.
\begin{itemize}
\item \texttt{argc}: stands for argument count. It is the number of command-line arguments when the program was invoked (i.e. how many strings are there in the line that invoked the program). In the above echo example, \texttt{argc == 3}, the three strings are: "echo", "hello" and "world", respectively.
\item \texttt{argv}: stands for argument vector. It is a pointer to an array of character strings that contain the actual arguments, one per string. You can imagine when you type in command line to invoke a program, what you typed in was stored somewhere in an array of character strings. Additionally, the standard requires that \texttt{argv[argc]} be a null pointer. In the echo example, you typed "echo hello world", and following array of characters was stored:
\begin{verbatim}
["echo", "hello", "world", 0]
\end{verbatim}
\end{itemize}

\subsubsection{Example: \texttt{echo}}
\label{sec:org6cde602}
Knowing this, we can write a program that mimic the \texttt{echo} function: re-print what we typed in when we invoke the program to terminal:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdio.h>

int main(int argc, char* argv[]) {
  while (*(++argv))
    printf("%s%s", *argv, *(argv + 1) ? " " : "");  // the second %s is for the space

  printf("\n");

  return 0;
}
\end{minted}

\subsubsection{Example: \texttt{pattern\_finding}}
\label{sec:orgbf5b394}
This program will try to find any lines in the input buffer that contains the keyword passed in when invoking it. For example, in command line prompt:
\begin{verbatim}
$ pattern_finding love < text.txt
\end{verbatim}
it will print all lines that contain \texttt{love} to the terminal.

The program uses \texttt{strstr()} to search the existence of a certain keyword in target string. We also write a \texttt{getline()} function to get one single line from input buffer (using \texttt{getchar()}). Pay attention that in the new C library (\texttt{stdio.h}), a \texttt{getline()} function has been added. So we rename our function to \texttt{getlines()}. The code is as follows:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000

int getlines(char* line, int max);

//find: print lines that match pattern from 1st arg 
int main(int argc, char* argv[]) {
  char line[MAXLINE];  // used to hold a line of string
  int found = 0;

  if (argc != 2)
    printf("Usage: find pattern\n");
  else
    while (getlines(line, MAXLINE) > 0)
      if (strstr(line, argv[1]) != NULL) {
	printf("No.%d: %s", ++found, line);
      }

  return found;
}

int getlines(char* line, int max) {
  char ch;

  while (--max > 0 && (ch = getchar()) != EOF && ch != '\n') {
    *(line++) = ch;
  }

  if (ch == '\n')
    *(line++) = ch;  // no need to worry about not enough space, since if ch == '\n', it is not stored in line yet, because the loop was not executed
  *line = '\0';

  if (ch == EOF)
    return -1;

  return 1;
}
\end{minted}

\subsubsection{Optional arguments example: \texttt{pattern\_finding} extended}
\label{sec:org0352dd4}
Now we extend our \texttt{pattern\_finding} program so it can accept optional arguments. A convention for C programs on UNIX systems is that an argument that begins with a minus sign introduces an optical flag or parameter. Optional arguments should be permitted in any order, they can also be combined (a minus sign with two or more optional arguments, without space between each other).

There is no magic about optional arguments. They are collected as strings in \texttt{argv[]} when the program is invoked, just like anyother strings occured when invoking the function. We extend the \texttt{pattern\_finding} program to include support for two optional arguments:
\begin{enumerate}
\item -x: print lines that doesn't contain the target pattern;
\item -n: in addition to print lines, the program will also print the corresponding line number before the line.
\end{enumerate}
So, the program can be invoked in following way:
\begin{verbatim}
$ pattern_finding -n -x keyword < text.txt
\end{verbatim}
in this case, when \texttt{main()} is called, \texttt{argc == 4}, \texttt{*argv == \{"pattern\_finding", "-n", "-x", "keyword"\}}. \texttt{< text.txt} is just redirect \texttt{stdin} to the text.

Or, we can combine the two optional arguments:
\begin{verbatim}
$ pattern_finding -xn keyword < text.txt
\end{verbatim}
in this case, when \texttt{main()} is called, \texttt{argc == 3}, \texttt{*argv == \{"pattern\_finding", "-xn", "keyword"\}}.

Thus, we have to write code to analyze argument strings that has \texttt{"-xxx"} form. Generally, we keep a list of flags inside the program. If we encountered any optional argument in the string, we can set the corresponding flag to true.

The code and explanation is as follows:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000

int getlines(char* line, int max);

//find: print lines that match pattern from 1st arg 
// with optional arguments enabled
int main(int argc, char* argv[]) {
  char line[MAXLINE];  // temporary container to hold line read from buffer
  char c;  // to check optional arguments 

  int line_num = 0;  // record the number of line                                                             
  int except = 0;  // flag of optional argument x, if this is true, print lines that doesn't have pattern  
  int number = 0;  // flag for optional argument n , if this is true, print the corresponding line number
  int found = 0;


  // check inputted arguments and set flag accordingly
  // use prefix to skip the first argv (which is the name of the function)
  while (--argc > 0 && (*++argv)[0] == '-')  // outter while loop check each "-xxx" styled optional argument 
    while (c = *++argv[0]) {  // inner while loop check each char in the "-xxx" styled argument
      switch (c) {
      case 'x':
	except = 1;
	break;
      case 'n':
	number = 1;
	break;
      default:
	printf("find: illegal option %c\n", c);
	argc = 0;  // this will terminate the program
	found = -1;
	break;
      }
    }

  if (argc != 1)  //we should have only one argument at this point, which is the pattern we are going to find. All optional arguments have been examed by the previous while loop 
    printf("Usage: find -x -n pattern\n");  // print a message showing how to use this program
  else
    while (getlines(line, MAXLINE) > 0) {
      line_num++;  // update the line number

      /*Notes: 
	Print the line based on value of variable except and the found result.
	To print a line, the truth value of found and except should be different. When except = 1, we print lines that not found, so found == 0;
	When except = 0, we print lines that are found, so found == 1;
      */
      if ((strstr(line, *argv) != NULL) != except) {
	if (number)  // if the number flag is true, we print the line number 
	  printf("%d", line_num);
	printf("%s", line);
	found++;
      }

    }

  return found;

}

int getlines(char* line, int max) {
  char ch;

  while (--max > 0 && (ch = getchar()) != EOF && ch != '\n') {
    *(line++) = ch;
  }

  if (ch == '\n')
    *(line++) = ch;  // no need to worry about not enough space, since if ch == '\n', it is not stored in line yet, because the loop was not executed
  *line = '\0';

  if (ch == EOF)
    return -1;

  return 1;
}
\end{minted}

\subsection{Pointers to Functions}
\label{sec:orge2ff1f1}
It is possible to define pointers to functions, which can be assigned, placed in arrays, passed to functions, returned by functions, and so on.

To declare a pointer to a function, you write:
\begin{verbatim}
return_type (*ptr_name)(parameter1_type, parameter2_type, ...)
\end{verbatim}
Explanation:
\begin{itemize}
\item \texttt{return\_type}: the return type of the function this pointer pointing to.
\item \texttt{ptr\_name}: the name of the pointer variable
\item \texttt{parameter\_type}: the type of the function this pointer referring to.
\end{itemize}

Example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdio.h>

int add(int a, int b) {
  return a + b;
}

int main() {
  int (*a)(int, int);
  a = &add;
  printf("%d\n", (*a)(2, 3));
}
\end{minted}
When calling the function pointer, you have to use parenthese to enclose \texttt{*} and pointer name. Use \texttt{\&} and function name to get the "address" of the function.

\subsubsection{Example: qsort() which takes a comp() function pointer}
\label{sec:org12e72bd}
(Example 5-11).

A quick sort function which takes a function pointer to be used in its body to sort is as follows:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
void qsorts(void* v[], int left, int right, int (*comp)(void*, void*)) {
  int last;

  if (left >= right)
    return;

  swap(v, left, (left + right) / 2);
  last = left;

  for (int i = left + 1; i <= right; i++)
    if ((*comp)(v[i], v[left]) < 0)
      swap(v, i, ++last);

  swap(v, left, last);
  qsorts(v, left, last - 1, comp);
  qsorts(v, last + 1, right, comp);
}
\end{minted}

\section{Input and Output}
\label{sec:orgd3a4d50}

\subsection{Standard Input and Output}
\label{sec:org59e2149}
\subsubsection{Input redirection}
\label{sec:org552643d}
In many environments, a file may be substituted for the keyboard as the source of standard input by using the \texttt{<} convention for input redirection. For example, we have following code:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdio.h>

int main() {
  char c;
  while ((c = getchar()) != EOF)
    printf("%c", c);

  return 0;
}
\end{minted}
When we call the program, we use \texttt{<} to redirect standard input with a file:
\begin{verbatim}
$ ./a.out < out.txt
\end{verbatim}
the effect of this program is to print all content in \texttt{out.txt} to standard output.
\subsubsection{Output redirection}
\label{sec:org5a3dde2}
We can also redirect a program's standard output to a file. We use \texttt{>} convention to do it, the syntax is:
\begin{verbatim}
$./a.out > result.txt
\end{verbatim}
in this way, all standard output of \texttt{a.out} will be redirected to file \texttt{result.txt}. The file will be created if not exist.

Output produced by \texttt{putchar()} and \texttt{printf()} are the same, they will both finds its way to the standard output.
\subsubsection{Pipe between two programs}
\label{sec:orgc988ab9}
It is possible to use one program's standard output as another program's standard input:
\begin{verbatim}
$./prog1 | ./prog2
\end{verbatim}
the above line puts the standard output of \texttt{prog1} into the standard input of \texttt{prog2}.

\subsubsection{Include header file}
\label{sec:org95c5129}
When you include a file with brackets \texttt{<>}, the compiler will search the header in a standard set of places (typically: \texttt{/usr/include}).

\subsubsection{Macros in standard library}
\label{sec:org9fe6402}
"Functions" like \texttt{getchar} and \texttt{putchar} in \texttt{<stdio.h>}, and \texttt{tolower} in \texttt{<ctype.h>} are often macros, thus avoiding the overhead of a function call per character.

\subsubsection{Formatted output: printf}
\label{sec:org4ebb770}
p167 on textbook. A table of \texttt{printf()}'s conversion characters are shown in table 7-1 in the book (p168).

A width or precision may be specified as \texttt{.*}, the value is computed by converting the next argument (which must be an \texttt{int}). For example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int main(int argc, char* argv[]) {
  char* s = "abcdefg";
  int length = 4;
  printf("%.*s\n", length, s);
  return 0;
}
\end{minted}
the above program printed the first \texttt{length} characters in string \texttt{s}. Don't forget the dot before \texttt{*}.

\subsubsection{Function \texttt{sprintf()}}
\label{sec:orgfe39442}
This function does the same conversions as \texttt{printf()}. It accepts a \texttt{char* string} argument, and will place the result in \texttt{string} instead of to the standard output. \texttt{string} must big enough to receive the result.

\subsection{Variable-length Argument Lists}
\label{sec:org0be70ec}
This section will use an implementation of a minimal version of \texttt{printf()} to show how to write a function that processes a Variable-length argument list in a portable way.

\subsubsection{Declare a function that takes varying amounts of arguments}
\label{sec:org2dfce07}
To declare a function whose argument number is not fixed (which may vary), we do:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
void miniPrintf(char* format, ...)
\end{minted}
the declaration \texttt{...} means that the number and types of these arguments may vary. It can only appear at the end of a list of named argument (there must be at least one named argument).

\subsubsection{Traverse the argument list and final cleanup}
\label{sec:org32640b0}
The standard header \texttt{<stdarg.h>} contains a set of macro definitions that define how to step through an argument list. To build functions that takes varying amounts of arguments, you have to include \texttt{<stdarg.h>}.

\paragraph{Type \texttt{va\_list}}
\label{sec:org7b8e374}
A data type named \texttt{va\_list} is defined in \texttt{<stdarg.h>}. We declare a variable of this type, then use this variable to refer to each unnamed argument passed in the function. It works like a pointer. For example, we can have following declaration:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdarg.h>
void miniPrintf(char* format, ...) {
  va_list ap;  // points to each unnamed argument in turn
  va_start(ap, format);  // make ap point to 1st unnamed argument
  //...
}
\end{minted}

\paragraph{Macro \texttt{va\_start}}
\label{sec:orgae69dc4}
After the declaration \texttt{va\_list ap;}, \texttt{ap} is an object of type \texttt{va\_list}. How to use it to actually point to the unnamed arguments? We begin by using a macro named \texttt{va\_start}. After declaring \texttt{ap}, we call this macro to "initiate" \texttt{ap}:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdarg.h>
void miniPrintf(char* format, ...) {
  va_list ap;  // points to each unnamed argument in turn
  va_start(ap, format);  // make ap point to 1st unnamed argument
  //...
}
\end{minted}
\texttt{va\_start()} "accepts" two tokens. The first one is the \texttt{va\_list} type variable which will be used to refer to unnamed arguments in turn, here we use \texttt{ap}. The second one should be the \textbf{LAST} named argument from the function call. \texttt{va\_start} will use this to locate the beginning of unnamed argument. After this line, \texttt{ap} will be referring to the first unnamed argument.

But how could we "retrieve" the unnamed argument being referred by \texttt{ap} and move to next argument? We call \texttt{va\_arg} macro to do this job.

\paragraph{Macro \texttt{va\_arg}}
\label{sec:org5fbcdb0}
\texttt{va\_arg} is a macro defined in \texttt{<stdarg.h>}. It "accepts" two tokens, the first one is an object of \texttt{va\_list} type (we used \texttt{ap}), the second one is the type name you wish to collect from current argument which \texttt{ap} is appointing to. When this macro is called, it returns one argument of the type you specified and steps \texttt{ap} to the next. The type name you provided will be used by \texttt{va\_arg} to determine what type to return and how big a step to take. You have to use another variable of the same type to hold the returned argument, so you can use later.

For example, following call of \texttt{va\_arg} will return an integer argument, and we hold it using an integer variable named \texttt{ival}:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int ival;
ival = va_arg(ap, int);
\end{minted}

\paragraph{Macro \texttt{va\_end}}
\label{sec:orgcc59aa3}
\texttt{va\_end} is a macro defined in \texttt{<stdarg.h>}. It takes one token, which is the \texttt{va\_list} object we used in the program. This macro will do whatever needs to cleanup. It must be called before the function returns:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
va_end(ap);
\end{minted}

\subsubsection{\texttt{miniPrintf()} example}
\label{sec:orgb0897c8}
In this example, \texttt{miniPrintf()} takes two arguments, the first one is a pointer to char, which will be the format string or content it will be printing. Every character of \texttt{\%} indicates there is an argument in the argument list waiting to be printed in a certain format. Here, we just use the next character after \texttt{\%} to determine what type of argument we retrieve from the argument list. The function is declared as:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdarg.h>
#include <stdio.h>
void miniPrintf(char* format, ...)
\end{minted}
To retrieve arguments in the unamed argument list, we declare an object of type \texttt{va\_list}:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
va_list ap;
char *p;  // to traverse format string
char* sval;  // to hold string argument
int ival;  // to hold integer argument
double dval;  // to hold double argument
\end{minted}
Before processing, we need to initialize the \texttt{va\_list} object:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
va_start(ap, format);
\end{minted}
Then, we go over the \texttt{format} string. If no \texttt{\%} encountered, we call \texttt{putchar()} to print it directly:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
for (p = format; *p; p++) {
  if (*p != '%') {
    putchar(*p);
    continue;
  }

  // do things when '%' is found
}
\end{minted}
When \texttt{\%} is found, we need to check the next character and determine what data type we need to retrieve from the unamed argument list:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
for (p = format; *p; p++) {
  if (*p != '%') {
    putchar(*p);
    continue;
  }

  switch (*++p) {  // check next char
  case 'd':
    ival = va_arg(ap, int);
    printf("%d", ival);
    break;
  }
  case 'f':
    dval = va_arg(ap, double);
    printf("%f", dval);
    break;
  case 's':
    for (sval = va_arg(ap, char*); *sval; sval++)
      putchar(*sval);
    break;
  default:
    putchar(*p);
    break;
}
\end{minted}
When the style token after \texttt{\%} is \texttt{s}, it means we have to print a string. So the return type of \texttt{va\_arg} is a pointer to \texttt{char}. We print the C-string one character by one character, until we reach the \texttt{'\textbackslash{}0'} terminator.

\subsection{Formated Input: \texttt{scanf()}}
\label{sec:orgb49388f}
p171.

\subsubsection{A simple example}
\label{sec:orge2c2c52}
An example of using \texttt{scanf()}:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#include <stdio.h>

int main() {
  int a;
  int b;
  int c;
  int d;
  int num;
  scanf("%d%d%d%d", &a, &b, &c, &d);
  printf("a = %d\nb = %d\nc = %d\nd = %d\n", a, b, c, d);

  return 0;
}
\end{minted}
here, we read four inputs and store them to four variables. Notice we have to pass in the address of each variable to \texttt{scanf()}. In this way, \texttt{scanf()} can modify the variable directly (passed by value).

\subsubsection{Declaration and arguments}
\label{sec:orgc2629b6}
\texttt{scanf()} is declared as:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int scanf(char *format, ...)
\end{minted}

It will use the \texttt{format} string to retrieve information via certain format, convert them and assign to variables in the followed list. \texttt{scanf()} stops when it exhausts its format string, or when some input fails to match the control specification. It returns the number of successfully matched and assigned input items (to variable in the unamed argument lists).

The \texttt{format} string may contain:
\begin{enumerate}
\item blanks or tabs. These will be automatically ignored
\item ordinary characters (not \texttt{\%}). \texttt{scanf()} will try to match these characters with the corresponding non-whitespace character of the input stream. For example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
scanf("%dabcde%d", &a, &b);
printf("a = %d\nb = %d\n", a, b);
\end{minted}
input: \texttt{1abcde2}, output:
\begin{verbatim}
a = 1
b = 2
\end{verbatim}
\item conversion specifications, which is explained below.
\end{enumerate}

A conversion specification is some characters starting with \texttt{\%}, which will be used by \texttt{scanf()} to convert the next \textbf{input field} and assign to corresponding variable. An input field is defined as a string of non-white space characters; it extends either to the next white space character or until the field width has been reached (the width of the field may be specified by conversion specification, see below).

In the conversion specification, we may find:
\begin{itemize}
\item \%: indicating starting of a conversion specification
\item *: assignment suppresion marker. If this is present, the input field is skipped, no assignment to variable is made
\item number: a number that specifies the maximum width of the input field (of which this current conversion specification is taking care)
\item \texttt{h, l or L}: indicating the width of the target. \texttt{\%h}: a short integer; \texttt{\%l}: a long integer.
\item a conversion character: indicating what type to convert to, like \texttt{\%d, \%c, \%s} etc. (i.e. the interpretation of the input field).
\end{itemize}

Some examples of using \texttt{scanf()} can be found on p172, 173.

\subsection{File Access}
\label{sec:org5b1cc03}
\subsubsection{Opening a file}
\label{sec:orgdef26a3}
The \texttt{<stdio.h>} library has a type \texttt{FILE} and a function \texttt{fopen()} that provides tools to work on files. The function \texttt{fopen()}'s declaration is as follows:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
FILE *fopen(char* name, char* mode)
\end{minted}
It accepts the name of the file and mode for opening this file. It will return a pointer to a \texttt{FILE} object. The type \texttt{FILE} is defined with a \texttt{typedef}, and is a structure that contains information about the file, such as:
\begin{itemize}
\item location of a buffer
\item current character position in the buffer
\item file openning mode: read or write
\item error states: if error has occurred
\item EOF states: whether end of file has occurred
\end{itemize}

To obtain a pointer to a file, we do:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
FILE* fp;
fp = fopen(name, mode);
\end{minted}
the allowable modes include:
\begin{itemize}
\item r: read mode
\item w: write mode
\item a: append mode
\item b: append b to open in binary mode (for some systems)
\end{itemize}

When errors occurred during file opening, \texttt{fopen()} will return a \texttt{NULL}.
\subsubsection{Accessing the file}
\label{sec:org4a6f15a}
Once the file is opened, we access it through the \texttt{FILE} pointer \texttt{fp}. We have following choices:
\begin{itemize}
\item \texttt{char getc(FILE *fp)}: (maybe) a macro that accepts a \texttt{FILE} pointer, returns the next character from the file (character position is recorded inside the \texttt{FILE} object). It returns \texttt{EOF} for end of file or error.
\item \texttt{char putc(char c, FILE *fp)}: (maybe) a macro that accepts a character \texttt{c} and a \texttt{FILE} pointer. It will write \texttt{c} to the file and returns the character written, or returns \texttt{EOF} if an error occurs.
\end{itemize}

After using the file, we have to call \texttt{fclose()} to disconnect program from the file, freeing the file pointer for another file.

\subsubsection{\texttt{stdin}, \texttt{stdout} and \texttt{stderr}}
\label{sec:org4f4f3de}
When a C program is started, the operating system environment is responsible for opening three files and providing file pointers for them to the program. These files are:
\begin{itemize}
\item standard input, file pointer: \texttt{stdin}
\item standard output, file pointer: \texttt{stdout}
\item standard error, file pointer: \texttt{stderr}
\end{itemize}
These file pointers are declared in \texttt{<stdio.h>}. Normally, \texttt{stdin} is connected to the keyboard, \texttt{stdout} and \texttt{stderr} are connected to the screen. \texttt{stdin} and \texttt{stdout} may be redirected to files or pipes as described earlier. Pay attention that \texttt{stderr} normally appears on the screen even if the standard output is redirected, this prevents error message disappearing down the pipeline. 

Since C programs use these three file pointers to communicate with outside components, when we get char from input, or print char on output, we are actually getting or printing these characters via these file pointers to the final destination (standard input, standard output and standard error). Thus, \texttt{getchar()} and \texttt{putchar(c)} can be defined in terms of \texttt{getc, putc, stdin} and \texttt{stdout} as:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
#define getchar() getc(stdin)
#define putchar(c) putc((c), stdout)
\end{minted}

\subsubsection{Formatted input and output of files}
\label{sec:org109af3f}
To format input or output of files, we can use \texttt{fscanf()} and \texttt{fprintf()}. These functions are similar with \texttt{scanf()} and \texttt{printf()}, except the firs argument is a file pointer. The declaration of these two functions are:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int fscanf(FILE *fp, char* format, ...)
int fprintf(FILE *fp, char* format, ...)
\end{minted}

An example of sending formated error message to \texttt{stderr} is:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
fprintf(stderr, "Error occurred!\n");
\end{minted}
\subsubsection{Example: replicate program \texttt{cat}}
\label{sec:orgc738dc9}
p176: normal error handling

p177: advanced error handling (using \texttt{stderr} and \texttt{exit()})
\subsubsection{Line input and output}
\label{sec:org4333733}
The standard library provides an input routine \texttt{fgets()}, which can reads the next input line (including \texttt{'\textbackslash{}n'} character) from a \texttt{FILE} pointer to a char array. It will return a \texttt{char} pointer pointing to this char array. Its declaration is as follows:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
char *fgets(char* line, int maxline, FILE *fp);
\end{minted}
At most \texttt{maxline - 1} characters will be read. The resulting line is automatically terminated with \texttt{'\textbackslash{}0'}. When end of file reached or error occurred, it returns \texttt{NULL}.

The standard library provides an output routine \texttt{fputs()}, which can write a string (which need not contain a newline) to a file. The declaration is as follows:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int fputs(char* line, FILE *fp);
\end{minted}
It returns \texttt{EOF} if an error occurs, and zero otherwise.

The library functions \texttt{gets} and \texttt{puts} are similar to \texttt{fgets} and \texttt{fputs}, but operate on \texttt{FILE} pointers \texttt{stdin} and \texttt{stdout}. \texttt{gets} deletes the terminal \texttt{'\textbackslash{}n'}, and \texttt{puts} adds it.
\subsection{MISC Functions}
\label{sec:org959aba3}
\subsubsection{Storage Management}
\label{sec:org4bfeaa8}
Two functions are used to obtain blocks of memory dynamically:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
void* malloc(size_t n);
void* calloc(size_t n, size_t size);
\end{minted}

\texttt{malloc()} will return a pointer to \texttt{n} bytes of uninitialized storage, or \texttt{NULL} if the request cannot be satisfied.

\texttt{calloc()} will return a pointer to enough space for an array of \texttt{n} objects of the specified size, or \texttt{NULL} if the request cannot be satisfied. The storage is initialized to zero.

The pointer returned by \texttt{malloc()} or \texttt{calloc()} has the proper alignment for the object requested (proper amount of memory), however, it must be case into the appropriate type before assigning to a pointer to hold. For example:
\begin{minted}[breaklines=true,breakanywhere=true]{c}
int* ip;
ip = (int*) calloc(n, sizeof(int));
\end{minted}

To free the space pointed by a pointer \texttt{p}, of which initially obtained by a call to \texttt{malloc()} or \texttt{calloc()}, we can call \texttt{free(p)}.
\section{Place Holder}
\label{sec:org1b2749b}
\end{document}
