% Created 2019-10-12 Sat 06:23
% Intended LaTeX compiler: pdflatex
\documentclass[12pt]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[margin=1in] {geometry}
\usepackage{parskip}
\usepackage{fontspec}
\setmainfont{Times New Roman}
\setmonofont{Droid Sans Mono}[SizeFeatures={Size=10}]
\linespread {1.5}
\setcounter{tocdepth} {6}
\setcounter{secnumdepth} {6}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.2 (Org mode 9.2.3)}, 
 pdflang={English}}
\begin{document}

\tableofcontents

\part{Modules}
\label{sec:orgd8b1e15}
\chapter{\texttt{csv}}
\label{sec:org501af71}
Python's \texttt{csv} module in the standard library parses the lines in a CSV file and allows us to quickly extract the values we're interested in. Here we'll present an example to read data from a csv file:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
import csv


filename = 'my_csv_file.csv'
with open(filename) as f:
    reader = csv.reader(f)
\end{minted}
After the above code, reader contains an iterator that associated with the file content. Each iterated element in reader is a list containing the content of each line in the original file, with each element is element separated by coma. Pay attention that if you close the file (``disconnect'' the file object with the file), this \texttt{reader} will not be able to access the content in file.

\section{\texttt{reader()}}
\label{sec:org942f3d4}
\href{https://docs.python.org/3/library/csv.html\#csv.reader}{Documentation}
This is a member function. It accepts any object which supports the iterator protocol (by providing these methods: \texttt{\_\_iter\_\_()}, \texttt{\_\_next\_\_()}) and returns a string each time its \texttt{\_\_next\_\_()} method is called (file object and list object are both suitable).

It will return a reader object associated with the file. The reader object will iterate over lines in the given csv file. You need to use a variable to hold the returned reader object.

Data in csv file has following structure: Rows separated by newline character, and record separated by a coma in a single line. For example:
\begin{verbatim}
course name, time, credit hour, grade
COP 4530, fall 19, 3, A
COP 4531, fall 19, 3, A
CDA 3101, fall 19, 3, A
COP 4610, fall 19, 3, A
COT 4420, fall 19, 3, A
\end{verbatim}

Reader object somehow read each row and transfer them into a list of strings, each item separated by the coma is an element in the list. Reader object is iterable over rows. It has struture like:
\begin{verbatim}
["course name", "time", "credit hour", "grade"]
["COP 4530", "fall 19", "3", "A"]
["COP 4531", "fall 19", "3", "A"]
["CDA 3101", "fall 19", "3", "A"]
["COP 4610", "fall 19", "3", "A"]
["COT 4420", "fall 19", "3", "A"]
\end{verbatim}
Each row read from the csv file is returned as a list of strings. No automatic data type conversion is performed.

Reader object behaves like an iterator: it has \texttt{\_\_iter\_\_()} and \texttt{\_\_next\_\_()} defined. When calling \texttt{\_\_iter\_\_()}, it will return itself. 
\chapter{\texttt{datetime}}
\label{sec:org00b3cad}
\href{https://docs.python.org/3/library/datetime.html}{Documentation}

This module is used when you need object that representing date and time. Such object have many applications, for example:
\begin{itemize}
\item pass in as variable to be ploted in matplotlib
\end{itemize}

\section{\texttt{datetime}}
\label{sec:orgc1740b3}
This is a class defined in datetime module (\href{https://docs.python.org/3/library/datetime.html\#datetime.datetime}{Documentation}). An object of \texttt{datetime} type is a single object containing all the information from a \texttt{date} object and a \texttt{time} object. It assumes that there are exactly 3600 * 24 seconds in every day.

It can be printed directly by pass it into \texttt{print()}.
\subsection{\texttt{strptime()}}
\label{sec:org1d2213b}
This is a method inside \texttt{datetime} class, it can be used to convert a string of date information to python's datetime type. It accepts two arguments: \texttt{date\_string} and \texttt{format}. \texttt{date\_string} contains the information of your date, \texttt{format} contains rules to parse the \texttt{date\_string}. It will return a \texttt{datetime} object corresponding to the \texttt{date\_string}, parsed according to \texttt{format}. For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
import datetime


date = datetime.datetime.strptime('2014x7x1', '%Yx%mx%d')
print(date)
\end{minted}
Output:
\begin{verbatim}
2014-07-01 00:00:00
\end{verbatim}
The \texttt{\%Yx} part is telling python to parse the part of the string before the first \texttt{x} as a \textbf{four-digit} year (if lower case y is provided, then it will be \textbf{two-digit} year: \texttt{\%yx}). Similarly, \texttt{\%m} is to parse month, and \texttt{\%d} is to parse the day of the month. The original values of year, month and day should be valid (including leap years), otherwise, \texttt{ValueError} will rise.

The \texttt{strptime()} method can take a variety of arguments to determine how to interpret the date. You can find more \href{https://docs.python.org/3/library/datetime.html\#strftime-and-strptime-behavior}{here}.

\section{\texttt{strptime()}}
\label{sec:org9ca3bbd}

\chapter{\texttt{matplotlib}}
\label{sec:org211ad6f}
\section{\texttt{pyplot}}
\label{sec:org5630ead}
\subsection{\texttt{plot()} (plot line)}
\label{sec:org80dea49}
\subsubsection{Pass a sequence of number into \texttt{pyplot.plot()}}
\label{sec:org969b8d4}
We start with a simple example. Plot a list of numbers.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
import matplotlib.pyplot as plt

squares = [1, 4, 9, 16, 25]
plt.plot(squares)
plt.show()
\end{minted}
We first imported a class in \texttt{matplotlib}. The class name is \texttt{pyplot}, we give it an alias \texttt{plt}. Then we created a list of numbers, then call member function \texttt{plt.plot()} and pass the list into the function. After that, the figure is shown by calling member function \texttt{plt.show()}. This function opens \texttt{matplotlib}'s viewer and displays the plot.

When you give \texttt{pyplot.plot()} a sequence of numbers, it assumes the first data point corresponds to an x-coordinate value of 0. Thus, in the above example, we are actually plotting following data points:
\begin{verbatim}
(0, 1), (1, 4), (2, 9), (3, 16), (4, 25)
\end{verbatim}
\subsubsection{Pass two sequences of number into \texttt{pyplot.plot()}}
\label{sec:orgb13d6a5}
We can pass two sequences of number into \texttt{plot()}, which will represent the x value and y value. For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
x_value = [1, 2, 3, 4, 5]
squares = [1, 4, 9, 16, 25]
plt.plot(x_value, squares, linewidth=5)
\end{minted}
Two sequences passed into the \texttt{pyplot.plot()} function should have same dimension, otherwise, a \texttt{ValueError} will be thrown.

You can plot multiple data sets on the same xy coordinates. Just provide the corresponding x and y sequences. For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
x_value = [1, 2, 3, 4, 5]
cubes = [1, 8, 27, 64, 125]
squares = [1, 4, 9, 16, 25]
plt.plot(x_value, squares, x_value, cubes, linewidth=5)
\end{minted}

You can also divide them into two calls of \texttt{pyplot.plot()}:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
x_value = [1, 2, 3, 4, 5]
cubes = [1, 8, 27, 64, 125]
squares = [1, 4, 9, 16, 25]
plt.plot(x_value, cubes, linewidth=5)
plt.plot(x_value, squares, linewidth=5)
\end{minted}
They will still be ploted into the same figure. You have to mannualy arrange different data set. The first and second data set will be evaluated as \texttt{x1} and \texttt{y1}, if only one data set is provided, it will be evaluated as \texttt{y}, and use default \texttt{[0, 1, 2, 3, ...]} as \texttt{x}.
\subsubsection{line width}
\label{sec:orgb28ffca}
The line width of the curve can be set by:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.plot(squares, linewidth=5)
\end{minted}

\subsection{\texttt{scatter()} (plot scatter)}
\label{sec:org8764ffb}
\subsubsection{Single point}
\label{sec:org4889ef7}
To plot single point, use \texttt{pyplot.scatter()}. It accepts at lease two arguments, corresponding to the x and y coordinates of the point. For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.scatter(float(input("Scatter x:")), float(input("Scatter y:")), s=200)
\end{minted}
The argument \texttt{s} is used to set the size of the scatter.
\subsubsection{Sequence of plot}
\label{sec:org2b2bd73}
We can plot a series of points using \texttt{scatter()}. Just pass lists of x- and y-values:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.scatter([1, 2, 3, 4, 5], [5, 6, 7, 1, 4], s=100)
plt.show()
\end{minted}
You must provide x- and y-value at the same time (no default value of x will be used, unlike \texttt{plot()}), otherwise, \texttt{TypeError} will be thrown. Also, the dimension of x- and y-value lists must be the same, other \texttt{ValueError} will be thrown.
\subsubsection{Set outline color of points}
\label{sec:orgf21b845}
Default points have outline. You can set the edge color to the one you want. For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.scatter(x_values, y_values, s=20, edgecolors='red')  # change to red
plt.scatter(x_values, y_values, s=20, edgecolors='none')  # remove outline
\end{minted}
The order of the style arguments are not affecting the result.

\subsubsection{Set fill color of points}
\label{sec:org28afd2d}
The fill color of points can be set by \texttt{c}:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.scatter(x_values, y_values, s=20, edgecolors='red', c='none')
\end{minted}

\subsection{\texttt{fill\_between()}}
\label{sec:org00832b7}
This method takes one series of x-values and two series of y-values, and fills the space between the two y-value series over the series of x-values. For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
from matplotlib import pyplot as plt


y_1 = [3, 4, 5, 3, 2, 3, 4]
y_2 = [5, 4, 2, 2, 6, 7, 8]
plt.plot(y_1, c='red')
plt.plot(y_2, c='black')
plt.scatter(list(range(len(y_1))), y_1, c='red')
plt.scatter(list(range(len(y_2))), y_2, c='black')

plt.fill_between(list(range(len(y_1))), y_1, y_2, facecolor='red', alpha=0.1)
plt.show()
\end{minted}

The \texttt{alpha} argument controls a color's transparency. 0: transparent, 1 (default) is completely opaque.

\subsection{Member Functions to Adjust Figure Appearance}
\label{sec:orga87c78b}
In this section, several member functions are presented to adjust figure appearance.

\subsubsection{\texttt{.title()}}
\label{sec:orgc9f1ae4}
Add title of the image. The size of the title can also be adjusted.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.title("Square Numbers", fontsize=24)
\end{minted}

\subsubsection{\texttt{.xlabel()}, \texttt{.ylabel()}}
\label{sec:orgd2d0ed0}
Set the x label and y label
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.xlabel("Value", fontsize=14)
\end{minted}

\subsubsection{\texttt{.tick\_params()} (adjust tick label of axis)}
\label{sec:org3c9a9a9}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.tick_params(axis='both', labelsize=14)
\end{minted}

\subsubsection{set x, y axis range}
\label{sec:orgdd096da}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.axis([x_0, x_1, y_0, y_1])
\end{minted}

\subsubsection{remove axis}
\label{sec:org2af8ca7}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.axes().get_xaxis().set_visible(False)
plt.axes().get_yaxis().set_visible(False)
\end{minted}
\subsubsection{set color}
\label{sec:orgb89b219}
\href{https://matplotlib.org/2.0.2/api/colors\_api.html}{Documentation}
When you set the color of a object (by passing arguments to \texttt{c}), you can either pass a string to indicate its color (e.g. \texttt{edgecolor='red'}), or a tuple with three decimal values (correspond to red, green and blue). The range of the value is from 0 to 1. It is calculated by deviding RGB value with 255. So, a RGB color of R42, G160, B151 should be \texttt{(0.164, 0.627, 0.592)}. Example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.scatter(x_values, y_values, s=20, edgecolors=(0.16, 0.63, 0.59), c='none')
\end{minted}

\subsubsection{use colormap}
\label{sec:org1147327}
\emph{Colormap} is a series of colors in a gradient that moves from a starting to ending color. Colormap allows you to emphasize a pattern in the data. For example, you might make low values a light color and high values a darker color.

Take the square scatter as an example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
import matplotlib.pyplot as plt
x_values = [x for x in range(1, 100)]
y_values = [x**2 for x in x_values]

plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Greens, edgecolor='none', s=40)

plt.show()
\end{minted}
We first set \texttt{y\_values} to \texttt{c}, this tells python to use color maps to set the color of the point with regard to the \texttt{y\_values}. You can set the specific colormap you want to use by \texttt{cmap=plt.cm.xxx}, where \texttt{xxx} is the name of color map you wish to use. The names and visual effect of different colormaps can be found \href{https://matplotlib.org/examples/color/colormaps\_reference.html}{here}.

\subsection{\texttt{.figure} (create a new \texttt{Figure} object)}
\label{sec:orgf6d9e7e}
\href{https://matplotlib.org/3.1.0/api/\_as\_gen/matplotlib.pyplot.figure.html}{Documentation}

\texttt{figure()} will create a new object of \href{https://matplotlib.org/3.1.0/api/\_as\_gen/matplotlib.figure.Figure.html\#matplotlib-figure-figure}{figure}. Check the documentation page for parameter list. The object will also be passed to new\_figure\_manager in the backends, which allows to hook custom \texttt{Figure} classes into the pyplot interface.

To set the size of the figure:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.figure(figsize=(a, b))
\end{minted}
The \texttt{figsize} parameter takes a tuple, which is the dimensions of the plotting window in inches. Python assumes that the screen resolution is 80 pixels per inch. You can use another parameter \texttt{dpi} to tell python the resolution of your screen:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.figure(dpi=128, figsize=(10, 6))
\end{minted}

You can use a variable to hold the \texttt{Figure} object returned by this method. Then you can call method defined inside \texttt{Figure} class to further adjust your figure. For example: \texttt{fig.autofmt\_xdate()} can draw the date labels in x axis diagonally to prevent them from overlapping (first used in \emph{Python Crash Course}, project 2).

\subsection{Utility Member Functions}
\label{sec:org4853202}
\subsubsection{\texttt{savefig()}}
\label{sec:org4a9fa2a}
You can save the figure by calling \texttt{.savefig()} member function. Example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
plt.savefig('squares_plot.svg', bbox_inches='tight')
\end{minted}
The first argument is a filename for the plot image, which will be saved to the same directory as your python file. The second argument trims extra whitespace from the plot.
\chapter{\texttt{numpy}}
\label{sec:org463ec7d}
\section{Array in Numpy}
\label{sec:orgd292ce2}
The key to \texttt{NumPy} is the array object defined inside it. It is an n-dimensional array of homogeneous types, with many operations being performed in compiled code for performance (higher efficiency). Compared with standard python sequences, array in \texttt{NumPy} has following feature:
\begin{enumerate}
\item Size is fixed. Modifying the size means creating a new array
\item Data type stored in each entry of the array must be the same
\item More efficienct mathematical operations
\end{enumerate}

We have many different ways to create a \texttt{NumPy} array. In general, any numerical data that is stored in an array-like container can be converted to a \texttt{NumPy} array through use of array function (\texttt{numpy.array()}). You just provide the sequence container as input.

Other functions you can use:
\subsection{\texttt{numpy.zeros()}}
\label{sec:orgdc0a3f1}
Accepts a tuple or list which indicates the shape of the zero matrix. It will return a matrix of that shape filled with zeros.
\subsection{\texttt{numpy.ones()}}
\label{sec:org4f7f3b8}
Same as \texttt{numpy.zeros()}, the filled value will be 1.
\subsection{\texttt{numpy.arange()}}
\label{sec:orgbcc4894}
\subsubsection{\texttt{arange(num)}}
\label{sec:org92527a9}
Accepts number. It will return a 1-D array, containing values from \texttt{0} to \texttt{num - 1}. By default, the value type is the same type as the input number, but you can change it to other data types (the basic data types defined in \texttt{numpy}). Also, the default step size is 1. For example:
\begin{minted}[breaklines=true,breakanywhere=true]{python}
import numpy as np
x = np.arange(5.5)
print(x)
\end{minted}
result:
\begin{verbatim}
[0. 1. 2. 3. 4. 5.]
\end{verbatim}


\subsubsection{\texttt{arange(num, dtype=)}}
\label{sec:org9cdc48c}
Similar with \texttt{arange(num)}, excepts that the type of the filled value is determined by the flag \texttt{dtype}. For example: \texttt{numpy.arange(num, dtype=numpy.float32)}.
\subsubsection{\texttt{arange(start, end)}}
\label{sec:org6ca0792}
Accepts two numbers. It will return a 1-D array, containing values from \texttt{start} to \texttt{end - 1}. Default data type will be determined by the type of \texttt{start} and \texttt{end}. If one of them is integer, another is float, then the returned array will contain float values. Default step size is also one.
\subsubsection{\texttt{arange(start, end, stepsize)}}
\label{sec:orgc5406a4}
Similar with \texttt{arange(start, end)}, you can add a third parameter which determines the step size.
\subsection{\texttt{numpy.linspace()}}
\label{sec:org0eb6857}
This function creates arrays containing elements that are spaced equally between the specified beginning and end values.
\subsubsection{\texttt{numpy.linspace(start, end)}}
\label{sec:org9210e48}
It accepts two numbers, and it will return a 1-D array that contains 50 numbers that are spaced equally over \texttt{[start, end]}. 50 is the default number of elements created between \texttt{[start, end]}.
\subsubsection{\texttt{numpy.linspace(start, end, num)}}
\label{sec:orgf149d97}
It is similar with the above one, but the number of elements is given at the third parameter \texttt{num}.
\subsection{\texttt{numpy.random.random()}}
\label{sec:org8ff276f}
This function accepts a tuple (or list) that define the shape of a matrix. It will return a matrix filled with random numbers (in range [0, 1)) in that shape.
\section{Member function and attribute  of \texttt{numpy}'s array}
\label{sec:orgf4de09e}
\subsection{\texttt{.min()}}
\label{sec:org8515fb2}
Return the minimum element.
\subsection{\texttt{.ravel()}}
\label{sec:orgc76949f}
This function will return a 1-D array that contains all element of the calling array. The original array is not modified.
\subsection{\texttt{.reshape()}}
\label{sec:orgf97fdb9}
Accepts tuple or direct number indicating the shape you want to change into. It will return a \textbf{COPY} of the matrix in changed shape. The original array is not affected. Example:
\begin{minted}[breaklines=true,breakanywhere=true]{python}
import numpy as np
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(x)
print(x.reshape(3, 3))
\end{minted}
result:
\begin{verbatim}
[1 2 3 4 5 6 7 8 9]
[[1 2 3]
 [4 5 6]
 [7 8 9]]
\end{verbatim}
\subsection{\texttt{.resize()}}
\label{sec:org2c33db3}
Similar with \texttt{.reshape()}. Except this function will modify the calling array in place.
\subsection{\texttt{.shape}}
\label{sec:org6dae002}
This is an attribute of the array class. It defines the shape of the array. You can assign a tuple to it to change the shape of the array. The number of elements in the array should be able to fill in the shape you changed, otherwise a \texttt{ValueError} will arise. Example:
\begin{minted}[breaklines=true,breakanywhere=true]{python}
import numpy as np
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(x)
x.shape = (3, 3)
print(x)
\end{minted}
result:
\begin{verbatim}
[1 2 3 4 5 6 7 8 9]
[[1 2 3]
 [4 5 6]
 [7 8 9]]
\end{verbatim}
\subsection{\texttt{.sum()}}
\label{sec:org9973402}
Return the summation of all elements.
\subsection{\texttt{.transpose()}}
\label{sec:org553026a}
This function will return a transposed version of the calling array. The original array is not modified.
\section{Array operations}
\label{sec:org2891ada}
Basic operations apply element-wise. The result is a new array with the resultant elements. Example:
\begin{verbatim}
>>> a = np.arange(5)
>>> b = np.arange(5)
>>> a + b
array([0, 2, 4, 6, 8])
>>> a - b
array([0, 0, 0, 0, 0])
>>> a > 3
array([False, False, False, False, True])
\end{verbatim}

Operations like \texttt{*=} and \texttt{+=} will modify the original array.
\section{Linear Algebra Operations}
\label{sec:org1ef4c80}
\subsection{Matrix multiplication}
\label{sec:org45cc834}
You can't use \texttt{*} to perform a matrix multiplication since it is done element-wise. You have to call a function defined in \texttt{numpy} to do the matrix multiplication: \texttt{numpy.dot(a, b)}.
\subsection{Matrix transpose}
\label{sec:org7902734}
You can transpose an array by calling its member function: \texttt{a.transpose()}. It will return a transposed \texttt{a}, original array will not be modified.
\subsection{Matrix inverse}
\label{sec:org77dcc75}
There is a function (\texttt{inv()}) that is defined in \texttt{numpy.linalg.inv()} that accepts an array and it will return the inverse of the array. You have to make sure the array is a \texttt{n} by \texttt{n} matrix.
\subsection{Creating unit matrix}
\label{sec:org4416f1e}
Function \texttt{numpy.linalg.eye()} can do this. You have to pass in the parameter that determines its size.
\subsection{Calculating trace of a matrix}
\label{sec:orgb93354d}
Function \texttt{numpy.trace()} can do this. You have to pass in the array you want to know trace of. If the matrix is not square, you'll get a ``partial'' trace.
\subsection{Solve linear matrix equation}
\label{sec:org46b20bc}
Function \texttt{numpy.linalg.solve()} can do this. For example, we have the following equations:
\begin{align*}
x_1 + 2x_2 &= 5 \\
3x_1 + 4x_2 &= 7
\end{align*}

Use matrix notation:
\begin{verbatim}
ax = y
|1 2| |x1| |5|
|3 4| |x2| |7|
\end{verbatim}

To solve for x, we call \texttt{numpy.linalg.solve(a, y)}. It will return the solution matrix. Code:
\begin{minted}[breaklines=true,breakanywhere=true]{python}
import numpy as np
a = np.array([[1, 2], [3, 4]])
y = np.array([[5.], [7.]])

print(np.linalg.solve(a, y))
\end{minted}
result:
\begin{verbatim}
[[-3.]
 [ 4.]]
\end{verbatim}
\subsection{Get eigenvalues/eigenvectors of matrix}
\label{sec:orgce6bf3c}
Function \texttt{numpy.linalg.eig()} can do this. You pass in a matrix, it will return its eigen value and eigen vector.

\chapter{\texttt{pygal}}
\label{sec:org0bc1bd1}
\href{http://pygal.org/en/stable/documentation/index.html}{Documentation}

\section{\texttt{Chart Configuration}}
\label{sec:org69ecc39}
Pygal is customized at chart level with the help of the \texttt{Config} class. You can view the complete configuration attributes in \href{http://www.pygal.org/en/stable/documentation/configuration/chart.html}{here} (name of each configuration you can use for your chart, and how you can use it).
\section{\texttt{Bar}}
\label{sec:orge0cae3a}
\texttt{Bar} is a nested class inside \texttt{pygal}. Use this to create an object of a histogram. Each object of histogram has its own data set, as well as the styling information stored as attributes. They can be manipulated by the member function (methods) defined in \texttt{pygal.Bar}. To declare a \texttt{Bar} object:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
hist = pygal.Bar()
\end{minted}
(without any parameters)

\subsection{\texttt{attributes}}
\label{sec:org35a5418}
\subsubsection{\texttt{title}}
\label{sec:org06cc8f6}
\texttt{title} stores the title of the histogram objects. You can set the title of the histogram directly by assigning this attribute with a string. Example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
hist.title = "Your Histogram Title"
\end{minted}
Other attributes work the same way. You can assign them directly with the value you wish.
\subsubsection{\texttt{x\_labels}}
\label{sec:orga10b1d3}
This attribute will add x label. You can assign it with a list of strings, they will be used to label the data in x direction. For example, if your have added a list: \texttt{[5, 4, 3, 1, 6]} to the \texttt{Bar} object, and want to plot histogram based on this. You can add x labels corresponding to each value, for example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
hist = Bar()
worked_hour = [5, 4, 3, 1, 6]
hist.add('work hour', worked_hour)
hist.x_labels = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
\end{minted}
When you render the histogram, these labels will be under each bar.
\subsubsection{\texttt{y\_labels}}
\label{sec:org161e9bb}
You can also set y labels, but it can override the default label that reflect the y value.
\subsubsection{\texttt{x\_title}}
\label{sec:org82bd697}
\subsubsection{\texttt{y\_title}}
\label{sec:org53b05eb}
\subsection{\texttt{member functions}}
\label{sec:orge55d6b2}
\subsubsection{\texttt{.add()}}
\label{sec:orgfb8ce63}
This function accepts two arguments: \texttt{add('title', value)}. You can pass in positionally. First is title and the second is value. The title is the name of this group of data, and value is your data set (can be a single number, which will only have one bar).

You can add multiple data set to one \texttt{Bar} object. Notice that python will not check if there is a naming conflict (duplicate names are permitted).

Pay attention that value added should be number (int or float), otherwise, a \texttt{TypeError} will rise. When you work with files, you may read the data in string format, be sure to convert them to numbers.

The \texttt{title} should be filled. If you don't want to add title, use an empty string: ''.

The bar created is interactive. You can customize the tooltip (which is shown when you hover your mouse above the bar) by passing in a list of dictionaries into the \texttt{add()} method, instead of a list of values. Each element in the list is a dictionary with two key-value pairs. Key \texttt{'value'} will be associated with the value, and key \texttt{'label'} will be associated with customized tooltip you want.

Each dictionary in list of dictionaries can be expanded to give the bar image more functions. For example, you can add clickable links to the bar. Just wrap the url link in the dictionary with key \texttt{'xlink'} (its value is set to the url link).
\subsubsection{\texttt{.render\_to\_file()}}
\label{sec:orge3bc669}
This function will render the data in the \texttt{Bar} object and save it to a file. The filename is passed in when calling the function. For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
hist.render_to_file('my_plot.svg')
\end{minted}
\section{\texttt{i18n}}
\label{sec:org2be3757}
Pygal's country codes (two-letter codes) are stored in this module. \texttt{i18n} is short for \emph{internationalization}. The dictionary \texttt{COUNTRIES} inside this module contains the two-letter country codes as keys and the country names as values.

The \texttt{i18n} module is in \texttt{pygal\_maps\_world} (which is a separate module from \texttt{pygal}). You can access \texttt{COUNTRIES} in following way:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
from pygal_maps_world.i18n import COUNTRIES
\end{minted}
\section{\texttt{World}}
\label{sec:org8a07e83}
Pygal includes a \texttt{World} class (which is a chart type, just like \texttt{Bar} is also a chart type). This chart can help to plot global data sets on a map. To use it, we declare an object of this class:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
import pygal


wm = pygal.maps.world.World()
\end{minted}
Pay attention where is the class located. We can also simplify the expression:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
from pygal.maps.world import World


wm = World()
\end{minted}
Current version of PyCharm (2019.1.2) will report error that \texttt{world} and \texttt{World} is not found, but you can still use it.
\subsection{Attributes}
\label{sec:org2b74f10}
You can modify these attributes of the \texttt{World} object.
\subsubsection{\texttt{title}}
\label{sec:orga4ad247}
The title of the image:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
from pygal.maps.world import World


wm = World()
wm.title = 'World Map'
\end{minted}

\subsection{Functions}
\label{sec:org22bf1cf}
\subsubsection{\texttt{add()}}
\label{sec:orge5f1105}
This is used to set which country is highlighted on the final chart, as well as adding numeric data to those countries. Similar with \texttt{Bar.add()}.

It accepts two parameters, the first one is a string that contains the name of the group. The second one can be a list containing 2-digit country code (in string format) (these countries will be grouped together and have same color on the final image). For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
from pygal.maps.world import World


wm = World()
wm.title = 'North America'

wm.add('North America', ['ca', 'mx', 'us'])
\end{minted}
The rendered file will ``light'' the corresponding region that is indicated in the list you passed in.

If you want to pass numeric data to theose countries, you use a dictionary instead of a list in the \texttt{add()} function. The key should be the 2-digit country code, value should be numeric value that you want to pass to the country. By default, pygal uses these numbers to shade the countries from light (less in value) to dark (more in value). Example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
from pygal.maps.world import World


wm = World()
wm.title = 'Populations of Countries in North America'
wm.add('North America', {'ca': 341260000, 'us': 309349000, 'mx': 113423000})
wm.render_to_file('North America Population.svg')
\end{minted}

\subsubsection{\texttt{render\_to\_file()}}
\label{sec:orge821c6b}
This method accepts one parameter, which is the filename of the file you want to render. It can also be relative path or path. For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
wm.render_to_file('americas.svg')
\end{minted}

\section{\texttt{style}}
\label{sec:org3c6b601}
\href{http://www.pygal.org/en/stable/documentation/styles.html}{Documentation}

This sub-module contains predefined ways (classes) to style your chart. When creating a new pygal chart object (for example, \texttt{hist = Bar()}), you can pass the \texttt{style} parameter with different objects declared based on the classes in \texttt{style}. For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
from pygal.style import LightSolarizedStyle
chart = pygal.StackedLine(fill=True, style=LightSolarizedStyle)
\end{minted}
or:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
from pygal.style import RotateStyle
from pygal.maps.world import World

world_map_style = RotateStyle('#336699')
world_map = World(style=world_map_style)
\end{minted}
\subsection{\texttt{RotateStyle}}
\label{sec:org8a1a0df}
\href{http://www.pygal.org/en/stable/documentation/parametric\_styles.html\#rotate}{Documentation}

Examples to use:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
from pygal.style import RotateStyle
from pygal.maps.world import World

world_map_style = RotateStyle('#336699')
world_map = World(style=world_map_style)
\end{minted}
This \texttt{RotateStyle} class takes one argument, an RGB color in hex format. Pygal then chooses colors for each of the groups based on the color provided. The format of the RGB color is:
\begin{verbatim}
#rrggbb
rr: red component of the color
gg: green component of the color
bb: blue component of the color
The range of the color is 00 to FF
\end{verbatim}

The style object can be used when creating a pygal chart object. You just need to pass it as a keyword argument when you declare a chart object (\texttt{style=style\_object}).

\chapter{\texttt{random}}
\label{sec:org6a79d1b}
\section{\texttt{choice()}}
\label{sec:org4328dc2}
\href{https://docs.python.org/3/library/random.html\#random.choice}{Documentation}

\texttt{choice()} is a member function defined in \texttt{random} module. It has several overloads.

\subsection{\texttt{choice(sequence)} \label{orgd7595ba}}
\label{sec:orga28cab3}
It accepts a sequence type, and will return a random element in the passed in sequence. If the sequence is empty, an \texttt{IndexError} will be thrown.

\section{\texttt{randint()}}
\label{sec:org26dc575}
\href{https://docs.python.org/3/library/random.html\#random.randint}{Documentation}
It accepts two arguments a, b. It will return a random integer \texttt{N}, such that \texttt{a <= N <= b}.

It is alias for \texttt{randrange(a, b + 1)}.

\chapter{\texttt{request}}
\label{sec:org21ae69b}
\href{https://2.python-requests.org/en/master/}{Documentation}

This module is used to work with API requests.

\section{\texttt{get()}}
\label{sec:orgf4d453c}
\href{https://2.python-requests.org/en/master/api/\#requests.get}{Documentation}

This function accepts an url, it will send a GET request and return the \href{https://2.python-requests.org/en/master/api/\#requests.Response}{response object}. You can hold the response object using a variable. This object contains a server's response to an HTTP request. For example:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
# make an API call and store the response to a variable
url = 'https://api.github.com/search/repositories?q=language:python&sort=stars'
r = requests.get(url)
print("Status code:", r.status_code)
\end{minted}
Output:
\begin{verbatim}
Status code: 200
\end{verbatim}
The member \texttt{status\_code} contains the status of accessing the url. 200 means normal access. (if you visit google from mainland China, you will get 404).

\section{\texttt{Response}}
\label{sec:org824bd49}
This is a class that contains a server's response to an HTTP request.
\end{document}
