\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}ifndef DL\PYGZus{}LIST\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}define DL\PYGZus{}LIST\PYGZus{}H}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}

\PYG{k}{namespace} \PYG{n}{cop4530} \PYG{p}{\PYGZob{}}

  \PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
    \PYG{k}{class} \PYG{n+nc}{List} \PYG{p}{\PYGZob{}}
      \PYG{k}{private}\PYG{o}{:}
	\PYG{c+c1}{// nested Node class}
	\PYG{k}{struct} \PYG{n}{Node} \PYG{p}{\PYGZob{}}
	\PYG{c+c1}{// declared later}
	\PYG{p}{\PYGZcb{};}

      \PYG{k}{public}\PYG{o}{:}
	\PYG{c+c1}{//nested const\PYGZus{}iterator class}
	\PYG{k}{class} \PYG{n+nc}{const\PYGZus{}iterator} \PYG{p}{\PYGZob{}}
	\PYG{c+c1}{// declared later}
	\PYG{p}{\PYGZcb{};}

	\PYG{c+c1}{// nested iterator class}
	\PYG{k}{class} \PYG{n+nc}{iterator} \PYG{o}{:} \PYG{k}{public} \PYG{n}{const\PYGZus{}iterator} \PYG{p}{\PYGZob{}}
	\PYG{c+c1}{// declared later}
	\PYG{p}{\PYGZcb{};}

      \PYG{k}{public}\PYG{o}{:}
	\PYG{c+c1}{// constructor, desctructor, copy constructor}
	\PYG{n}{List}\PYG{p}{();} \PYG{c+c1}{// default zero parameter constructor}
	\PYG{n}{List}\PYG{p}{(}\PYG{k}{const} \PYG{n}{List} \PYG{o}{\PYGZam{}}\PYG{n}{rhs}\PYG{p}{);} \PYG{c+c1}{// copy constructor}
	\PYG{n}{List}\PYG{p}{(}\PYG{n}{List} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{rhs}\PYG{p}{);} \PYG{c+c1}{// move constructor}
	\PYG{c+c1}{// num elements with value of val}
	\PYG{k}{explicit} \PYG{n+nf}{List}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{num}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val} \PYG{o}{=} \PYG{n}{T}\PYG{p}{\PYGZob{}\PYGZcb{});}
	\PYG{c+c1}{// constructs with elements [start, end)}
	\PYG{n}{List}\PYG{p}{(}\PYG{n}{const\PYGZus{}iterator} \PYG{n}{start}\PYG{p}{,} \PYG{n}{const\PYGZus{}iterator} \PYG{n}{end}\PYG{p}{);}

	\PYG{o}{\PYGZti{}}\PYG{n}{List}\PYG{p}{();} \PYG{c+c1}{// destructor}

	\PYG{c+c1}{// copy assignment operator}
	\PYG{k}{const} \PYG{n}{List}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{List} \PYG{o}{\PYGZam{}}\PYG{n}{rhs}\PYG{p}{);}
	\PYG{c+c1}{// move assignment operator}
	\PYG{n}{List} \PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{=}\PYG{p}{(}\PYG{n}{List} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{rhs}\PYG{p}{);}

	\PYG{c+c1}{// member functions}
	\PYG{k+kt}{int} \PYG{n+nf}{size}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;} \PYG{c+c1}{// number of elements}
	\PYG{k+kt}{bool} \PYG{n+nf}{empty}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;} \PYG{c+c1}{// check if list is empty}
	\PYG{k+kt}{void} \PYG{n+nf}{clear}\PYG{p}{();} \PYG{c+c1}{// delete all elements}
	\PYG{k+kt}{void} \PYG{n+nf}{reverse}\PYG{p}{();} \PYG{c+c1}{// reverse the order of the elements}

	\PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{front}\PYG{p}{();} \PYG{c+c1}{// reference to the first element}
	\PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{front}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
	\PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{back}\PYG{p}{();} \PYG{c+c1}{// reference to the last element}
	\PYG{k}{const} \PYG{n}{T} \PYG{o}{\PYGZam{}} \PYG{n}{back}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

	\PYG{k+kt}{void} \PYG{n+nf}{push\PYGZus{}front}\PYG{p}{(}\PYG{k}{const} \PYG{n}{T} \PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{);} \PYG{c+c1}{// insert to the beginning}
	\PYG{k+kt}{void} \PYG{n+nf}{push\PYGZus{}front}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{val}\PYG{p}{);} \PYG{c+c1}{// move version of insert}
	\PYG{k+kt}{void} \PYG{n+nf}{push\PYGZus{}back}\PYG{p}{(}\PYG{k}{const} \PYG{n}{T} \PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{);} \PYG{c+c1}{// insert to the end}
	\PYG{k+kt}{void} \PYG{n+nf}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{T} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{val}\PYG{p}{);} \PYG{c+c1}{// move version of insert}
	\PYG{k+kt}{void} \PYG{n+nf}{pop\PYGZus{}front}\PYG{p}{();} \PYG{c+c1}{// delete first element}
	\PYG{k+kt}{void} \PYG{n+nf}{pop\PYGZus{}back}\PYG{p}{();} \PYG{c+c1}{// delete last element}

	\PYG{k+kt}{void} \PYG{n+nf}{remove}\PYG{p}{(}\PYG{k}{const} \PYG{n}{T} \PYG{o}{\PYGZam{}}\PYG{n}{val}\PYG{p}{);} \PYG{c+c1}{// remove all elements with value = val}

	\PYG{c+c1}{// print out all elements. ofc is deliminitor}
	\PYG{k+kt}{void} \PYG{n+nf}{print}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{os}\PYG{p}{,} \PYG{k+kt}{char} \PYG{n}{ofc} \PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{} \PYGZsq{}}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

	\PYG{n}{iterator} \PYG{n+nf}{begin}\PYG{p}{();} \PYG{c+c1}{// iterator to first element}
	\PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{begin}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}
	\PYG{n}{iterator} \PYG{n+nf}{end}\PYG{p}{();} \PYG{c+c1}{// end marker iterator}
	\PYG{n}{const\PYGZus{}iterator} \PYG{n+nf}{end}\PYG{p}{()} \PYG{k}{const}\PYG{p}{;}

	\PYG{n}{iterator} \PYG{n+nf}{insert}\PYG{p}{(}\PYG{n}{iterator} \PYG{n}{itr}\PYG{p}{,} \PYG{k}{const} \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{val}\PYG{p}{);} \PYG{c+c1}{// insert val ahead of itr}
	\PYG{n}{iterator} \PYG{n+nf}{insert}\PYG{p}{(}\PYG{n}{iterator} \PYG{n}{itr}\PYG{p}{,} \PYG{n}{T} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{n}{val}\PYG{p}{);} \PYG{c+c1}{// move version of insert}

	\PYG{n}{iterator} \PYG{n+nf}{erase}\PYG{p}{(}\PYG{n}{iterator} \PYG{n}{itr}\PYG{p}{);} \PYG{c+c1}{// erase one element}
	\PYG{n}{iterator} \PYG{n+nf}{erase}\PYG{p}{(}\PYG{n}{iterator} \PYG{n}{start}\PYG{p}{,} \PYG{n}{iterator} \PYG{n}{end}\PYG{p}{);} \PYG{c+c1}{// erase [start, end)}


      \PYG{k}{private}\PYG{o}{:}
	\PYG{k+kt}{int} \PYG{n}{theSize}\PYG{p}{;} \PYG{c+c1}{// number of elements}
	\PYG{n}{Node} \PYG{o}{*}\PYG{n}{head}\PYG{p}{;} \PYG{c+c1}{// head node}
	\PYG{n}{Node} \PYG{o}{*}\PYG{n}{tail}\PYG{p}{;} \PYG{c+c1}{// tail node}

	\PYG{k+kt}{void} \PYG{n+nf}{init}\PYG{p}{();} \PYG{c+c1}{// initialization}
    \PYG{p}{\PYGZcb{};}

  \PYG{c+c1}{// overloading comparison operators}
  \PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
  \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}} \PYG{n}{lhs}\PYG{p}{,} \PYG{k}{const} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{rhs}\PYG{p}{);}

  \PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
  \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}} \PYG{n}{lhs}\PYG{p}{,} \PYG{k}{const} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{rhs}\PYG{p}{);}

  \PYG{c+c1}{// overloading output operator}
  \PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}}
  \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream} \PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream} \PYG{o}{\PYGZam{}}\PYG{n}{os}\PYG{p}{,} \PYG{k}{const} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{l}\PYG{p}{);}

  \PYG{c+c1}{// include the implementation file here}
  \PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZdq{}List.hpp\PYGZdq{}}

\PYG{p}{\PYGZcb{}} \PYG{c+c1}{// end of namespace 4530}

\PYG{c+cp}{\PYGZsh{}endif}
\end{Verbatim}
