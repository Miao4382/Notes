\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}pragma once}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{} // for hash\PYGZlt{}std::string\PYGZgt{}}

\PYG{k}{class} \PYG{n+nc}{Employee} \PYG{p}{\PYGZob{}}
\PYG{k}{private}\PYG{o}{:}
  \PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{name}\PYG{p}{;} \PYG{c+c1}{//name will be used as key}
  \PYG{k+kt}{double} \PYG{n}{salary}\PYG{p}{;}

\PYG{k}{public}\PYG{o}{:}
  \PYG{c+c1}{//constructor}
  \PYG{n}{Employee}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{string} \PYG{n}{n} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}N/A\PYGZdq{}}\PYG{p}{,} \PYG{k+kt}{double} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{:} \PYG{n}{name}\PYG{p}{\PYGZob{}}\PYG{n}{n}\PYG{p}{\PYGZcb{},} \PYG{n}{salary}\PYG{p}{\PYGZob{}}\PYG{n}{s}\PYG{p}{\PYGZcb{}} \PYG{p}{\PYGZob{}\PYGZcb{}}

  \PYG{c+c1}{//name accessor}
  \PYG{k}{const} \PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZam{}} \PYG{n}{getName}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{name}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{//salary accessor}
  \PYG{k+kt}{double} \PYG{n}{getSalary}\PYG{p}{()} \PYG{k}{const} \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{salary}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{//equality operator}
  \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{==}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Employee}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{getName}\PYG{p}{()} \PYG{o}{==} \PYG{n}{rhs}\PYG{p}{.}\PYG{n}{getName}\PYG{p}{();}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{//non\PYGZhy{}equal operator}
  \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{!=}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Employee}\PYG{o}{\PYGZam{}} \PYG{n}{rhs}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{o}{!}\PYG{p}{(}\PYG{o}{*}\PYG{k}{this} \PYG{o}{==} \PYG{n}{rhs}\PYG{p}{);}
  \PYG{p}{\PYGZcb{}}

  \PYG{c+c1}{//overload \PYGZlt{}\PYGZlt{} to enable printing class info}
  \PYG{k}{friend} \PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{k}{operator}\PYG{o}{\PYGZlt{}\PYGZlt{}}\PYG{p}{(}\PYG{n}{std}\PYG{o}{::}\PYG{n}{ostream}\PYG{o}{\PYGZam{}} \PYG{n}{oi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Employee}\PYG{o}{\PYGZam{}} \PYG{n}{obj}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{oi} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s}{\PYGZdq{}Name: \PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{obj}\PYG{p}{.}\PYG{n}{name} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s}{\PYGZdq{}   Salary: \PYGZdl{} \PYGZdq{}} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{n}{obj}\PYG{p}{.}\PYG{n}{salary} \PYG{o}{\PYGZlt{}\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}\PYGZbs{}n\PYGZsq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{oi}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{};}

\PYG{c+c1}{//define a version of hash function that specifically accepts this Employee type, and return the \PYGZdq{}integerized\PYGZdq{} key of this Employee class.}
\PYG{c+c1}{//this implementation is in the Employee class declaration file, which means the Employee class objects provide a hash function that specifically work for them}
\PYG{k}{template}\PYG{o}{\PYGZlt{}\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{hash}\PYG{o}{\PYGZlt{}}\PYG{n}{Employee}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZob{}}
\PYG{k}{public}\PYG{o}{:}
  \PYG{k+kt}{size\PYGZus{}t} \PYG{k}{operator}\PYG{p}{()(}\PYG{k}{const} \PYG{n}{Employee}\PYG{o}{\PYGZam{}} \PYG{n}{item}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{n}{std}\PYG{o}{::}\PYG{n}{hash}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{::}\PYG{n}{string}\PYG{o}{\PYGZgt{}} \PYG{n}{hf}\PYG{p}{;} \PYG{c+c1}{// declare an hash function object}
    \PYG{k}{return} \PYG{n+nf}{hf}\PYG{p}{(}\PYG{n}{item}\PYG{p}{.}\PYG{n}{getName}\PYG{p}{());} \PYG{c+c1}{//the returned value of item.getName() will be used as key of item, which is a string}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{};}
\end{Verbatim}
