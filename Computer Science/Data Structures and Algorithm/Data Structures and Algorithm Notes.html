<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-05-07 Tue 10:27 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8e68a4a">1. Data Structures</a>
<ul>
<li><a href="#org3a3cda9">1.1. Vector</a></li>
<li><a href="#org5b3fc76">1.2. List</a></li>
<li><a href="#org822418d">1.3. Stack</a></li>
<li><a href="#org23cd417">1.4. Queue</a></li>
<li><a href="#orga0ad149">1.5. Tree</a>
<ul>
<li><a href="#orga222a02">1.5.1. Binary Search Tree</a>
<ul>
<li><a href="#org8ac7873">1.5.1.1. General Idea</a></li>
<li><a href="#orgd86228f">1.5.1.2. Simple Implementation</a>
<ul>
<li><a href="#orgb32237c">1.5.1.2.1. Tree node structure</a></li>
<li><a href="#org3ecfe00">1.5.1.2.2. <code>zero parameter constructor</code></a></li>
<li><a href="#org0ef7130">1.5.1.2.3. <code>copy constructor</code></a></li>
<li><a href="#orgfb2b22a">1.5.1.2.4. <code>move constructor</code></a></li>
<li><a href="#org95f4a33">1.5.1.2.5. <code>destructor</code></a></li>
<li><a href="#orgba3dbbf">1.5.1.2.6. <code>copy assignment operator</code></a></li>
<li><a href="#org3ede88a">1.5.1.2.7. <code>move assignment operator</code></a></li>
<li><a href="#org977a2f7">1.5.1.2.8. public <code>findMin()</code></a></li>
<li><a href="#org8b70199">1.5.1.2.9. public <code>findMax()</code></a></li>
<li><a href="#orgb5d5a6a">1.5.1.2.10. public <code>contains()</code></a></li>
<li><a href="#orgc9d267a">1.5.1.2.11. public <code>makeEmpty()</code></a></li>
<li><a href="#orgd3635b1">1.5.1.2.12. public <code>insert()</code></a></li>
<li><a href="#org8810f4e">1.5.1.2.13. public <code>remove()</code></a></li>
<li><a href="#org31f0f8e">1.5.1.2.14. public <code>isEmpty()</code></a></li>
<li><a href="#org4a67947">1.5.1.2.15. public <code>printTree()</code></a></li>
<li><a href="#org3b044d8">1.5.1.2.16. <code>insert()</code></a></li>
<li><a href="#orgff08f58">1.5.1.2.17. <code>remove()</code></a></li>
<li><a href="#org7ccee52">1.5.1.2.18. <code>findMin()</code></a></li>
<li><a href="#orgd4104c4">1.5.1.2.19. <code>findMax()</code></a></li>
<li><a href="#org8ca3248">1.5.1.2.20. <code>contains()</code></a></li>
<li><a href="#org6ddee50">1.5.1.2.21. <code>makeEmpty()</code></a></li>
<li><a href="#orgacf492e">1.5.1.2.22. <code>printTree()</code></a></li>
<li><a href="#orgb4f07a2">1.5.1.2.23. <code>clone()</code></a></li>
</ul>
</li>
<li><a href="#org1509b74">1.5.1.3. Problem with Simple Binary Search Tree</a></li>
</ul>
</li>
<li><a href="#org5a4c922">1.5.2. AVL Tree</a>
<ul>
<li><a href="#orgbc106ff">1.5.2.1. General Idea</a></li>
<li><a href="#orga07c233">1.5.2.2. Simple Implementation (recursive)</a></li>
</ul>
</li>
<li><a href="#org6827b6b">1.5.3. Red Black Tree</a>
<ul>
<li><a href="#orgc4acd71">1.5.3.1. General Idea</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6d2dcff">1.6. Hash Table</a>
<ul>
<li><a href="#org5800ae8">1.6.1. General Idea</a>
<ul>
<li><a href="#orgea4f5c7">1.6.1.1. Key</a></li>
<li><a href="#org7cb7383">1.6.1.2. Vector/Array</a></li>
</ul>
</li>
<li><a href="#org59b9b1b">1.6.2. Hash Function</a>
<ul>
<li><a href="#orgd7a7516">1.6.2.1. Hash Function Object</a></li>
<li><a href="#orged5befa">1.6.2.2. Hash Function in C++ STL</a></li>
</ul>
</li>
<li><a href="#org82a6414">1.6.3. Collision Management</a>
<ul>
<li><a href="#orgdb5c8fb">1.6.3.1. Separate chaining</a></li>
<li><a href="#org07418ec">1.6.3.2. Probing</a>
<ul>
<li><a href="#orgc2ffaff">1.6.3.2.1. Linear probing</a></li>
<li><a href="#orgb0d8d25">1.6.3.2.2. Quadritic probing</a></li>
</ul>
</li>
<li><a href="#org1656dea">1.6.3.3. Double hashing</a></li>
</ul>
</li>
<li><a href="#orgd53eb91">1.6.4. Simple Implementation</a>
<ul>
<li><a href="#org55e51c5">1.6.4.1. Separate Chaining</a>
<ul>
<li><a href="#org9726cde">1.6.4.1.1. <code>Constructor</code></a></li>
<li><a href="#orgf3ce793">1.6.4.1.2. <code>contains()</code></a></li>
<li><a href="#org1fdf990">1.6.4.1.3. <code>makeEmpty()</code></a></li>
<li><a href="#orgf3e0c23">1.6.4.1.4. <code>insert()</code></a></li>
<li><a href="#orgdcab737">1.6.4.1.5. <code>remove()</code></a></li>
<li><a href="#org3e860ca">1.6.4.1.6. <code>myhash()</code></a></li>
<li><a href="#org7d8260c">1.6.4.1.7. <code>rehash()</code></a></li>
</ul>
</li>
<li><a href="#orgedf3f4f">1.6.4.2. Quadratic Probing</a>
<ul>
<li><a href="#org57e87d2">1.6.4.2.1. <code>constructor</code></a></li>
<li><a href="#org8601da7">1.6.4.2.2. <code>contains()</code></a></li>
<li><a href="#org2af08f6">1.6.4.2.3. <code>makeEmpty()</code></a></li>
<li><a href="#org3f4cc70">1.6.4.2.4. <code>insert()</code></a></li>
<li><a href="#org2a4cbea">1.6.4.2.5. <code>remove()</code></a></li>
<li><a href="#orgb6a8c73">1.6.4.2.6. <code>isActive()</code></a></li>
<li><a href="#orgf57c405">1.6.4.2.7. <code>findPos()</code></a></li>
<li><a href="#org459a85e">1.6.4.2.8. <code>rehash()</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org821d14b">1.7. Priority Queue</a>
<ul>
<li><a href="#org6188963">1.7.1. General Idea</a></li>
<li><a href="#org40a98a8">1.7.2. Simple Implementation</a>
<ul>
<li><a href="#orge570ae7">1.7.2.1. Structure Property</a></li>
<li><a href="#org9116d57">1.7.2.2. Binary Heap Class</a></li>
<li><a href="#org17fb0d1">1.7.2.3. <code>insert()</code></a></li>
<li><a href="#org5fc73d9">1.7.2.4. <code>deleteMin()</code></a></li>
<li><a href="#org661002e">1.7.2.5. <code>percolateDown()</code></a></li>
<li><a href="#orge7a60c4">1.7.2.6. <code>buildHeap()</code></a>
<ul>
<li><a href="#org340a486">1.7.2.6.1. Analysis and Implementation</a></li>
<li><a href="#org784bf2b">1.7.2.6.2. Complexity Analysis</a></li>
<li><a href="#org95d0c79">1.7.2.6.3. Build Heap by <code>insert()</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc260164">2. Sorting</a>
<ul>
<li><a href="#org0312230">2.1. Bubble Sort</a>
<ul>
<li><a href="#org8d27df1">2.1.1. General Idea</a></li>
<li><a href="#org5337e0d">2.1.2. Implementation</a></li>
</ul>
</li>
<li><a href="#org9cfdac1">2.2. Insertion Sort</a>
<ul>
<li><a href="#org65e8fd9">2.2.1. General Idea</a></li>
<li><a href="#orgd2412ca">2.2.2. Implementation</a></li>
<li><a href="#orgdb72c20">2.2.3. Lower Bound</a></li>
</ul>
</li>
<li><a href="#org188902a">2.3. Shell Sort</a>
<ul>
<li><a href="#org1d74320">2.3.1. General Idea</a></li>
<li><a href="#orgc314a45">2.3.2. Implementation</a></li>
<li><a href="#org9982f92">2.3.3. Worst-Case (Shell's increment sequence)</a></li>
<li><a href="#org5f6d7ff">2.3.4. Hibbard's increment sequence</a></li>
</ul>
</li>
<li><a href="#orgbdadc39">2.4. Heap Sort</a>
<ul>
<li><a href="#org17aa484">2.4.1. General Idea</a></li>
<li><a href="#orge9795f9">2.4.2. Implementation</a>
<ul>
<li><a href="#org4be4f52">2.4.2.1. Analysis</a></li>
<li><a href="#orgd7301c0">2.4.2.2. Build up heap order</a></li>
<li><a href="#org18a4293">2.4.2.3. Sort Using Heap Order</a></li>
</ul>
</li>
<li><a href="#org7bb57bf">2.4.3. Complexity Analysis</a>
<ul>
<li><a href="#org8c0f1a5">2.4.3.1. Build Heap</a></li>
<li><a href="#org2eded4a">2.4.3.2. Sort</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org70f87d5">2.5. Merge Sort</a>
<ul>
<li><a href="#org3a6a086">2.5.1. General Idea</a></li>
<li><a href="#org2c81953">2.5.2. Implementation</a></li>
</ul>
</li>
<li><a href="#orgcf6ddbc">2.6. Quick Sort</a>
<ul>
<li><a href="#org390386c">2.6.1. General Idea</a></li>
<li><a href="#org8da50cb">2.6.2. Picking the Pivot</a></li>
<li><a href="#orgb679696">2.6.3. Partition Strategy</a></li>
<li><a href="#org1736aad">2.6.4. Small Arrays</a></li>
<li><a href="#org78e513d">2.6.5. Implementations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org82eaa73">3. Gimmicks</a>
<ul>
<li><a href="#org8c723ba">3.1. C++ Related</a>
<ul>
<li><a href="#orgfb3bd67">3.1.1. Create a Vector Using its Iterator</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-org8e68a4a" class="outline-2">
<h2 id="org8e68a4a"><span class="section-number-2">1</span> Data Structures</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org3a3cda9" class="outline-3">
<h3 id="org3a3cda9"><span class="section-number-3">1.1</span> Vector</h3>
</div>
<div id="outline-container-org5b3fc76" class="outline-3">
<h3 id="org5b3fc76"><span class="section-number-3">1.2</span> List</h3>
</div>
<div id="outline-container-org822418d" class="outline-3">
<h3 id="org822418d"><span class="section-number-3">1.3</span> Stack</h3>
</div>
<div id="outline-container-org23cd417" class="outline-3">
<h3 id="org23cd417"><span class="section-number-3">1.4</span> Queue</h3>
</div>
<div id="outline-container-orga0ad149" class="outline-3">
<h3 id="orga0ad149"><span class="section-number-3">1.5</span> Tree</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-orga222a02" class="outline-4">
<h4 id="orga222a02"><span class="section-number-4">1.5.1</span> Binary Search Tree</h4>
<div class="outline-text-4" id="text-1-5-1">
</div>
<div id="outline-container-org8ac7873" class="outline-5">
<h5 id="org8ac7873"><span class="section-number-5">1.5.1.1</span> General Idea</h5>
<div class="outline-text-5" id="text-1-5-1-1">
<p>
A binary search tree is a binary tree implemented with the following rule: a node's left child is no larger than the node; a node's right child is no smaller than the node; Under this rule, it is clear that the smallest node in binary search tree is the leftmost node, while the largest node is the rightmost node.
</p>
</div>
</div>
<div id="outline-container-orgd86228f" class="outline-5">
<h5 id="orgd86228f"><span class="section-number-5">1.5.1.2</span> Simple Implementation</h5>
<div class="outline-text-5" id="text-1-5-1-2">
<p>
In this section, a simple binary search tree template will be implemented. The header of the class would be:
</p>
<div class="org-src-container">
<pre class="src src-c++">template &lt;typename comparable&gt;
class BinarySearchTree {

};
</pre>
</div>
<p>
<code>comparable</code> is the name of a class that supports comparison by <code>operator&lt;()</code>. Since the building of binary search tree requires ordering of nodes.
</p>

<p>
The header file of binary search tree class template is as follows:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>#pragma once
<span class="linenr"> 2: </span>#include &lt;iostream&gt;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>template &lt;typename comparable&gt;
<span class="linenr"> 5: </span>class BinarySearchTree {
<span class="linenr"> 6: </span>private:
<span class="linenr"> 7: </span>  //nested tree node structure
<span class="linenr"> 8: </span>  struct BinaryNode {};
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>private:
<span class="linenr">11: </span>  BinaryNode* root;
<span class="linenr">12: </span>
<span class="linenr">13: </span>private:
<span class="linenr">14: </span>  /** private operating functions **/
<span class="linenr">15: </span>  ///insert 
<span class="linenr">16: </span>  void insert(const comparable&amp; val, BinaryNode* &amp; t); //copy
<span class="linenr">17: </span>  void insert(comparable&amp;&amp; val, BinaryNode* &amp; t); //move
<span class="linenr">18: </span>
<span class="linenr">19: </span>  ///remove
<span class="linenr">20: </span>  void remove(const comparable&amp; val, BinaryNode* &amp; t);
<span class="linenr">21: </span>
<span class="linenr">22: </span>  ///search 
<span class="linenr">23: </span>  BinaryNode* findMin(BinaryNode* t) const;
<span class="linenr">24: </span>  BinaryNode* findMax(BinaryNode* t) const;
<span class="linenr">25: </span>  bool contains(const comparable&amp; val, BinaryNode* t) const;
<span class="linenr">26: </span>
<span class="linenr">27: </span>  ///utility
<span class="linenr">28: </span>  void makeEmpty(BinaryNode* &amp; t);
<span class="linenr">29: </span>  void printTree(BinaryNode* t, std::ostream&amp; out) const;
<span class="linenr">30: </span>  BinaryNode* clone(BinaryNode* t) const;
<span class="linenr">31: </span>
<span class="linenr">32: </span>public:
<span class="linenr">33: </span>  /** Constructor and destructor **/
<span class="linenr">34: </span>  BinarySearchTree(); //zero-parameter default constructor
<span class="linenr">35: </span>  BinarySearchTree(const BinarySearchTree&amp; rhs); //copy constructor
<span class="linenr">36: </span>  BinarySearchTree(BinarySearchTree&amp;&amp; rhs); //move constructor
<span class="linenr">37: </span>  ~BinarySearchTree(); //destructor
<span class="linenr">38: </span>
<span class="linenr">39: </span>  /** Assignment operator **/
<span class="linenr">40: </span>  BinarySearchTree&amp; operator=(const BinarySearchTree&amp; rhs); //copy
<span class="linenr">41: </span>  BinarySearchTree&amp; operator=(BinarySearchTree&amp;&amp; rhs); //move
<span class="linenr">42: </span>
<span class="linenr">43: </span>  /** Public Search Interface **/
<span class="linenr">44: </span>  const comparable&amp; findMin() const;
<span class="linenr">45: </span>  const comparable&amp; findMax() const;
<span class="linenr">46: </span>  bool contains(const comparable&amp; val) const;
<span class="linenr">47: </span>
<span class="linenr">48: </span>  /** Modification of tree **/
<span class="linenr">49: </span>  void makeEmpty();
<span class="linenr">50: </span>  void insert(const comparable&amp; val);//copy version
<span class="linenr">51: </span>  void insert(comparable&amp;&amp; val);//move version
<span class="linenr">52: </span>  void remove(const comparable&amp; val);
<span class="linenr">53: </span>
<span class="linenr">54: </span>  /** Utility **/
<span class="linenr">55: </span>  bool isEmpty() const;
<span class="linenr">56: </span>  void printTree(std::ostream&amp; out = std::cout) const;  
<span class="linenr">57: </span>
<span class="linenr">58: </span>};
<span class="linenr">59: </span>
<span class="linenr">60: </span>//include implementation here 
<span class="linenr">61: </span>#include "bst.hpp"
</pre>
</div>

<p>
An object of <code>BinarySearchTree</code> class holds a private data member <code>root</code>, which is a pointer to <code>TreeNode</code> type, holds the address of the root of a binary tree. The implementation of <code>TreeNode</code> structure and other member functions are detailed below.
</p>
</div>

<div id="outline-container-orgb32237c" class="outline-6">
<h6 id="orgb32237c"><span class="section-number-6">1.5.1.2.1</span> Tree node structure</h6>
<div class="outline-text-6" id="text-1-5-1-2-1">
<p>
A tree node contains three data members, one is <code>comparable</code> type and is used to hold the data of that node. The other two are pointer to tree node, which will be used to hold the address of the node's left and right child. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>struct BinaryNode {
<span class="linenr"> 2: </span>  comparable element;//data stored in the node, and it is comparable (at least one comparable routine is defined for this type)
<span class="linenr"> 3: </span>  BinaryNode* left;
<span class="linenr"> 4: </span>  BinaryNode* right;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  ///constructor
<span class="linenr"> 7: </span>  //copy
<span class="linenr"> 8: </span>  BinaryNode(const comparable&amp; val = val{}, BinaryNode* lt = nullptr, BinaryNode* rt = nullptr) : element {val}, left {lt}, right {rt} {}
<span class="linenr"> 9: </span>  //move
<span class="linenr">10: </span>  BinaryNode(comparable&amp;&amp; val = val{}, BinaryNode* lt = nullptr, BinaryNode* rt = nullptr) : element {std::move(val)}, left {lt}, right {rt} {}
<span class="linenr">11: </span>};
</pre>
</div>
</div>
</div>

<div id="outline-container-org3ecfe00" class="outline-6">
<h6 id="org3ecfe00"><span class="section-number-6">1.5.1.2.2</span> <code>zero parameter constructor</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-2">
<p>
Just initialize <code>root</code> pointer as <code>nullptr</code>. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>BinarySearchTree&lt;comparable&gt;::BinarySearchTree() : root {nullptr} {}
</pre>
</div>
</div>
</div>

<div id="outline-container-org0ef7130" class="outline-6">
<h6 id="org0ef7130"><span class="section-number-6">1.5.1.2.3</span> <code>copy constructor</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-3">
<p>
This constructor accepts another object of <code>BinarySearchTree</code> class. It will call an internal recursive routine <code>clone()</code> to finish copying and building. The details of the process is in <code>clone()</code> function. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>BinarySearchTree&lt;comparable&gt;::BinarySearchTree(const BinarySearchTree&amp; rhs) {
<span class="linenr">3: </span>  root = clone(rhs.root);
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfb2b22a" class="outline-6">
<h6 id="orgfb2b22a"><span class="section-number-6">1.5.1.2.4</span> <code>move constructor</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-4">
<p>
It is very simple to move, we just need to "bring" rhs's root to our root, and redirect <code>rhs.root</code> to <code>nullptr</code>. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>BinarySearchTree&lt;comparable&gt;::BinarySearchTree(BinarySearchTree&amp;&amp; rhs) {
<span class="linenr">3: </span>  root = rhs.root;
<span class="linenr">4: </span>  rhs.root = nullptr;
<span class="linenr">5: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org95f4a33" class="outline-6">
<h6 id="org95f4a33"><span class="section-number-6">1.5.1.2.5</span> <code>destructor</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-5">
<p>
Just call <code>makeEmpty()</code> routine, all memories will be recycled. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>BinarySearchTree&lt;comparable&gt;::~BinarySearchTree() {
<span class="linenr">3: </span>  makeEmpty();
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgba3dbbf" class="outline-6">
<h6 id="orgba3dbbf"><span class="section-number-6">1.5.1.2.6</span> <code>copy assignment operator</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-6">
<p>
We call <code>clone()</code> to do the copy and building work. Since this is assignment operator, don't forget return value. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>BinarySearchTree&lt;comparable&gt;&amp; BinarySearchTree&lt;comparable&gt;::operator=(const BinarySearchTree&amp; rhs) {
<span class="linenr">3: </span>  root = clone(rhs.root);
<span class="linenr">4: </span>  return *this;
<span class="linenr">5: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3ede88a" class="outline-6">
<h6 id="org3ede88a"><span class="section-number-6">1.5.1.2.7</span> <code>move assignment operator</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-7">
<p>
Take <code>rhs</code>'s root directly. Remember the return. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>BinarySearchTree&lt;comparable&gt;&amp; BinarySearchTree&lt;comparable&gt;::operator=(BinarySearchTree&amp;&amp; rhs) {
<span class="linenr">3: </span>  root = rhs.root;
<span class="linenr">4: </span>  rhs.root = nullptr;
<span class="linenr">5: </span>  return *this;
<span class="linenr">6: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org977a2f7" class="outline-6">
<h6 id="org977a2f7"><span class="section-number-6">1.5.1.2.8</span> public <code>findMin()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-8">
<p>
This function is in <code>public</code> domain. It will return the constant reference of the minimum node in the tree. Like many other public member functions, this function will call a private version of <code>findMin()</code> to actually finish the job. This is because of the recursive nature of the tree data structure, many functions will work recursively. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>const comparable&amp; BinarySearchTree&lt;comparable&gt;findMin() const {
<span class="linenr">3: </span>  return (findMin(root))-&gt;element;
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8b70199" class="outline-6">
<h6 id="org8b70199"><span class="section-number-6">1.5.1.2.9</span> public <code>findMax()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-9">
<p>
Similar with <code>findMin()</code>. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>const comparable&amp; BinarySearchTree&lt;comparable&gt;::findMax() const {
<span class="linenr">3: </span>  return (findMax(root))-&gt;element;
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb5d5a6a" class="outline-6">
<h6 id="orgb5d5a6a"><span class="section-number-6">1.5.1.2.10</span> public <code>contains()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-10">
<p>
This function accepts a parameter <code>val</code> of type <code>comparable</code>. It will search the tree for the existence of <code>val</code>. It will call a private recursive version of <code>contains()</code>. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>bool BinarySearchTree&lt;comparable&gt;::contains(const comparable&amp; val) const {
<span class="linenr">3: </span>  return contains(val, root);
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc9d267a" class="outline-6">
<h6 id="orgc9d267a"><span class="section-number-6">1.5.1.2.11</span> public <code>makeEmpty()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-11">
<p>
This function will clear all nodes (reclaim their memory) in the tree. It will call a private recursive version of <code>makeEmpty()</code>. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>void BinarySearchTree&lt;comparable&gt;::makeEmpty() {
<span class="linenr">3: </span>  makeEmpty(root);
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd3635b1" class="outline-6">
<h6 id="orgd3635b1"><span class="section-number-6">1.5.1.2.12</span> public <code>insert()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-12">
<p>
This function accepts a parameter <code>val</code> of type <code>comparable</code>. It will call a private recursive version of <code>insert()</code> to insert <code>val</code> into the tree (to the proper position where <code>val</code> should go). Code (copy version):
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>void BinarySearchTree&lt;comparable&gt;::insert(const comparable&amp; val) {
<span class="linenr">3: </span>  insert(val, root);
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8810f4e" class="outline-6">
<h6 id="org8810f4e"><span class="section-number-6">1.5.1.2.13</span> public <code>remove()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-13">
<p>
This function accepts a parameter <code>val</code> of type <code>comparable</code>. It will call a private recursive version of <code>remove()</code> to remove <code>val</code> from the tree. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>void BinarySearchTree&lt;comparable&gt;::remove(const comparable&amp; val) {
<span class="linenr">3: </span>  remove(val, root);
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org31f0f8e" class="outline-6">
<h6 id="org31f0f8e"><span class="section-number-6">1.5.1.2.14</span> public <code>isEmpty()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-14">
<p>
This function will check if the tree is empty. The criteria is simple: if the root is <code>nullptr</code>, then the tree is empty. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>bool BinarySearchTree&lt;comparable&gt;::isEmpty() const {
<span class="linenr">3: </span>  if (root == nullptr)
<span class="linenr">4: </span>    return true;
<span class="linenr">5: </span>  else 
<span class="linenr">6: </span>    return false;
<span class="linenr">7: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org4a67947" class="outline-6">
<h6 id="org4a67947"><span class="section-number-6">1.5.1.2.15</span> public <code>printTree()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-15">
<p>
This function accepts a <code>std::ostream</code> object <code>out</code>. It will call a private version of <code>printTree()</code> and pass this object into it, to print the tree in in-order (in ascending order). Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename comparable&gt;
<span class="linenr">2: </span>void BinarySearchTree&lt;comparable&gt;::printTree(std::ostream&amp; out) const {
<span class="linenr">3: </span>  printTree(root, out);
<span class="linenr">4: </span>} 
</pre>
</div>
</div>
</div>

<div id="outline-container-org3b044d8" class="outline-6">
<h6 id="org3b044d8"><span class="section-number-6">1.5.1.2.16</span> <code>insert()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-16">
<p>
The private recursive version of <code>insert()</code>. Implemented recursively. It accepts two parameters: a <code>comparable</code> type <code>val</code>, and a pointer to <code>TreeNode</code> type <code>t</code>. The function can insert the value into the subtree whose root is indicated by <code>t</code>. Its working steps are:
</p>
<ul class="org-ul">
<li>check if <code>t</code> is pointing to <code>nullptr</code>, if so, this is the base case: an empty branch is found, and <code>val</code> should be inserted there;</li>
<li>if it is not the base case, we will insert it into <code>t</code>'s children:
<ul class="org-ul">
<li><code>val &gt; t-&gt;element</code>: insert to right subtree by calling itself and pass <code>val</code> and <code>t-&gt;right</code></li>
<li><code>val &lt; t-&gt;element</code>: insert to left subtree by calling itself and pass <code>val</code> and <code>t-&gt;right</code></li>
</ul></li>
<li>if <code>val == t-&gt;element</code>, we do nothing, since its already in the tree (no duplicate)</li>
</ul>

<p>
Code (copy version):
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename comparable&gt;
<span class="linenr"> 2: </span>void BinarySearchTree&lt;comparable&gt;::insert(const comparable&amp; val, BinaryNode* &amp; t) {  
<span class="linenr"> 3: </span>  //base case1: t is pointing to nullptr
<span class="linenr"> 4: </span>  if (t == nullptr) {
<span class="linenr"> 5: </span>    t = new BinaryNode{val}; //this step will modify t, so pass the pointer by reference is necessary
<span class="linenr"> 6: </span>    return;
<span class="linenr"> 7: </span>  }
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>  //determine which branch to insert 
<span class="linenr">10: </span>  //not considering the equal case 
<span class="linenr">11: </span>  if (val &lt; t-&gt;element)
<span class="linenr">12: </span>    insert(val, t-&gt;left);
<span class="linenr">13: </span>  else if (val &gt; t-&gt;element)
<span class="linenr">14: </span>    insert(val, t-&gt;right);
<span class="linenr">15: </span>  else
<span class="linenr">16: </span>    return;//val == t-&gt;element, do nothing
<span class="linenr">17: </span>}
</pre>
</div>

<p>
Notice that the passed in <code>TreeNode</code> pointer type is referenced type, this is because we will change the memory address stored in pointer itself when we allocate new chunk of memory and store the new tree node.
</p>
</div>
</div>

<div id="outline-container-orgff08f58" class="outline-6">
<h6 id="orgff08f58"><span class="section-number-6">1.5.1.2.17</span> <code>remove()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-17">
<p>
This is internal private version of <code>remove()</code>. It accepts two parameters: a <code>comparable</code> type <code>val</code>, a reference to pointer of <code>TreeNode</code> type (we need to change the address stored in pointer, so we need reference type pointer). This function works recursively. It will remove the node containing <code>val</code> in subtree whose root is pointed by <code>t</code>. When we remove a node from the tree, its children are disconnected from the tree (because this node connects them to the tree). We need to reconnect them to the tree. The details of reconnecting protocol is up to programmer's choice, here we'll introduce a simple way.
</p>
<ul class="org-ul">
<li>there are four base cases
<ol class="org-ol">
<li><code>t == nullptr</code>: no match found, return</li>
<li><code>t-&gt;element &gt; val</code>: call <code>remove(val, t-&gt;left)</code></li>
<li><code>t-&gt;element &lt; val</code>: call <code>remove(val, t-&gt;right)</code></li>
<li><code>t-&gt;element == val</code>: this is the node we want to remove, proceed to next step</li>
</ol></li>
<li>find the left most leaf of <code>t-&gt;right</code>: <code>left_leaf_ptr</code></li>
<li>attach <code>t-&gt;left</code> to the left child of <code>left_leaf_ptr</code></li>
<li>use a temporary <code>TreeNode</code> pointer <code>temp</code>  to store address of <code>t-&gt;right</code></li>
<li>reclaim <code>t</code>'s memory</li>
<li>reconnect previous <code>t</code>'s children by: <code>t = temp</code>. Notice that <code>t</code> should point to its parent's children. Before deletion, <code>t</code>'s parent's child is <code>t</code>, now, <code>t</code>'s parent's child is <code>t-&gt;right</code>, <code>t-&gt;left</code> is also connected to <code>t-&gt;right</code>.</li>
</ul>

<p>
Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename comparable&gt;
<span class="linenr"> 2: </span>void BinarySearchTree&lt;comparable&gt;::remove(const comparable&amp; val, BinaryNode* &amp; t) {
<span class="linenr"> 3: </span>  //base case 1: t is pointing to nullptr, no match
<span class="linenr"> 4: </span>  if (t == nullptr)
<span class="linenr"> 5: </span>    return;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  //base case 2: t is pointing to the target node
<span class="linenr"> 8: </span>  if (t-&gt;element == val) {
<span class="linenr"> 9: </span>    //find the left most spot of t-&gt;right, and attach t-&gt;left to it
<span class="linenr">10: </span>    if (t-&gt;right == nullptr) {
<span class="linenr">11: </span>      t-&gt;right = t-&gt;left;
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>
<span class="linenr">14: </span>    else {
<span class="linenr">15: </span>      BinaryNode* left_leaf_ptr = t-&gt;right;
<span class="linenr">16: </span>      while (left_leaf_ptr -&gt; left != nullptr)
<span class="linenr">17: </span>	left_leaf_ptr = left_leaf_ptr -&gt; left;
<span class="linenr">18: </span>      //after the above loop, left_leaf_ptr is pointing to the left most leaf of t-&gt;right, attach t-&gt;left to the left subtree of this leaf
<span class="linenr">19: </span>      left_leaf_ptr -&gt; left = t-&gt;left;
<span class="linenr">20: </span>    }
<span class="linenr">21: </span>
<span class="linenr">22: </span>    //keep record of the address of current t-&gt;right
<span class="linenr">23: </span>    BinaryNode* temp = t-&gt;right;
<span class="linenr">24: </span>    //reclaim memory 
<span class="linenr">25: </span>    delete t;
<span class="linenr">26: </span>    //re-connect tree node 
<span class="linenr">27: </span>    t = temp; // here requires modifying t, thus reference is required
<span class="linenr">28: </span>
<span class="linenr">29: </span>    return;
<span class="linenr">30: </span>  }
<span class="linenr">31: </span>
<span class="linenr">32: </span>  //t is not pointing to the target node
<span class="linenr">33: </span>  if (t-&gt;element &gt; val) 
<span class="linenr">34: </span>    remove(val, t-&gt;left);
<span class="linenr">35: </span>  else
<span class="linenr">36: </span>    remove(val, t-&gt;right);
<span class="linenr">37: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org7ccee52" class="outline-6">
<h6 id="org7ccee52"><span class="section-number-6">1.5.1.2.18</span> <code>findMin()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-18">
<p>
This function will return a pointer of <code>TreeNode</code> type which points to the left most leaf of the tree whose root is pointed by the passed in <code>TreeNode</code> pointer <code>t</code>. If <code>t == nullptr</code>, <code>nullptr</code> will be returned. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename comparable&gt;
<span class="linenr"> 2: </span>typename BinarySearchTree&lt;comparable&gt;::BinaryNode* BinarySearchTree&lt;comparable&gt;::findMin(BinaryNode* t) const {
<span class="linenr"> 3: </span>  if (t == nullptr)
<span class="linenr"> 4: </span>    return t;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  while (t-&gt;left != nullptr)
<span class="linenr"> 7: </span>    t = t-&gt;left;
<span class="linenr"> 8: </span>  //after the above loop, t is now pointing to left-most leaf
<span class="linenr"> 9: </span>  return t;  
<span class="linenr">10: </span>}
</pre>
</div>

<p>
Pay attention to the return type keyword:
</p>
<div class="org-src-container">
<pre class="src src-c++">typename BinarySearchTree&lt;comparable&gt;::BinaryNode*
</pre>
</div>
<p>
If you are returning a nested class type, for example, in the above code you are returning a pointer to <code>BinaryNode</code>, which itself is a structure defined in <code>BinarySearchTree</code>, you have to add the keyword <code>typename</code> to indicate this is a type to be returned.
</p>
</div>
</div>

<div id="outline-container-orgd4104c4" class="outline-6">
<h6 id="orgd4104c4"><span class="section-number-6">1.5.1.2.19</span> <code>findMax()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-19">
<p>
Similar with <code>findMin()</code>, this function will return a pointer to the right most node. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename comparable&gt;
<span class="linenr"> 2: </span>typename BinarySearchTree&lt;comparable&gt;::BinaryNode* BinarySearchTree&lt;comparable&gt;::findMax(BinaryNode* t) const {
<span class="linenr"> 3: </span>  if (t == nullptr)
<span class="linenr"> 4: </span>    return t;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  while (t-&gt;right != nullptr)
<span class="linenr"> 7: </span>    t = t-&gt;right;
<span class="linenr"> 8: </span>  //after the above loop, t is not pointing to right-most leaf
<span class="linenr"> 9: </span>  return t;   
<span class="linenr">10: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8ca3248" class="outline-6">
<h6 id="org8ca3248"><span class="section-number-6">1.5.1.2.20</span> <code>contains()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-20">
<p>
Steps to find a specific node is similar with <code>remove()</code>. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++">template &lt;typename comparable&gt;
bool BinarySearchTree&lt;comparable&gt;::contains(const comparable&amp; val, BinaryNode* t) const {
  //base case: t == nullptr, no match found
  if (t == nullptr)
    return false;

  //base case2: t-&gt;element == val
  if (t-&gt;element == val)
    return true;

  //try to find val in t's children
  if (t-&gt;element &gt; val)
    return contains(val, t-&gt;left);
  else 
    return contains(val, t-&gt;right);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org6ddee50" class="outline-6">
<h6 id="org6ddee50"><span class="section-number-6">1.5.1.2.21</span> <code>makeEmpty()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-21">
<p>
This function accepts a pointer of <code>TreeNode</code> type <code>t</code>. It will reclaim all memory used by this node and all its children. Working steps:
</p>
<ul class="org-ul">
<li>check if base case reached (<code>t == nullptr</code>), if so, do nothing, return</li>
<li>call itself and pass <code>t-&gt;left</code> to reclaim memory of its left child</li>
<li>call itself and pass <code>t-&gt;right</code> to reclaim memory of its right child</li>
<li>reclaim <code>t</code>'s memory, and assign it to <code>nullptr</code></li>
</ul>

<p>
Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename comparable&gt;
<span class="linenr"> 2: </span>void BinarySearchTree&lt;comparable&gt;::makeEmpty(BinaryNode* &amp; t) {
<span class="linenr"> 3: </span>  //base case 
<span class="linenr"> 4: </span>  if (t == nullptr)
<span class="linenr"> 5: </span>    return;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  //begin makeEmpty
<span class="linenr"> 8: </span>  makeEmpty(t-&gt;left);
<span class="linenr"> 9: </span>  makeEmpty(t-&gt;right);
<span class="linenr">10: </span>  delete t;
<span class="linenr">11: </span>  t = nullptr;
<span class="linenr">12: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgacf492e" class="outline-6">
<h6 id="orgacf492e"><span class="section-number-6">1.5.1.2.22</span> <code>printTree()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-22">
<p>
The idea is similar with <code>makeEmpty()</code>, the only difference is in <code>printTree</code>, you are printing rather than deleting. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename comparable&gt;
<span class="linenr"> 2: </span>void BinarySearchTree&lt;comparable&gt;::printTree(BinaryNode* t, std::ostream&amp; out) const {
<span class="linenr"> 3: </span>  //base case 
<span class="linenr"> 4: </span>  if (t == nullptr)
<span class="linenr"> 5: </span>    return;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  //print the tree in inorder traversal
<span class="linenr"> 8: </span>  printTree(t-&gt;left, out);
<span class="linenr"> 9: </span>  out &lt;&lt; t-&gt;element &lt;&lt; ' ';
<span class="linenr">10: </span>  printTree(t-&gt;right, out);
<span class="linenr">11: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb4f07a2" class="outline-6">
<h6 id="orgb4f07a2"><span class="section-number-6">1.5.1.2.23</span> <code>clone()</code></h6>
<div class="outline-text-6" id="text-1-5-1-2-23">
<p>
This function accepts a pointer to <code>TreeNode</code> type <code>t</code>. It will return a pointer to a newly constructed <code>TreeNode</code>, whose element is the same as <code>t-&gt;element</code>, left child is the same as <code>t-&gt;left</code>, right child is the same as <code>t-&gt;right</code>. It works in a recursive way. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>typename BinarySearchTree&lt;comparable&gt;::BinaryNode* BinarySearchTree&lt;comparable&gt;::clone(BinaryNode* t) const {
<span class="linenr">2: </span>  /** pay attention that what you clone is a BinaryNode! **/
<span class="linenr">3: </span>  //base case 
<span class="linenr">4: </span>  if (t == nullptr)
<span class="linenr">5: </span>    return t;
<span class="linenr">6: </span>
<span class="linenr">7: </span>  //clone 
<span class="linenr">8: </span>  return new BinaryNode{t-&gt;element, clone(t-&gt;left), clone(t-&gt;right)};
<span class="linenr">9: </span>}
</pre>
</div>

<p>
Pay attention that, the returned pointer is constructed by the address generated by the <code>new</code> operation (allocating new memory spaces).
</p>
</div>
</div>
</div>

<div id="outline-container-org1509b74" class="outline-5">
<h5 id="org1509b74"><span class="section-number-5">1.5.1.3</span> Problem with Simple Binary Search Tree</h5>
<div class="outline-text-5" id="text-1-5-1-3">
<p>
The binary search tree can only guarantee \(O(\log{N})\) complexity when the tree is nearly <b>BALANCED</b>, which means for any node in the binary search tree, the number of nodes in its left subtree is roughly the same as its right subtree. However, this may not be the case during practical uses of this simple binary search tree. Consider two cases:
</p>
<ol class="org-ol">
<li>We insert an ordered array into the tree by calling <code>insert()</code> repeatedly for all the elements in array in order. We'll create a linked list rather than a binary tree. If its in ascending order, only right subtree will be used; If its in descending order, only left subtree will be used. Many operations will be \(O(N)\) complexity.</li>
<li>We have a balanced binary search tree at first. We kept removing nodes in it by calling <code>remove()</code>. In our implementation of <code>remove()</code>, we will attach the target node's left subtree to its right subtree. So this will decrease the number of nodes in left subtrees. The balanced tree will degenerate to un-balanced tree, with one subtree holds significant more amount of nodes than the other subtree.</li>
</ol>

<p>
In both cases, we may face increased time complexity. Thus, we want to come up with ways to build <b>balanced</b> binary search tree.
</p>
</div>
</div>
</div>

<div id="outline-container-org5a4c922" class="outline-4">
<h4 id="org5a4c922"><span class="section-number-4">1.5.2</span> AVL Tree</h4>
<div class="outline-text-4" id="text-1-5-2">
</div>
<div id="outline-container-orgbc106ff" class="outline-5">
<h5 id="orgbc106ff"><span class="section-number-5">1.5.2.1</span> General Idea</h5>
<div class="outline-text-5" id="text-1-5-2-1">
<p>
An AVL tree is identical to a binary search tree, except that for every node in the tree, the height of the left and right subtrees can differ by most 1 (the height of an empty tree is defined to be -1).
</p>

<p>
Let \(S(h)\) be the minimum number of nodes that an AVL tree of height \(h\) needs.
</p>



<div class="figure">
<p><object type="image/svg+xml" data="./img/1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>


<div id="outline-container-orga07c233" class="outline-5">
<h5 id="orga07c233"><span class="section-number-5">1.5.2.2</span> Simple Implementation (recursive)</h5>
</div>
</div>
<div id="outline-container-org6827b6b" class="outline-4">
<h4 id="org6827b6b"><span class="section-number-4">1.5.3</span> Red Black Tree</h4>
<div class="outline-text-4" id="text-1-5-3">
</div>
<div id="outline-container-orgc4acd71" class="outline-5">
<h5 id="orgc4acd71"><span class="section-number-5">1.5.3.1</span> General Idea</h5>
</div>
</div>
</div>
<div id="outline-container-org6d2dcff" class="outline-3">
<h3 id="org6d2dcff"><span class="section-number-3">1.6</span> Hash Table</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Hash table ADT is a way of organizing data. It only allows a subset of operations of binary search tree. However, Hash table has higher efficiency on these supported operations than binary search tree. For example, Hash table can perform insertion, deletion and find in <b>CONSTANT</b> average time.
</p>

<p>
One point should be made clear that, Hash table does not support operation that requires ordering information.
</p>
</div>
<div id="outline-container-org5800ae8" class="outline-4">
<h4 id="org5800ae8"><span class="section-number-4">1.6.1</span> General Idea</h4>
<div class="outline-text-4" id="text-1-6-1">
</div>
<div id="outline-container-orgea4f5c7" class="outline-5">
<h5 id="orgea4f5c7"><span class="section-number-5">1.6.1.1</span> Key</h5>
<div class="outline-text-5" id="text-1-6-1-1">
<p>
A key is part of the data item that is used to perform searching by some methods. We search the <b>key</b> and find the match item, then we declare that we have found the item.
</p>
</div>
</div>
<div id="outline-container-org7cb7383" class="outline-5">
<h5 id="org7cb7383"><span class="section-number-5">1.6.1.2</span> Vector/Array</h5>
<div class="outline-text-5" id="text-1-6-1-2">
<p>
The ideal Hash table data structure is merely an array (which has a fixed size) containing our data items. Imagine we have a bunch of data items to be put into an array. In order to achieve constant time access, we may think design a certain rule of how to put items into the array. This rule can be a mapping from a specific key to the actual index in that array. We can define some part of our data item as the <b>KEY</b> to be used to get the index through the mapping. So, for each data item, we can find out where we should put it in the array. And we can also find out the existence of a specific data item by using the corresponding key in constant time.
</p>

<p>
Basically, hash table is an array that manages the position of data items by their key, rather than their sequence of inserting into the array.
</p>
</div>
</div>
</div>
<div id="outline-container-org59b9b1b" class="outline-4">
<h4 id="org59b9b1b"><span class="section-number-4">1.6.2</span> Hash Function</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
The mapping we mentioned above is called a hash function. Ideally, a hash function should:
</p>
<ol class="org-ol">
<li>be simple to compute</li>
<li>can ensure that any two distinct keys get different index value</li>
</ol>

<p>
The fact that there are a finite number of cells and a virtually inexhaustible supply of keys makes 2 impossible. In practical, we try our best to achieve it. By that, it means seek a hash function that distributes the keys as even as possible among the slots of the array.
</p>

<p>
If the input keys are integers already, simpliy choose <code>hash(key)</code> as <code>key % array.size()</code>. If <code>array.size()</code> is a prime number, this hash function can distribute the keys evenly.
</p>

<p>
If the input keys are not integer, our strategy contains two steps:
</p>
<ol class="org-ol">
<li>convert the key into integer <code>i</code></li>
<li>calculate <code>i % array.size()</code> to get the index</li>
</ol>

<p>
In practice, the function that fullfills step 1 is called hash function. The second step is trival.
</p>
</div>

<div id="outline-container-orgd7a7516" class="outline-5">
<h5 id="orgd7a7516"><span class="section-number-5">1.6.2.1</span> Hash Function Object</h5>
<div class="outline-text-5" id="text-1-6-2-1">
<p>
We have to design the details of how hash function convert a non-integer data type into integer value. For example, to convert a string object to integer value. We can just directly write a function that accepts <code>std::string</code> and returns <code>size_t</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>size_t hash(const std::string&amp; key) {
<span class="linenr">2: </span>  size_t hashVal = 0;
<span class="linenr">3: </span>  for (char ch:key)
<span class="linenr">4: </span>    hashVal = 37 * hashVal + ch;
<span class="linenr">5: </span>  return hashVal;
<span class="linenr">6: </span>}
</pre>
</div>

<p>
To do this job in a more generic way, we can define a hash function object. A function object (also called a functor) is a class object with <code>operator()</code> defined. This operator is called function call operator, which can make the object be used like a function. For example:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>class Add {
<span class="linenr">2: </span>public:
<span class="linenr">3: </span>  int operator()(int a, int b) {
<span class="linenr">4: </span>    return (a + b);
<span class="linenr">5: </span>  }
<span class="linenr">6: </span>};
</pre>
</div>

<p>
In the above code, we defined a class named <code>Add</code>. It has only one public member function <code>operator()</code>, which accepts two integer parameters <code>a</code> and <code>b</code>. It will return the result of <code>a + b</code>. To use it, we can:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>Add addition; // declare an object
<span class="linenr">2: </span>std::cout &lt;&lt; "1 + 1 is: " &lt;&lt; addition(1, 1); // operator() is called
</pre>
</div>

<p>
We can also write a template:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;class T&gt;
<span class="linenr">2: </span>class Add {
<span class="linenr">3: </span>public:
<span class="linenr">4: </span>  T operator()(T a, T b) {
<span class="linenr">5: </span>    return (a + b);
<span class="linenr">6: </span>  }
<span class="linenr">7: </span>};
</pre>
</div>

<p>
To use it:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>Add addition&lt;int&gt;; // declare an object
<span class="linenr">2: </span>std::cout &lt;&lt; "1 + 1 is: " &lt;&lt; addition(1, 1); // operator() is called
</pre>
</div>

<p>
You can also write a <b>specialization</b> of the template for a spefic type. For example:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>// for generic type T
<span class="linenr"> 2: </span>template &lt;class T&gt;
<span class="linenr"> 3: </span>class Add {
<span class="linenr"> 4: </span>public:
<span class="linenr"> 5: </span>  T operator()(T a, T b) {
<span class="linenr"> 6: </span>    return (a + b);
<span class="linenr"> 7: </span>  }
<span class="linenr"> 8: </span>};
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>// for string type
<span class="linenr">11: </span>template&lt;&gt; // you'll provide the specific type below
<span class="linenr">12: </span>class Add&lt;std::string&gt; { // provide type here
<span class="linenr">13: </span>public:
<span class="linenr">14: </span>  int operator()(std::string a, std::string b) {
<span class="linenr">15: </span>    return (std::stoi(a) + std::stoi(b));
<span class="linenr">16: </span>  }
<span class="linenr">17: </span>};
</pre>
</div>

<p>
This is called template specialization. You write the implementation of the class using one specific type. Pay attention that, if all the template typename is designated, it will be implemented during compile.
</p>

<p>
Back to our hash function object. We can first declare an empty template and write template specialization for different types of key we want to convert to integer. For example, in the following code, hash function for <code>std::string</code> and <code>double</code> are defined.
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>#pragma once
<span class="linenr"> 2: </span>#include &lt;string&gt;
<span class="linenr"> 3: </span>//an empty function object template
<span class="linenr"> 4: </span>template &lt;typename Key&gt;
<span class="linenr"> 5: </span>class hash {
<span class="linenr"> 6: </span>public:
<span class="linenr"> 7: </span>  size_t operator()(const Key&amp; k) const;
<span class="linenr"> 8: </span>};
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>//a specialization of hash function, which accepts a string and return the converted integer value 
<span class="linenr">11: </span>template&lt;&gt;
<span class="linenr">12: </span>class hash&lt;std::string&gt; {
<span class="linenr">13: </span>public:
<span class="linenr">14: </span>  size_t operator()(const std::string&amp; k) const {
<span class="linenr">15: </span>    size_t hashVal = 0;
<span class="linenr">16: </span>    for(char ch:k)
<span class="linenr">17: </span>      hashVal = 37 * hashVal + ch;
<span class="linenr">18: </span>    return hashVal;
<span class="linenr">19: </span>  }
<span class="linenr">20: </span>};
<span class="linenr">21: </span>
<span class="linenr">22: </span>//a specialization of hash function, which accepts a double and return the converted hash value (this is only for test purpose, so the hash function is bad)
<span class="linenr">23: </span>template&lt;&gt;
<span class="linenr">24: </span>class hash&lt;double&gt; {
<span class="linenr">25: </span>public:
<span class="linenr">26: </span>  size_t operator()(double k) const {
<span class="linenr">27: </span>    if (double &lt; 0)
<span class="linenr">28: </span>      double = 0 - double;
<span class="linenr">29: </span>
<span class="linenr">30: </span>    size_t hashVal{static_cast&lt;size_t&gt;(k)}; //requires narrowing conversion
<span class="linenr">31: </span>
<span class="linenr">32: </span>    return hashVal;
<span class="linenr">33: </span>  }
<span class="linenr">34: </span>};
</pre>
</div>

<p>
The above code is wrapped in a header file (this header file is considered to store the hash function). When using hash table, we may want to use it to hold user-defined data type, like an object of user-defined class. It is your duty to provide usable hash function specialization that can convert the user-defined class into integer value. Generally, this specialization of hash function should be inside the declaration file of the class that is going to be put into hash table (so as long as you included the class, you can use it in hash table container). The keyword of the name of hash function is just that: <code>hash()</code>.
</p>

<p>
For example, suppose I have a class named <code>Employee</code>. It has following private data member:
</p>
<div class="org-src-container">
<pre class="src src-c++">std::string name;
double salary;
</pre>
</div>

<p>
Now I want to use <code>name</code> as the key to generate the hash-value of an employee object. So I have to put following template specialization of hash function into the header file of <code>Employee</code> class (employee.h):
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template&lt;&gt;
<span class="linenr">2: </span>class hash&lt;Employee&gt; {
<span class="linenr">3: </span>public:
<span class="linenr">4: </span>  size_t operator()(const Employee&amp; item) {
<span class="linenr">5: </span>    static hash&lt;std::string&gt; hf;
<span class="linenr">6: </span>    return hf(item.getName()); //this line makes it clear that, the returned value of item.getName() will be used as key of item, which is a string
<span class="linenr">7: </span>  }
<span class="linenr">8: </span>};
</pre>
</div>

<p>
Notice that, inside the implementation, I created an object of <code>hash&lt;std::string&gt;</code> type. This is to utilize the hash function that accepts a <code>std::string</code> type, an example of using hash function for pre-defined types to build our own hash function.
</p>

<p>
The keyword <code>static</code> is just tell computer that only one copy of the <code>hash&lt;std::string&gt;</code> object is needed in case of multiple calling of <code>hash&lt;Employee&gt;::operator()</code>. <code>getName()</code> is the routine in <code>Employee</code> class that returns <code>name</code>.
</p>
</div>
</div>


<div id="outline-container-orged5befa" class="outline-5">
<h5 id="orged5befa"><span class="section-number-5">1.6.2.2</span> Hash Function in C++ STL</h5>
<div class="outline-text-5" id="text-1-6-2-2">
<p>
Designing a good hash function is usually very hard in practical, and is usually done by mathematicians working in related field. In C++ STL, we have predefined hash function for primitive types as well as types predefined in C++ STL (like <code>std::string</code>). To use it, you have to:
</p>
<div class="org-src-container">
<pre class="src src-c++">#include &lt;functional&gt;
</pre>
</div>

<p>
Hash function for <code>std::string</code> object is defined in <code>&lt;string&gt;</code> header file. Pay attention that you still need to write the specific version of hash function that accepts your own user-defined class (by giving a template specialization in the user-defined class).
</p>

<p>
Using the same example in the previous section, the following code shows how to implement the hash function specialization for <code>Employee</code> class using C++ STL provided hash function instead:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>#include &lt;string&gt; // enable C++ STL hash function for string
<span class="linenr">2: </span>template&lt;&gt;
<span class="linenr">3: </span>class hash&lt;Employee&gt; {
<span class="linenr">4: </span>public:
<span class="linenr">5: </span>  size_t operator()(const Employee&amp; item) {
<span class="linenr">6: </span>    static std::hash&lt;std::string&gt; hf;
<span class="linenr">7: </span>    return hf(item.getName()); //this line makes it clear that, the returned value of item.getName() will be used as key of item, which is a string
<span class="linenr">8: </span>  }
<span class="linenr">9: </span>};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org82a6414" class="outline-4">
<h4 id="org82a6414"><span class="section-number-4">1.6.3</span> Collision Management</h4>
<div class="outline-text-4" id="text-1-6-3">
<p>
Collision happens when inserting an element, it hashes to the same value as a previously inserted element. The probability of collision increases as the hash table gets full. There are various ways to manage collision, in this section following will be introduced briefly:
</p>
<ul class="org-ul">
<li>separate chaining</li>
<li>probing
<ul class="org-ul">
<li>linear probing</li>
<li>quadratic probing</li>
</ul></li>
<li>double hashing</li>
</ul>
</div>

<div id="outline-container-orgdb5c8fb" class="outline-5">
<h5 id="orgdb5c8fb"><span class="section-number-5">1.6.3.1</span> Separate chaining</h5>
<div class="outline-text-5" id="text-1-6-3-1">
<p>
This strategy will keep a doubly-linked list (<code>std::list</code>) of all elements that hash to the same value. The hash table array will not store data element directly, it keeps track of a doubly linked list of data element in the array instead. If collision happens, data element hashes to the same index value will be pushed into the list. Actually, any containers can be used beside linked list, for example: binary tree, another hash table.
</p>

<p>
Load factor \(\lambda\) is defined as:
\[
\lambda = \frac {\text{total number of items in hash table}} {\text{hash table size}} = \frac {\text{total number of items}} {\text{number of linked list}}
\]
so, load factor is also the average length of the linked list. A successful search requires about \(1 + \frac {\lambda} {2}\) links to be traversed. \(\frac {\lambda} {2}\) corresponds to expected number of other elements traversed before we find match, 1 corresponds to the matched element.
</p>

<p>
To reduce the chance of collision, we want to keep \(\lambda\) low. When \(\lambda \approx 1\), we may want to resize the hash table. When copying old items into new array, we have to use hash function to re-calculate the appropriate index for each of the item. This process is called rehash.
</p>
</div>
</div>

<div id="outline-container-org07418ec" class="outline-5">
<h5 id="org07418ec"><span class="section-number-5">1.6.3.2</span> Probing</h5>
<div class="outline-text-5" id="text-1-6-3-2">
<p>
In this strategy, if an element is hased to a slot that is already occupied, we try alternative slots until an empty cell is found. The operation of trying to find an empty alternative slot is called probing. So, how to calculate these "alternative" index value if the first hashed value is already occupied?
</p>

<p>
We list the alternative indexes as:
\[
h_0(x), h_1(x), h_2(x), \cdots
\]
where
\[
h_i(x) = [hash(x) + f(i)] \bmod \text {tableSize}
\]
with \(f(0) = 0\).
</p>

<p>
The function \(f(i)\) is called the collision resolution strategy. A hash table doesn't use separate chaining requires a larger table than those use. Generally, \( \lambda \) should be kept below 0.5.
</p>
</div>

<div id="outline-container-orgc2ffaff" class="outline-6">
<h6 id="orgc2ffaff"><span class="section-number-6">1.6.3.2.1</span> Linear probing</h6>
<div class="outline-text-6" id="text-1-6-3-2-1">
<p>
Linear probing is to use linear function of \(i\), typically \(f(i) = i\). Basically, if one spot is occupied, we move to the adjacent spot. Repeat this process until we find an empty spot. As long as the table is big enough, an empty spot can clways be found. However, the time to do so cen get quite large (for both insertion and searching). Another issue is blocks of occupied slots start forming quickly, which is known as primary clustering. 
</p>
</div>
</div>

<div id="outline-container-orgb0d8d25" class="outline-6">
<h6 id="orgb0d8d25"><span class="section-number-6">1.6.3.2.2</span> Quadritic probing</h6>
<div class="outline-text-6" id="text-1-6-3-2-2">
<p>
Quadritic probing is to use quadratic function of \(i\), typically \(f(i) = i^2\). If the table size is prime number, there is no guarantee of finding an empty cell once the table gets more than half full. This is because at most half of the table can be used as alternative location to resolve collisions for objects that hash to same index value in the begining (\(h_o(x)\)). Formally, we have the following theorem:
</p>

<p>
<b>THEOREM</b>
</p>
<blockquote>
<p>
If quadratic probing is used, and the table size is prime, then a new element can <b>always</b> be inserted if the table is at most half empty
</p>
</blockquote>

<p>
<b>PROOF</b>
</p>

<p>
Intuitively, we can imagine why we are facing this problem: even if the table is not full, we still can't insert an item. Unlike linear probing, quadratic probing is not probing empty slot <b>one by one</b>. For linear probing, as long as there is empty cell, we can always get there. For quadratic probing, we are skipping some empty slots. In fact, when inserting an element, we first calculate \(h_0(x)\), then all the possible \(h_i(x)\) can be calculated:
</p>
\begin{align*}
h_0(x) &= hash(x) \bmod \text{tableSize} \\
h_1(x) &= (hash(x) + 1) \bmod \text{tableSize} \\
h_2(x) &= (hash(x) + 4) \bmod \text{tableSize} \\
\vdots \\
h_i(x) &= (hash(x) + i^2) \bmod \text{tableSize}
\end{align*}
<p>
the fact is, the sequence \(h_0(x), h_1(x), h_2(x), \cdots, h_i(x), \cdots\) has finite number of distinct terms. The number of distinct terms is the number of items you can insert into the hash table.
</p>

<p>
To demonstrate the occurence of duplication of \(h_i(x)\), assume the size of the table is a prime number \(N\). Let \(i = 0,1,2,\cdots\). We calculate \(h_i(x)\) all the way from \(i = 0\) to \(i = \lfloor \frac {N} {2} \rfloor \), since \(N\) is prime number, this is equal to \( \frac {N - 1} {2} \). We have:
\[
h_i(x) = [hash(x) + (\frac {N - 1} {2})^2] \mod N
\]
Then, we calculate \(h_{i + 1}(x)\):
\[
h_{i + 1}(x) = [hash(x) + (\frac {N + 1} {2})^2] \mod N
\]
then, \(h_i(x) - h_{i + 1}(x)\) is:
</p>
\begin{align*}
&= (\frac {N - 1} {2})^2 \mod N - (\frac {N + 1} {2})^2 \mod N \\
&= (N^2 - 2N + 1) \mod N - (N^2 + 2N + 1) \mod N \\
&= 1 \mod N - 1 \mod N \\
&= 0
\end{align*}

<p>
So, \(h_i(x) = h_{i + 1}(x)\), duplicate occured.
</p>

<p>
Similarly, \(h_{i + 2}(x) = h_{i - 2}(x)\), if \(i = \lfloor \frac {N} {2} \rfloor\). Thus, \(i = 0,1,2, \cdots, \lfloor \frac {N} {2} \rfloor\) is distinct alternative locations, total number is:
\[
\lfloor \frac {N} {2} \rfloor + 1 = \lceil \frac {N} {2} \rceil
\]
</p>

<p>
For an arbitrarily \(hash(x)\) value, the first \(\lceil \frac {N} {2} \rceil\) alternative locations are distinct. If a hash table has less than \(\lceil \frac {N} {2} \rceil\) positions occupied, an empty spot can always be found for any item inserted.
</p>
</div>
</div>
</div>

<div id="outline-container-org1656dea" class="outline-5">
<h5 id="org1656dea"><span class="section-number-5">1.6.3.3</span> Double hashing</h5>
<div class="outline-text-5" id="text-1-6-3-3">
<p>
In this strategy, when an collision occurs, we use another hash function to probe:
\[
h_i(x) = [hash(x) + f(i)] \bmod \text{tableSize}
\]
and:
\[
f(i) = i \cdot hash_2(x)
\]
</p>

<p>
The function \(f(i)\) should never evaluate to zero, otherwise, \(h_i(x) = hash(x) \bmod \text{tableSize}\) will occur. A typical choice of \(hash_2(x)\) is:
\[
hash_2(x) = R - (x \bmod R)
\]
where \(R\) is a prime number smaller than tableSize.
</p>
</div>
</div>
</div>
<div id="outline-container-orgd53eb91" class="outline-4">
<h4 id="orgd53eb91"><span class="section-number-4">1.6.4</span> Simple Implementation</h4>
<div class="outline-text-4" id="text-1-6-4">
</div>
<div id="outline-container-org55e51c5" class="outline-5">
<h5 id="org55e51c5"><span class="section-number-5">1.6.4.1</span> Separate Chaining</h5>
<div class="outline-text-5" id="text-1-6-4-1">
<p>
We'll implement a hash table class template in this section. It uses separate chaining strategy to manage collisions. It requires the object stored in it can provide a specialization of <code>hash()</code> function, so it can use it to generate index value. Take employee class as an example.
</p>

<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>#pragma once
<span class="linenr"> 2: </span>#include &lt;iostream&gt;
<span class="linenr"> 3: </span>#include &lt;string&gt; // for hash&lt;std::string&gt;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>class Employee {
<span class="linenr"> 6: </span>private:
<span class="linenr"> 7: </span>  std::string name; //name will be used as key
<span class="linenr"> 8: </span>  double salary;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>public:
<span class="linenr">11: </span>  //constructor
<span class="linenr">12: </span>  Employee(std::string n = "N/A", double s = 0) : name{n}, salary{s} {}
<span class="linenr">13: </span>
<span class="linenr">14: </span>  //name accessor
<span class="linenr">15: </span>  const std::string&amp; getName() const {
<span class="linenr">16: </span>    return name;
<span class="linenr">17: </span>  }
<span class="linenr">18: </span>
<span class="linenr">19: </span>  //salary accessor 
<span class="linenr">20: </span>  double getSalary() const {
<span class="linenr">21: </span>    return salary;
<span class="linenr">22: </span>  }
<span class="linenr">23: </span>
<span class="linenr">24: </span>  //equality operator
<span class="linenr">25: </span>  bool operator==(const Employee&amp; rhs) const {
<span class="linenr">26: </span>    return getName() == rhs.getName();
<span class="linenr">27: </span>  }
<span class="linenr">28: </span>
<span class="linenr">29: </span>  //non-equal operator
<span class="linenr">30: </span>  bool operator!=(const Employee&amp; rhs) const {
<span class="linenr">31: </span>    return !(*this == rhs);
<span class="linenr">32: </span>  }
<span class="linenr">33: </span>
<span class="linenr">34: </span>  //overload &lt;&lt; to enable printing class info
<span class="linenr">35: </span>  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; oi, const Employee&amp; obj) {
<span class="linenr">36: </span>    oi &lt;&lt; "Name: " &lt;&lt; obj.name &lt;&lt; "   Salary: $ " &lt;&lt; obj.salary &lt;&lt; '\n';
<span class="linenr">37: </span>    return oi;
<span class="linenr">38: </span>  } 
<span class="linenr">39: </span>};
<span class="linenr">40: </span>
<span class="linenr">41: </span>//define a version of hash function that specifically accepts this Employee type, and return the "integerized" key of this Employee class.
<span class="linenr">42: </span>//this implementation is in the Employee class declaration file, which means the Employee class objects provide a hash function that specifically work for them
<span class="linenr">43: </span>template&lt;&gt;
<span class="linenr">44: </span>class hash&lt;Employee&gt; {
<span class="linenr">45: </span>public:
<span class="linenr">46: </span>  size_t operator()(const Employee&amp; item) {
<span class="linenr">47: </span>    static std::hash&lt;std::string&gt; hf; // declare an hash function object 
<span class="linenr">48: </span>    return hf(item.getName()); //the returned value of item.getName() will be used as key of item, which is a string
<span class="linenr">49: </span>  }
<span class="linenr">50: </span>};
</pre>
</div>

<p>
Notice that we have provided the <code>hash()</code> function specialization in the <code>Employee</code> class, so we can use it in our hash table class.
</p>


<p>
The header for our hash table class is as follows:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>#pragma once
<span class="linenr"> 2: </span>#include &lt;vector&gt;
<span class="linenr"> 3: </span>#include &lt;list&gt;
<span class="linenr"> 4: </span>#include &lt;algorithm&gt; //for std::find() 
<span class="linenr"> 5: </span>#include &lt;functional&gt; //for std::hash() function
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>template &lt;typename HashedObj&gt;
<span class="linenr"> 8: </span>class HashTable {
<span class="linenr"> 9: </span>public:
<span class="linenr">10: </span>  //accepts an integer value, will build up a vector of that size, and initialize each entry an empty list (by calling the default constructor of list)
<span class="linenr">11: </span>  explicit HashTable(int size = 101);
<span class="linenr">12: </span>
<span class="linenr">13: </span>  bool contains(const HashedObj&amp; x) const;
<span class="linenr">14: </span>
<span class="linenr">15: </span>  void makeEmpty();
<span class="linenr">16: </span>  bool insert(const HashedObj&amp; x);
<span class="linenr">17: </span>  bool insert(HashedObj&amp;&amp; x);
<span class="linenr">18: </span>  bool remove(const HashedObj&amp; x);
<span class="linenr">19: </span>
<span class="linenr">20: </span>private:
<span class="linenr">21: </span>  std::vector&lt;std::list&lt;HashedObj&gt;&gt; theLists; //array of lists
<span class="linenr">22: </span>  int currentSize; // hold current number of items in array
<span class="linenr">23: </span>
<span class="linenr">24: </span>  //void rehash();
<span class="linenr">25: </span>  size_t myhash(const HashedObj&amp; x) const;
<span class="linenr">26: </span>};
<span class="linenr">27: </span>
<span class="linenr">28: </span>#include "ht_separate_chain.hpp"
</pre>
</div>

<p>
Notice that we have declared a vector of list as our container for the hash table. The implementation is given below.
</p>
</div>

<div id="outline-container-org9726cde" class="outline-6">
<h6 id="org9726cde"><span class="section-number-6">1.6.4.1.1</span> <code>Constructor</code></h6>
<div class="outline-text-6" id="text-1-6-4-1-1">
<p>
It accepts an integer value, will build up a vector of that size, and initialize each entry an empty list (by calling the default constructor of list).
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename HashedObj&gt;
<span class="linenr">2: </span>HashTable&lt;HashedObj&gt;::HashTable(int size) {
<span class="linenr">3: </span>  for (int i = 0; i &lt; size; ++i)
<span class="linenr">4: </span>    theLists.push_back(std::list&lt;HashedObj&gt;{});
<span class="linenr">5: </span>
<span class="linenr">6: </span>  currentSize = 0; //initialize the size, or do we have to specifically code it? should be 0 automatically
<span class="linenr">7: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf3ce793" class="outline-6">
<h6 id="orgf3ce793"><span class="section-number-6">1.6.4.1.2</span> <code>contains()</code></h6>
<div class="outline-text-6" id="text-1-6-4-1-2">
<p>
this function tries to find if there is an element <code>x</code> stored in hash table. We do it in following ways:
</p>
<ul class="org-ul">
<li>call <code>myhash(x)</code> to find out the index of <code>x</code></li>
<li>navigate the vector of lists to locate the list that should contain <code>x</code>, if <code>x</code> was inserted</li>
<li>use <code>std::find()</code> to check if <code>x</code> exist in that list</li>
</ul>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename HashedObj&gt;
<span class="linenr">2: </span>bool HashTable&lt;HashedObj&gt;::contains(const HashedObj&amp; x) const {
<span class="linenr">3: </span>  auto&amp; whichList = theLists[myhash(x)]; // whichList is reference to list!
<span class="linenr">4: </span>  return std::find(whichList.begin(), whichList.end(), x) != whichList.end();
<span class="linenr">5: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1fdf990" class="outline-6">
<h6 id="org1fdf990"><span class="section-number-6">1.6.4.1.3</span> <code>makeEmpty()</code></h6>
<div class="outline-text-6" id="text-1-6-4-1-3">
<p>
This function will clear all lists stored in the vector of lists, and also reset the <code>currentSize</code> to 0.
</p>
<ul class="org-ul">
<li>use a ranged for loop to traverse each list stored in theLists.</li>
<li>use <code>std::list::clear()</code> to clear each list</li>
<li>reset <code>currentSize</code></li>
</ul>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename HashedObj&gt;
<span class="linenr">2: </span>void HashTable&lt;HashedObj&gt;::makeEmpty() {
<span class="linenr">3: </span>  for (auto&amp; thisList : theLists)
<span class="linenr">4: </span>    thisList.clear();
<span class="linenr">5: </span>
<span class="linenr">6: </span>  currentSize = 0; // reset value of currentSize
<span class="linenr">7: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf3e0c23" class="outline-6">
<h6 id="orgf3e0c23"><span class="section-number-6">1.6.4.1.4</span> <code>insert()</code></h6>
<div class="outline-text-6" id="text-1-6-4-1-4">
<p>
This function will insert an element <code>x</code> into the list. Steps are as follows:
</p>
<ul class="org-ul">
<li>call <code>myhash(x)</code> to find out the index of <code>x</code></li>
<li>navigate the vector of lists to locate the list that should contain <code>x</code>, if <code>x</code> was inserted</li>
<li>use <code>std::find()</code> to check if <code>x</code> exist in that list</li>
<li>if <code>x</code> is not in the list
<ul class="org-ul">
<li>call <code>push_back(x)</code> to insert it into the list</li>
<li>update <code>currentSize</code></li>
<li>check the load factor of hash table
<ul class="org-ul">
<li>load factor &gt; 1: call <code>rehash()</code></li>
<li>otherwise, do nothing</li>
</ul></li>
</ul></li>
<li>if <code>x</code> is already in the list, return <code>false</code> to indicate insertion failed.</li>
</ul>

<p>
The code is as follows (copy version):
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename HashedObj&gt;
<span class="linenr"> 2: </span>bool HashTable&lt;HashedObj&gt;::insert(const HashedObj&amp; x) {
<span class="linenr"> 3: </span>  auto&amp; whichList = theLists[myhash(x)];
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  auto itr = find(whichList.begin(), whichList.end(), x);
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  if (itr == whichList.end()) {
<span class="linenr"> 8: </span>    whichList.push_back(x);
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    if (++currentSize &gt; theLists.size())//update size and check if rehash is needed
<span class="linenr">11: </span>      rehash();
<span class="linenr">12: </span>
<span class="linenr">13: </span>    return true;
<span class="linenr">14: </span>  }
<span class="linenr">15: </span>
<span class="linenr">16: </span>  return false; //match found
<span class="linenr">17: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdcab737" class="outline-6">
<h6 id="orgdcab737"><span class="section-number-6">1.6.4.1.5</span> <code>remove()</code></h6>
<div class="outline-text-6" id="text-1-6-4-1-5">
<p>
This function will remove an element <code>x</code> in the list. Steps are as follows:
</p>
<ul class="org-ul">
<li>call <code>myhash(x)</code> to find out the index of <code>x</code></li>
<li>navigate the vector of lists to locate the list that should contain <code>x</code>, if <code>x</code> was inserted</li>
<li>use <code>std::find()</code> to check if <code>x</code> exist in that list</li>
<li>if <code>x</code> is not in the list
<ul class="org-ul">
<li>return <code>false</code> to indicate erase failed</li>
</ul></li>
<li>if <code>x</code> is found in the list
<ul class="org-ul">
<li>call <code>std::list::erase()</code> to erase <code>x</code></li>
<li>update <code>currentSize</code></li>
<li>return true to indicate erase succeed</li>
</ul></li>
</ul>

<p>
Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename HashedObj&gt;
<span class="linenr"> 2: </span>bool HashTable&lt;HashedObj&gt;::remove(const HashedObj&amp; x) {
<span class="linenr"> 3: </span>  auto&amp; whichList = theLists[myhash(x)];
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  auto itr = std::find(whichList.begin(), whichList.end(), x);
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  if (itr == whichList.end())
<span class="linenr"> 8: </span>    return false;
<span class="linenr"> 9: </span>  else {
<span class="linenr">10: </span>    whichList.erase(itr);
<span class="linenr">11: </span>    --currentSize;
<span class="linenr">12: </span>    return true;
<span class="linenr">13: </span>  }
<span class="linenr">14: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3e860ca" class="outline-6">
<h6 id="org3e860ca"><span class="section-number-6">1.6.4.1.6</span> <code>myhash()</code></h6>
<div class="outline-text-6" id="text-1-6-4-1-6">
<p>
This function accepts an element <code>x</code>, and will return the hashed index value for the input <code>x</code>. It requires a proper specialization of <code>hash()</code> defined for <code>x</code>. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename HashedObj&gt;
<span class="linenr">2: </span>size_t HashTable&lt;HashedObj&gt;::myhash(const HashedObj&amp; x) const {
<span class="linenr">3: </span>  static hash&lt;HashedObj&gt; hf;
<span class="linenr">4: </span>  return hf(x) % theLists.size();
<span class="linenr">5: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org7d8260c" class="outline-6">
<h6 id="org7d8260c"><span class="section-number-6">1.6.4.1.7</span> <code>rehash()</code></h6>
<div class="outline-text-6" id="text-1-6-4-1-7">
<p>
When the load factor \( \approx 1\), we should increase the hash table size to avoid performance reduction of the hash table (i.e. multiple collisions happen). The steps are as follows:
</p>
<ul class="org-ul">
<li>declare a temporary vector of list (<code>temp</code>) to hold the current array (copy)</li>
<li>call <code>resize(2 * array.size())</code> to expand the current array's size</li>
<li>call <code>makeEmpty()</code> to clear up the current array</li>
<li>use a ranged for loop to traverse each element in <code>temp</code>, call <code>insert()</code> to insert them into the new array</li>
</ul>

<p>
Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename HashedObj&gt;
<span class="linenr"> 2: </span>void HashTable&lt;HashedObj&gt;::rehash() {
<span class="linenr"> 3: </span>  // create copy of old lists
<span class="linenr"> 4: </span>  std::vector&lt;std::list&lt;HashedObj&gt;&gt; temp = theLists;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  // expand the old list and make empty
<span class="linenr"> 7: </span>  theLists.resize(2 * theLists.size());
<span class="linenr"> 8: </span>  makeEmpty();
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>  // copy back
<span class="linenr">11: </span>  for (auto&amp; list : temp) // for each list in the old theLists 
<span class="linenr">12: </span>    for (auto&amp; x : list) // for each element in list 
<span class="linenr">13: </span>      insert(std::move(x)); // insert back, use move version
<span class="linenr">14: </span>}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgedf3f4f" class="outline-5">
<h5 id="orgedf3f4f"><span class="section-number-5">1.6.4.2</span> Quadratic Probing</h5>
<div class="outline-text-5" id="text-1-6-4-2">
<p>
In this section, a hash table with quadratic probing collision management strategy will be implemented. Similar with the separate chaining example, we'll implement this hash table to hold generic type <code>HashedObj</code>, which is required to provide the specialization of <code>hash()</code> function.
</p>

<p>
The public interface is:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>explicit HashTable(int size = 101);
<span class="linenr">2: </span>bool contains(const HashedObj&amp; x) const;
<span class="linenr">3: </span>void makeEmpty();
<span class="linenr">4: </span>bool insert(const HashedObj&amp; x);
<span class="linenr">5: </span>bool insert(HashedObj&amp;&amp; x);
<span class="linenr">6: </span>bool remove(const HashedObj&amp; x); 
<span class="linenr">7: </span>enum EntryType {ACTIVE, EMPTY, DELETED};
</pre>
</div>

<p>
Notice that, an enumerated data type named <code>EntryType</code> has been declared (in header file of this hash table class). This will be used to indicate the status of a certain slot in hash table array. Why we need this? In probing strategy, we probe the slot to find available empty slot. We need the slot of the array hold not only <code>HashedObj</code>, but also information on this slot: is it empty? is it actively storing a <code>HashedObj</code>? or is it deleted (so we can insert new <code>HashedObj</code> to it). This demand prompts us to use an object to wrap our <code>HashedObj</code> and variable that can indicate the various states of where this object stored, and we insert this object into the slot of the hash table array. The detail of the object is shown below:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>struct HashEntry {
<span class="linenr">2: </span>  HashedObj element; //hold the hashed object
<span class="linenr">3: </span>  EntryType info; //hold the current status of the item
<span class="linenr">4: </span>
<span class="linenr">5: </span>  HashEntry(const HashedObj&amp; e = HashedObj{}, EntryType i = EMPTY) : element{e}, info{i} {}
<span class="linenr">6: </span>
<span class="linenr">7: </span>  HashEntry(HashedObj&amp;&amp; e, EntryType i = EMPTY) : element{std::move(e)}, info{i} {}
<span class="linenr">8: </span>};
</pre>
</div>
<p>
This declaration of structure named <code>HashEntry</code> is in private section of the hash table class. Notice that we have declared a variable named <code>info</code>, whose type is the enumerated type we have just defined: <code>EntryType</code>. The object of this struct will be stored in the entry of hash table array.
</p>

<p>
Now let's take a look at the private member of our hash table class:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>// member 
<span class="linenr">2: </span>std::vector&lt;HashEntry&gt; array;
<span class="linenr">3: </span>int currentSize;
<span class="linenr">4: </span>// member functions
<span class="linenr">5: </span>bool isActive(int currentPos) const;
<span class="linenr">6: </span>int findPos(const HashedObj&amp; x) const;
<span class="linenr">7: </span>void rehash();
<span class="linenr">8: </span>size_t myhash(const HashedObj&amp; x) const;
</pre>
</div>

<p>
Notice that the type of the hash table array is a vector of <code>HashEntry</code> type. We also have a <code>currentSize</code> member to hold the number of <code>HashedObj</code> in the hash table. Previous analyze indicates that we must keep the loading factor less than 0.5 to ensure successful inserting for a new element.
</p>

<p>
Let's take a look at the implementation.
</p>
</div>

<div id="outline-container-org57e87d2" class="outline-6">
<h6 id="org57e87d2"><span class="section-number-6">1.6.4.2.1</span> <code>constructor</code></h6>
<div class="outline-text-6" id="text-1-6-4-2-1">
<p>
The constructor accepts an integer value, which will be used to declare the underlying vector. Also, <code>currentSize</code> should be initialized to zero. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename HashedObj&gt;
<span class="linenr">2: </span>HashTable&lt;HashedObj&gt;::HashTable(int size) : array(size) {
<span class="linenr">3: </span>  currentSize = 0;
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org8601da7" class="outline-6">
<h6 id="org8601da7"><span class="section-number-6">1.6.4.2.2</span> <code>contains()</code></h6>
<div class="outline-text-6" id="text-1-6-4-2-2">
<p>
This function accepts a <code>HashedObj</code> type parameter <code>x</code>, its working steps are as follows:
</p>
<ul class="org-ul">
<li>call <code>findPos(x)</code> to get the index of <code>x</code></li>
<li>call <code>isActive()</code> to check if <code>array[index]</code> is active</li>
</ul>

<p>
The index value returned by <code>findPos(x)</code> is the <b>SHOULD</b> index of <code>x</code> in the current array. If <code>x</code> is in the array, this index should be its index, however the status may not be <code>ACTIVE</code> (so we need to call <code>isActive</code> to determine). If <code>x</code> is not in the array, this index should be where it is inserted (if you are inserting <code>x</code>), so the status should be either <code>DELETED</code> or <code>EMPTY</code>. By checking the status of <code>array[index]</code>, we know whether <code>x</code> is in the hash table or not. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename HashedObj&gt;
<span class="linenr">2: </span>bool HashTable&lt;HashedObj&gt;::contains(const HashedObj&amp; x) const {
<span class="linenr">3: </span>  return isActive(findPos(x));
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2af08f6" class="outline-6">
<h6 id="org2af08f6"><span class="section-number-6">1.6.4.2.3</span> <code>makeEmpty()</code></h6>
<div class="outline-text-6" id="text-1-6-4-2-3">
<p>
This function will empty the entire hash table array. We use lazy deletion to achieve this task (we are using enumerated type to label the status of each slot, so changing the status to do lazy deletion is very intuitive). All we have to do is to reset <code>currentSize</code> and modify the status label of each slot to <code>EMPTY</code>. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename HashedObj&gt;
<span class="linenr">2: </span>void HashTable&lt;HashedObj&gt;::makeEmpty() {
<span class="linenr">3: </span>  currentSize = 0;
<span class="linenr">4: </span>  for(auto&amp; entry : array) //range based for loop
<span class="linenr">5: </span>    entry.info = EMPTY;
<span class="linenr">6: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org3f4cc70" class="outline-6">
<h6 id="org3f4cc70"><span class="section-number-6">1.6.4.2.4</span> <code>insert()</code></h6>
<div class="outline-text-6" id="text-1-6-4-2-4">
<p>
This function accepts a <code>HashedObj</code> type parameter <code>x</code>. It will insert <code>x</code> into the hash table. Working steps:
</p>
<ul class="org-ul">
<li>call <code>findPos(x)</code> to find out the <b>SHOULD</b> index of <code>x</code></li>
<li>check if <code>x</code> is already in the hash table
<ul class="org-ul">
<li>yes: return false (insertion failed: already in)</li>
</ul></li>
<li>copy <code>x</code> to the slot, and set status as <code>ACTIVE</code></li>
<li>rehash if load factor is greater than 0.5</li>
<li>return true to indicate insertion succeed</li>
</ul>

<p>
Code (copy version):
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename HashedObj&gt;
<span class="linenr"> 2: </span>bool HashTable&lt;HashedObj&gt;::insert(const HashedObj&amp; x) {
<span class="linenr"> 3: </span>  int currentPos = findPos(x);
<span class="linenr"> 4: </span>  if (isActive(currentPos))
<span class="linenr"> 5: </span>    return false; //already in the table
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  array[currentPos].element = x;
<span class="linenr"> 8: </span>  array[currentPos].info = ACTIVE;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>  //rehase 
<span class="linenr">11: </span>  if (++currentSize &gt; array.size() / 2)
<span class="linenr">12: </span>    rehash();
<span class="linenr">13: </span>
<span class="linenr">14: </span>  return true; //insertion successful
<span class="linenr">15: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org2a4cbea" class="outline-6">
<h6 id="org2a4cbea"><span class="section-number-6">1.6.4.2.5</span> <code>remove()</code></h6>
<div class="outline-text-6" id="text-1-6-4-2-5">
<p>
This function search and removes the entry that is equal to passed in parameter <code>x</code>. Working steps:
</p>
<ul class="org-ul">
<li>call <code>findPos(x)</code> to find out the <b>SHOULD</b> index of <code>x</code></li>
<li>check if <code>x</code> is in the hash table
<ul class="org-ul">
<li>no: return false (remove failed: <code>x</code> not found)</li>
</ul></li>
<li>lazy deletion: set status as <code>DELETED</code></li>
<li>return true to indicate remove succeed</li>
</ul>

<p>
Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename HashedObj&gt;
<span class="linenr">2: </span>bool HashTable&lt;HashedObj&gt;::remove(const HashedObj&amp; x) {
<span class="linenr">3: </span>  int currentPos = findPos(x);
<span class="linenr">4: </span>  if (!isActive(currentPos))
<span class="linenr">5: </span>    return false; //current position hold no active object (either deleted or empty)
<span class="linenr">6: </span>
<span class="linenr">7: </span>  array[currentPos].info = DELETED;
<span class="linenr">8: </span>  return true;
<span class="linenr">9: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb6a8c73" class="outline-6">
<h6 id="orgb6a8c73"><span class="section-number-6">1.6.4.2.6</span> <code>isActive()</code></h6>
<div class="outline-text-6" id="text-1-6-4-2-6">
<p>
This function accepts an integer type <code>currentPos</code>, which is the index to check. If the status is <code>ACTIVE</code>, return true, otherwise, return false. Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename HashedObj&gt;
<span class="linenr">2: </span>bool HashTable&lt;HashedObj&gt;::isActive(int currentPos) const {
<span class="linenr">3: </span>  return array[currentPos].info == ACTIVE;
<span class="linenr">4: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf57c405" class="outline-6">
<h6 id="orgf57c405"><span class="section-number-6">1.6.4.2.7</span> <code>findPos()</code></h6>
<div class="outline-text-6" id="text-1-6-4-2-7">
<p>
This is one of the most important function in our hash table class. It accepts a <code>HashedObj</code> type parameter <code>x</code>, and will return the <b>SHOULD</b> index of <code>x</code>. As mentioned above, this index is where <code>x</code> ashould be in the current hash table. If <code>x</code> is currently in the hash table, then this index is where it stored (the status may be <code>ACTIVE</code> or <code>DELETED</code>, though). If <code>x</code> is not in the hash table, then this index is where it should be inserted (i.e. this is the first non-ACTIVE slot of the series of available slots for <code>x</code>).
</p>

<p>
The working steps are as follows:
</p>
<ul class="org-ul">
<li><p>
pass <code>x</code> to myhash() function, the myhash() function will prompt the call of the HashedObj's own version of hash function, to convert a HashedObj to an size_t type integer based on the logic defined in the HashedObj class. Pay attention that this integerized value is raw &#x2014; doesn't mod the size of array yet (doesn't scaled). This is because in the final index looking iteration, we have to add \(i^2\) to this value, and then mod the array size (\(h_i(x) = (hash(x) + i^2) \bmod \text{tableSize}\)).
</p>

<p>
We store <code>myhash(x) % array.size()</code> to <code>currentPos</code>.
</p></li>
<li>use a variable <code>stepSize</code> to hold the current number of hash value finding iteration. This is to calculate the next index value using the quadratic rule.</li>
<li>use a while loop to check whether: 1. slot at <code>currentPos</code> is labeled <code>EMPTY</code>; 2. slot at <code>currentPos</code> is storing <code>x</code>. These are two stopping conditions for the while loop, if one of them is true, then <code>currentPos</code> is the <b>SHOULD</b> position of <code>x</code>.</li>
<li>if <code>currentPos</code> is not where <code>x</code> should be, we update it:
<ul class="org-ul">
<li>calculate the next <b>SHOULD</b> position</li>
<li>update <code>stepSize</code></li>
</ul></li>
<li>after the while loop, we return the <b>SHOULD</b> index. Notice that we will always be able to find one, because we always <code>rehash()</code> if the loading factor is greater than 0.5.</li>
</ul>

<p>
Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename HashedObj&gt;
<span class="linenr"> 2: </span>int HashTable&lt;HashedObj&gt;::findPos(const HashedObj&amp; x) const {
<span class="linenr"> 3: </span>  int stepSize = 0;
<span class="linenr"> 4: </span>  int initialPos = myhash(x);
<span class="linenr"> 5: </span>  int currentPos = (initialPos + stepSize * stepSize) % array.size();
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  while (array[currentPos].info != EMPTY &amp;&amp; array[currentPos].element != x) {
<span class="linenr"> 8: </span>    stepSize++;
<span class="linenr"> 9: </span>    currentPos = (initialPos + stepSize * stepSize) % array.size();
<span class="linenr">10: </span>  }
<span class="linenr">11: </span>
<span class="linenr">12: </span>  return currentPos;  
<span class="linenr">13: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org459a85e" class="outline-6">
<h6 id="org459a85e"><span class="section-number-6">1.6.4.2.8</span> <code>rehash()</code></h6>
<div class="outline-text-6" id="text-1-6-4-2-8">
<p>
Similar with <code>rehash()</code> in separate chaining structure, we need to keep the old array first, then we expand the size of the current array. Then we insert back elements into the new array. One thing should be made clear is that, we only have to insert those <code>ACTIVE</code> elements back to the new array.
</p>

<p>
Working steps:
</p>
<ul class="org-ul">
<li>declare <code>temp</code>, a vector of <code>HashEntry</code> type, and copy old array to it</li>
<li>expand array and make empty</li>
<li>use a range based for loop to traverse <code>temp</code>, insert those elements that are <code>ACTIVE</code></li>
</ul>

<p>
Code:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename HashedObj&gt;
<span class="linenr"> 2: </span>void HashTable&lt;HashedObj&gt;::rehash() {
<span class="linenr"> 3: </span>  auto temp = array;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  array.resize(array.size() * 2);
<span class="linenr"> 6: </span>  makeEmpty();
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  for (auto&amp; x : temp)
<span class="linenr"> 9: </span>    if (isActive(x))
<span class="linenr">10: </span>      insert(std::move(x));
<span class="linenr">11: </span>}
</pre>
</div>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org821d14b" class="outline-3">
<h3 id="org821d14b"><span class="section-number-3">1.7</span> Priority Queue</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-org6188963" class="outline-4">
<h4 id="org6188963"><span class="section-number-4">1.7.1</span> General Idea</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
A priority queue is a special kind of queue. Elements in priority queue is weighted&#x2014;they have an attribute to be used to determine the sequence they leave the queue. In this section, we assume the smallest element leaves the queue first.
</p>

<p>
A priority queue is a data structure that allows at least the following two operations:
</p>
<ul class="org-ul">
<li><code>insert</code></li>
<li><code>deleteMin</code></li>
</ul>

<p>
<code>insert</code> does the obvious thing: insert an item into the data structure (container).
<code>deleteMin</code> will finds, returns and removes the minimum element in the priority queue.
</p>

<p>
There are various ways to implement a priority queue. For example, we can implement a binary search tree. So whenever we <code>deleteMin</code>, we can just delete the left most element in the binary tree (because it is the smallest element). Whenever we need to <code>insert</code>, we just call the <code>insert()</code> routine to do so.
</p>

<p>
However, this is not the ideal way because we may add complexity to the problem. It seems like some kind of overkill: we not only satisfy the requirement of prority queue, we also end up with a totally ordered data structure. In certain circumstances, we really only need the minimum. Keeping all other information seems like a waste of resources.
</p>
</div>
</div>
<div id="outline-container-org40a98a8" class="outline-4">
<h4 id="org40a98a8"><span class="section-number-4">1.7.2</span> Simple Implementation</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
Let's see a simple implementation of priority queue. We'll use a tree structure to implement the priority queue. Since binary search tree is overkill, we can implement a partially ordered binary search tree to achieve our goal, this is also called a binary <b>heap</b>.
</p>
</div>
<div id="outline-container-orge570ae7" class="outline-5">
<h5 id="orge570ae7"><span class="section-number-5">1.7.2.1</span> Structure Property</h5>
<div class="outline-text-5" id="text-1-7-2-1">
<p>
A heap is a binary tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right, such a tree is known as a <b>complete binary tree</b>.
</p>

<p>
It can be shown that a complete binary tree can be represented by an array (without the need of link). This is by knowing a node's position in the array (the index), we can calculate the position of its parent, left child and right child. Specifically:
</p>
<ul class="org-ul">
<li>if the root node's index is 1, then for a node at <code>array[i]</code>:
<ul class="org-ul">
<li>its parent is at <code>array[i/2]</code></li>
<li>its left child is at <code>array[2*i]</code></li>
<li>its right child is at <code>array[2*i+1]</code></li>
</ul></li>
<li>if the root node's index is 0, then for a node at <code>array[i]</code>:
<ul class="org-ul">
<li>its parent is at <code>array[(i+1)/2-1]</code>. This does not apply to root node.</li>
<li>its left child is at <code>array[2*i+1]</code></li>
<li>its right child is at <code>array[2*i+2]</code></li>
</ul></li>
</ul>


<p>
Now, we define the <b>partial order</b> of the complete binary tree. This <b>partial order</b> allows operations of priority queue to be performed quickly (its also called <b>heap-order-property</b>). Since we want to be able to find the minimum quickly, it makes sense that the smallest element should be at the root. If we consider that any subtree should also be a heap, then any node should be smaller than <b>ALL</b> of its descendants. Apply this logic, we arrive at the heap-order property: in a heap, for every node X, the key in the parent of X is smaller than (or equal to) the key in X, with the exception of root. This property suggests the minimum element can always be found at the root. Thus, <code>findMin</code> can operate in constant time.
</p>
</div>
</div>
<div id="outline-container-org9116d57" class="outline-5">
<h5 id="org9116d57"><span class="section-number-5">1.7.2.2</span> Binary Heap Class</h5>
<div class="outline-text-5" id="text-1-7-2-2">
<p>
Based on the above discussion, we can use an array to keep our heap. <code>std::vector</code> is a good choice. In our heap class, we also want to use an integer to keep track of the number of elements in heap: <code>currentSize</code>. Also, we'll use <code>array[1]</code> as the slot to hold the root of the heap (so <code>array[currentSize]</code> is the last element in the heap).
</p>
</div>
</div>
<div id="outline-container-org17fb0d1" class="outline-5">
<h5 id="org17fb0d1"><span class="section-number-5">1.7.2.3</span> <code>insert()</code></h5>
<div class="outline-text-5" id="text-1-7-2-3">
<p>
Pay attention to following things:
</p>
<ul class="org-ul">
<li>before adding a new element to a heap, always check the capacity of current container (the vector).</li>
<li>new item can only be added to the rightmost slot at the bottom of the complete binary tree.</li>
<li>after adding a new item, the heap-property may be violated. For example, the newly inserted item is smaller than its parent.</li>
<li>if heap-property is violated, we percolate up until:
<ul class="org-ul">
<li>we find the proper slot for inserted item, or:</li>
<li>we reach the root</li>
</ul></li>
</ul>
<p>
Code for <code>insert()</code> routine:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span>template &lt;class T&gt;
<span class="linenr"> 2: </span>void BinaryHeap&lt;T&gt;::insert(const T&amp; x) {
<span class="linenr"> 3: </span>  if (array.size() == currentSize + 1) {
<span class="linenr"> 4: </span>    array.resize(array.size() * 2);
<span class="linenr"> 5: </span>  }
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  int hole_index = ++currentSize;
<span class="linenr"> 8: </span>  while (hole_index != 1 &amp;&amp; x &lt; array[hole_index/2]) {
<span class="linenr"> 9: </span>    array[hole_index] = std::move(array[hole_index/2]);
<span class="linenr">10: </span>    hole_index /= 2;
<span class="linenr">11: </span>  }
<span class="linenr">12: </span>
<span class="linenr">13: </span>  array[hole_index] = x;
<span class="linenr">14: </span>}
</pre>
</div>
</div>
</div>
<div id="outline-container-org5fc73d9" class="outline-5">
<h5 id="org5fc73d9"><span class="section-number-5">1.7.2.4</span> <code>deleteMin()</code></h5>
<div class="outline-text-5" id="text-1-7-2-4">
<p>
The advantage of a heap is it can access it's smallest element at constant time, because it is stored at the root position (or the first item in the underlying array). On the other hand, heap is a complete binary tree, which means any addition or deletion should occur at the leftmost slot of the bottom layer (i.e. the last element in the underlying array).
</p>

<p>
To delete the smallest item, we remove the element stored in hole and use <code>array[currentSize]</code> to fill into the hole. This operation will very likely violate the heap order, since preciously root holds the smallest element in the heap, now an element in bottom layer (which is larger than at least half of the heap) is placed into root. So, we have to re-build heap property.
</p>

<p>
To re-build heap property, we use a routine <code>percolateDown()</code>. It accepts the position of a hole, and try to move it down to where it fits (i.e. to where the element in that hole satisfies heap order). This routine will be introduced in the following section. The code for <code>deleteMin()</code> is as follows:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>bool BinaryHeap&lt;T&gt;::deleteMin() {
<span class="linenr"> 2: </span>  //check if the heap is empty 
<span class="linenr"> 3: </span>  if (isEmpty())
<span class="linenr"> 4: </span>    return false;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  //move the last item to the root
<span class="linenr"> 7: </span>  array[1] = std::move(array[currentSize--]);
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>  //percolate down
<span class="linenr">10: </span>  percolateDown(1);
<span class="linenr">11: </span>
<span class="linenr">12: </span>  return true;
<span class="linenr">13: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-org661002e" class="outline-5">
<h5 id="org661002e"><span class="section-number-5">1.7.2.5</span> <code>percolateDown()</code></h5>
<div class="outline-text-5" id="text-1-7-2-5">
<p>
The header of <code>percolateDown()</code> is as follows:
</p>
<div class="org-src-container">
<pre class="src src-c++">template &lt;typename T&gt;
void BinaryHeap&lt;T&gt;::percolateDown(int hole)
</pre>
</div>

<p>
It accepts an integer identifying the position of a hole (index of this hole in the underlying vector). This function will check if element stored here violates the heap order. If so, it will move it downward until the element fits in.
</p>

<p>
<code>percolateDown()</code> will compare the element stored in hole with its the smaller one of its children, until:
</p>
<ul class="org-ul">
<li>a position is found so that element in hole is smaller than its child or children;</li>
<li>the process of percolating down has reached to the bottom layer, the hole doesn't have child, this is where it should go</li>
</ul>

<p>
First, we define a child index:
</p>
<div class="org-src-container">
<pre class="src src-c++">int child;
</pre>
</div>

<p>
Then, we keep the value of element stored in the hole:
</p>
<div class="org-src-container">
<pre class="src src-c++">T tmp = std::move(array[hole]);
</pre>
</div>

<p>
We use a for loop to percolate down. We compare the value of <code>tmp</code>  with the value of its smaller child. If <code>tmp</code> is larger, we move it downward one layer, and lift the corresponding child up one layer. It is like you move the hole downward one layer. If <code>tmp</code> is smaller, then the current hole is the right spot to place <code>tmp</code> in, so we break the loop and place <code>tmp</code> to this spot.
</p>

<p>
The code for this function is as follows:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;typename T&gt;
<span class="linenr"> 2: </span>void BinaryHeap&lt;T&gt;::percolateDown(int hole) {
<span class="linenr"> 3: </span>  int child;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  T tmp = std::move(array[hole]);
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  for (; hole * 2 &lt;= currentSize; hole = child) {//pay attention you may not have right child!
<span class="linenr"> 8: </span>    child = hole * 2; // select left child
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    // check if right child exist &amp;&amp; if it is smaller than left child
<span class="linenr">11: </span>    if (child != currentSize &amp;&amp; array[child + 1] &lt; array[child])
<span class="linenr">12: </span>      ++child;
<span class="linenr">13: </span>
<span class="linenr">14: </span>    // tmp is larger than its smaller child, should percolate down
<span class="linenr">15: </span>    if (array[child] &lt; tmp)
<span class="linenr">16: </span>      array[hole] = std::move(array[child]);
<span class="linenr">17: </span>    else //hole position found
<span class="linenr">18: </span>      break; 
<span class="linenr">19: </span>  }
<span class="linenr">20: </span>
<span class="linenr">21: </span>  // place tmp into the proper hole position
<span class="linenr">22: </span>  array[hole] = std::move(tmp);  
<span class="linenr">23: </span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-orge7a60c4" class="outline-5">
<h5 id="orge7a60c4"><span class="section-number-5">1.7.2.6</span> <code>buildHeap()</code></h5>
<div class="outline-text-5" id="text-1-7-2-6">
</div>
<div id="outline-container-org340a486" class="outline-6">
<h6 id="org340a486"><span class="section-number-6">1.7.2.6.1</span> Analysis and Implementation</h6>
<div class="outline-text-6" id="text-1-7-2-6-1">
<p>
Imagine we have an input array of size \(N\). The arrangment of elements in this array is random. Now we want to build up heap order in this array, i.e. we want to rearrange the elements in this array so that they have heap property &#x2014; a complete binary tree that is represented by array, and each parent is smaller than its children (if it has any).
</p>

<p>
In this section, a method with \(O(N)\) complexity will be introduced. First, we load the input array into our internal array. Assume the height of the heap is \(h\). Start from \((h - 1)\) layer (because node in \(h\) layer does not have any child), for each node in the heap that has at least one child, we try to percolate it down. We do this until the final node: the root. Then the whole array is built with heap order.
</p>

<p>
So, our next question is: what is the index for the first node that has at least one child (start from \(h - 1\) layer).
</p>

<p>
To calculate this, first imagine a complete binary heap tree with \(N\) elements and the height is \(h\). In \(h\)th layer, only leaf presents, and they may not occupy the whole layer. The number of node in layer \(h\) is:
\[
\text {total number of nodes} - \text {number of nodes before layer } h = N - 2^h + 1
\]
</p>

<p>
This number is either even (\(2k\)) or odd (\(2k + 1\)). If its even, it means all their parents in layer \(h - 1\) have two children. If its odd, it means the parent of the last node has only one child.
</p>

<p>
Thus, we can express the number of node in layer \((h - 1)\) that has at least one child as:
\[
\lceil \frac {N - 2^h + 1} {2} \rceil
\]
</p>

<p>
On the other hand, from the definition of complete binary tree, all nodes at layer \(0\) to layer \(h - 2\) have two children, i.e. \(2^{h - 1} - 1\) nodes have two children.
</p>

<p>
Thus, the number of nodes that has at least one child in a complete binary tree of size \(N\) is:
\[
2^{h - 1} - 1 + \lceil \frac {N - 2^h + 1} {2} \rceil
= 2^{h - 1} - 2^{h - 1} + \lceil \frac {N - 1} {2} \rceil
\]
</p>

<p>
If \(N\) is even, \(\lceil \frac {N - 1} {2} \rceil = \frac {N} {2}\). If \(N\) is odd, \(\lceil \frac {N - 1} {2} \rceil = \lfloor \frac {N} {2} \rfloor \), which is <code>N/2</code> in C++ integer division rule.
</p>

<p>
If we place the root in <code>array[1]</code>, then <code>N/2</code> is the index of the last node in heap that has at least one child, which needs percolateDown.
</p>

<p>
The implementation is simple:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;typename T&gt;
<span class="linenr">2: </span>void BinaryHeap&lt;T&gt;::buildHeap() {
<span class="linenr">3: </span>  for (int i = currentSize / 2; i &gt; 0; --i)
<span class="linenr">4: </span>    percolateDown(i);
<span class="linenr">5: </span>}
</pre>
</div>
</div>
</div>
<div id="outline-container-org784bf2b" class="outline-6">
<h6 id="org784bf2b"><span class="section-number-6">1.7.2.6.2</span> Complexity Analysis</h6>
<div class="outline-text-6" id="text-1-7-2-6-2">
<p>
The time complexity of <code>buildHeap()</code> can be bound by calculating the following terms:
</p>
<ul class="org-ul">
<li>The time required to do a single percolate down</li>
<li>The total number of percolate down required for all nodes</li>
</ul>

<p>
For a single percolate down, it will compare the two child of one node to pick the smaller one. And then it will compare the smaller child with the node. These are constant time complexity.
</p>

<p>
For the total number of percolate down we need, we have to consider the worst case: we have to percolate down each node we encounter to bottom. To calculate the total number is the same to calculate the sum of the heights of all the nodes in the heap, and it can be bound by the sum of the heights of all the nodes in a full-occupied complete binary tree of the same height. For such a tree, we have the following relation:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-center">layer</th>
<th scope="col" class="org-center">number of nodes</th>
<th scope="col" class="org-center">height of nodes on this layer</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-center">0</td>
<td class="org-center">1</td>
<td class="org-center">h</td>
</tr>

<tr>
<td class="org-center">1</td>
<td class="org-center">2</td>
<td class="org-center">h - 1</td>
</tr>

<tr>
<td class="org-center">2</td>
<td class="org-center">2<sup>2</sup></td>
<td class="org-center">h - 2</td>
</tr>

<tr>
<td class="org-center">\(\vdots \)</td>
<td class="org-center">\(\vdots \)</td>
<td class="org-center">\(\vdots \)</td>
</tr>

<tr>
<td class="org-center">h - 1</td>
<td class="org-center">2<sup>h - 1</sup></td>
<td class="org-center">1</td>
</tr>

<tr>
<td class="org-center">h</td>
<td class="org-center">2<sup>h</sup></td>
<td class="org-center">0</td>
</tr>
</tbody>
</table>

<p>
Thus, sum of heights for all nodes are:
\[
2^0 \cdot h + 2^1(h - 1) + 2^2(h - 2) + \cdots + 2^{h - 1}(h - (h - 1)) + 2^h \cdot 0 = \sum_{i = 0}^{h}2^i(h - i)
\]
</p>

<p>
Let \(S = \sum_{i = 0}^{h}2^i(h - i)\), then \(2S = \sum_{i = 0}^{h}2^{i + 1}(h - i)\). So:
\[
2S - S = -h + 2^1 + 2^2 + \cdots + 2^h = -h + \frac {2 - 2^{h + 1}} {1 - 2}
= 2^{h + 1} - h - 2
\]
</p>

<p>
Notice the relation between \(N\) and \(h\): \(N = 2^{h + 1} - 1\), so the time complexity for <code>buildHeap()</code> is:
\[
O(N)
\]
</p>
</div>
</div>
<div id="outline-container-org95d0c79" class="outline-6">
<h6 id="org95d0c79"><span class="section-number-6">1.7.2.6.3</span> Build Heap by <code>insert()</code></h6>
<div class="outline-text-6" id="text-1-7-2-6-3">
<p>
Another way to build heap is to traverse the input array, for each element encountered, we call <code>insert()</code> routine to insert it into our heap. From the implementation of <code>insert()</code> we know that, each inserted element will be percolated up to its proper position. Intuitively, this method has a higher time complexity than the percolate down method we just introduced. Let's call this <code>insert()</code> method as B, the percolating down method as A. We know:
</p>
<ul class="org-ul">
<li>For A, all the nodes at \(h - 1\) level only need to percolate down <b>ONE</b> layer</li>
<li>For B, only the second inserted node can enjoy one-level-percolating operation. For every newly inserted node, it has to percolate up to the root (the worst case).</li>
</ul>

<p>
Actually, for A and B, the number of percolating operation (down for A, up for B) of a specific node at a certain layer is just the opposite. We have the following relation:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />

<col  class="org-center" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-center">layer</th>
<th scope="col" class="org-center"># of nodes</th>
<th scope="col" class="org-center"># of percolating (A)</th>
<th scope="col" class="org-center"># of percolating (B)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-center">0</td>
<td class="org-center">1</td>
<td class="org-center">h</td>
<td class="org-center">0</td>
</tr>

<tr>
<td class="org-center">1</td>
<td class="org-center">2</td>
<td class="org-center">h - 1</td>
<td class="org-center">1</td>
</tr>

<tr>
<td class="org-center">2</td>
<td class="org-center">2<sup>2</sup></td>
<td class="org-center">h - 2</td>
<td class="org-center">2</td>
</tr>

<tr>
<td class="org-center">\( \vdots \)</td>
<td class="org-center">\( \vdots \)</td>
<td class="org-center">\( \vdots \)</td>
<td class="org-center">\( \vdots \)</td>
</tr>

<tr>
<td class="org-center">h - 1</td>
<td class="org-center">2<sup>h - 1</sup></td>
<td class="org-center">1</td>
<td class="org-center">h - 1</td>
</tr>

<tr>
<td class="org-center">h</td>
<td class="org-center">2<sup>h</sup></td>
<td class="org-center">0</td>
<td class="org-center">h</td>
</tr>
</tbody>
</table>

<p>
Total number of percolating in A is:
\[
1 \cdot h + 2(h - 1) + 2^2(h - 2) + \cdots + 2^{h - 1}(h - (h - 1)) + 2^h(h - h)
=2^{h + 1} - h - 2
\]
</p>


<p>
Total number of percolating in B is:
\[
1 \cdot 0 + 2 \cdot 1 + 2^2 \cdot 2 + \cdots + (h - 1)2^{h - 1} + h \cdot 2^h
= (h - 1)2^{h + 1} + 2
\]
</p>

<p>
Now, plug in the relation between \(h\) and \(N\):
\[
h = \log{N + 1} - 1
\]
</p>

<p>
The number of percolating in A is: \(N - \log{N + 1} = O(N)\).
</p>

<p>
The number of percolating in B is: \((N + 1)\log{N + 1} - 2N = O(N\log{N})\).
</p>

<p>
Thus, building heap by calling <code>insert()</code> repeatedly has a much higher time complexity than the percolating down method.
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc260164" class="outline-2">
<h2 id="orgc260164"><span class="section-number-2">2</span> Sorting</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org0312230" class="outline-3">
<h3 id="org0312230"><span class="section-number-3">2.1</span> Bubble Sort</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org8d27df1" class="outline-4">
<h4 id="org8d27df1"><span class="section-number-4">2.1.1</span> General Idea</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
Bubble sort is a sorting algorithm that compares adjacent elements in the array. At each iteration of bubble sort, we compare the consecutive adjacent element. If they are out-of-order, we swap them to give order to the two adjacent elements, and label this iteration has <b>swapped</b>. Do this for all elements in the array. If one iteration has <b>swapped</b>, we do another. If we run through the array and no swapping happend, we know that the array is in order.
</p>
</div>
</div>
<div id="outline-container-org5337e0d" class="outline-4">
<h4 id="org5337e0d"><span class="section-number-4">2.1.2</span> Implementation</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
The code is as follows:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;class RandomAccessIterator, class Compare&gt;
<span class="linenr"> 2: </span>void Sort::bubbleSort(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
<span class="linenr"> 3: </span>  //define a variable to hold swapping information
<span class="linenr"> 4: </span>  bool swapped;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  //go over the range and do bubble sort
<span class="linenr"> 7: </span>  do {
<span class="linenr"> 8: </span>    swapped = false; //at beginning of each iteration, label swapped as false
<span class="linenr"> 9: </span>    for (auto itr = first; itr &lt; last - 1; ++itr) {
<span class="linenr">10: </span>      if (!comp(*itr, *(itr + 1)) &amp;&amp; *itr != *(itr + 1)) {
<span class="linenr">11: </span>	std::swap(*itr, *(itr + 1));
<span class="linenr">12: </span>	swapped = true;
<span class="linenr">13: </span>      }
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>
<span class="linenr">16: </span>  } while (swapped);
<span class="linenr">17: </span>}
</pre>
</div>
<p>
Pay attention that the function object <code>comp</code> may not define cases that two elements are equal. You have to manually consider this situation, otherwise, you may run into an infinite loop, since two elements equal will be considered <b>NOT</b> in order, and swap them won't change this fact, so the loop will not stop.
</p>
</div>
</div>
</div>

<div id="outline-container-org9cfdac1" class="outline-3">
<h3 id="org9cfdac1"><span class="section-number-3">2.2</span> Insertion Sort</h3>
<div class="outline-text-3" id="text-2-2">
</div>
<div id="outline-container-org65e8fd9" class="outline-4">
<h4 id="org65e8fd9"><span class="section-number-4">2.2.1</span> General Idea</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
Given a random array with \(N\) elements, insertion sort will build a sorted sub-array at the front of the array by continuosly insert elements from the rest of the array into this ordered sub-array. Assume we're at \(p\)th iteration of insertion sort, then the subarray from <code>array[0]</code> to <code>array[p - 1]</code> are sorted, and we insert <code>array[p]</code> into the proper position in the ordered subarray, resulting an ordered subarray from <code>array[0]</code> to <code>array[p]</code>. We repeat this process until we traverse the array and have them sorted.
</p>
</div>
</div>
<div id="outline-container-orgd2412ca" class="outline-4">
<h4 id="orgd2412ca"><span class="section-number-4">2.2.2</span> Implementation</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
Assume we are sorting an array in the range defined by two iterators: <code>[first, last)</code>. We'll take a look at \(p\)th iteration to determine how we insert. Assume we have an iterator <code>p</code> that is pointing to the element to be inserted. We use another iterator <code>i</code> to record its proper position (initially, <code>i = p</code>). We compare <code>*i</code> and <code>*(i - 1)</code> repeatedly (<code>i &gt; first</code>). Two possible cases:
</p>
<ul class="org-ul">
<li><code>*(i - 1)</code> and <code>*i</code> are in order: we have found the proper position</li>
<li><code>*(i - 1)</code> and <code>*i</code> are not in order: we swap <code>*(i - 1)</code> and <code>*i</code> to give them order, and we update <code>i</code> (<code>--i</code>), then compare <code>*i</code> and <code>*(i - 1)</code> again.</li>
</ul>

<p>
After the above loop, we can accomplish the job of inserting <code>*p</code> into the proper position in the ordered subarray (by a bubble-sort like swapping).
</p>

<p>
We repeat this operation to all elements from element at <code>first + 1</code> to <code>last - 1</code>.
</p>

<p>
The code is as follows (a function object is used to define order):
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;class RandomAccessIterator, class Compare&gt;
<span class="linenr"> 2: </span>void Sort::insertionSort(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
<span class="linenr"> 3: </span>  for (RandomAccessIterator p = first + 1; p &lt; last; ++p) {
<span class="linenr"> 4: </span>    for (RandomAccessIterator i = p; i &gt; first; --i) {
<span class="linenr"> 5: </span>      if (comp(*(i - 1), *i)) //array[i] is in right position
<span class="linenr"> 6: </span>	break;
<span class="linenr"> 7: </span>      else 
<span class="linenr"> 8: </span>	std::swap(*(i-1), *i);
<span class="linenr"> 9: </span>    }
<span class="linenr">10: </span>  }  
<span class="linenr">11: </span>}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdb72c20" class="outline-4">
<h4 id="orgdb72c20"><span class="section-number-4">2.2.3</span> Lower Bound</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
It can be proved that all sorting algorithms that just swapping adjacent elements has a lower bound of \(\Omega(N^2)\). This is true for both bubble sort and insertion sort.
</p>
</div>
</div>
</div>
<div id="outline-container-org188902a" class="outline-3">
<h3 id="org188902a"><span class="section-number-3">2.3</span> Shell Sort</h3>
<div class="outline-text-3" id="text-2-3">
</div>
<div id="outline-container-org1d74320" class="outline-4">
<h4 id="org1d74320"><span class="section-number-4">2.3.1</span> General Idea</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
Shell sort tries to break the \(\Omega(N^2)\) (the quadratic time barrier) by comparing and swapping elements that are distant from each other. How distant? Shell sort uses a sequence: \(h_1, h_2, ..., h_t\) to represent the distance between two elements being compared. \(h_1\) is always equal to 1 and it is the last increment step the Shell sort will use. This means at the end, Shell sort will still sort adjacent elements. However, at that time, many inversions have been solved by previous sorting with increment step = \(h_2, h_3, ..., h_t\).
</p>

<p>
Basically, Shell sort works in this way.
</p>

<p>
First, we choose an increment sequence: \(h_1, h_2, ..., h_t, h_1 = 1\). We start from \(h = h_t\). On this phase, we name it as \(h_t\)-sort. We compare and sort each following subarray:
</p>
\begin{equation*}
a_i, a_{i + h_t}, a_{i + 2h_t}, ...
\end{equation*}
<p>
The index goes to where \(i + kh_t\) is within the range. Apparently, \(i = 0, 1, 2, ..., h_t - 1\). For every \(i\), we sort the corresponding subarray (using insertion sort, for example. Just treat it like ordinary adjacent array). After we have sorted the subarray for all possible \(i\), the array is said to be \(h_t\)-sorted. Elements separated by \(h_t\) is in order. We repeat this process until we finish \(h_1\) sort, then the array is sorted. An important property of Shell sort is that if an \(h_k\)-sorted array goes through \(h_{k - 1}\)-sort (i.e. it is \(h_{k - 1}\)-sorted), it will remain \(h_k\)-sorted.
</p>
</div>
</div>
<div id="outline-container-orgc314a45" class="outline-4">
<h4 id="orgc314a45"><span class="section-number-4">2.3.2</span> Implementation</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
The choice of increment sequence can greatly influence the performance of Shell sort. In this section, Shell's original increment sequence will be used to illustrate the implementation of Shell sort. Shell's increment sequence is:
\[
h_t = \frac {\text {size}} {2}, h_{t - 1} = \frac {\text{size}} {4}, ..., h_1 = 1
\]
</p>

<p>
We are going to implement a Shell sort routine which has three parameters. Two iterators that give range of the array to sort: <code>[first, last)</code>. One function object that with <code>operator()</code> defined to give order to two elements in the array: <code>comp</code>. The header of the routine is as follows:
</p>
<div class="org-src-container">
<pre class="src src-c++">template &lt;class RandomAccessIterator, class Compare&gt;
void Sort::shellSort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
</pre>
</div>
<p>
We'll use insertion sort to sort each subarray, just treat each \(h_k\) apart element as "adjacent". We'll use a for loop to go over all \(h_k\) to sort the array:
</p>
<div class="org-src-container">
<pre class="src src-c++">for (int h = (last - first) / 2; h &gt; 0; h /= 2)
</pre>
</div>

<p>
For each iteration \(h_k\), we start at <code>*(first + h)</code> element (or <code>array[h]</code>). This is the second element from subarray <code>array[0], array[0 + h], array[0 + 2h], ...</code>. This is because the first element in the subarray is naturally sorted (only one element present), so we start with its second element and try to insert it into the ordered array. (Also pay attention that, <code>array[0], array[1], ..., array[h - 1]</code> are the first element in each subarray).
</p>

<p>
To sort all the subarrays, rather than sort one subarray at a time, we can just sort all subarrays simultaneously. Specifically, after we deal with <code>array[h]</code>, we move to the next element, <code>array[h + 1]</code>, which is the second element from subarray <code>array[1], array[1 + h], array[1 + 2h], ...</code>. We insert this element into the corresponding ordered section of its subarray. Then we move on to <code>array[h + 2]</code>, and etc, all the way to the last element of the range. We use a for loop to do this:
</p>
<div class="org-src-container">
<pre class="src src-c++">for (auto p = first + h; p != last; ++p)
</pre>
</div>

<p>
Notice that <code>p</code> is an iterator. For each element to be sorted in this for loop (for each <code>*p</code>), we perform an insertion operation:
</p>
<div class="org-src-container">
<pre class="src src-c++">// keep value of *p
auto temp = std::move(*p);
// define an iterator to hold where *p should go
auto j = p;
// looking into the sorted section to see where should *p go
for (; j &gt;= first + h &amp;&amp; !comp(*(j - h), temp); j -= h)
  *j = std::move(*(j - h));
// after above for loop, j is where *p should go
*j = std::move(temp);
</pre>
</div>

<p>
In this way, we have sorted the array by Shell sort algorithm. The combined code is as follows:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;class RandomAccessIterator, class Compare&gt;
<span class="linenr"> 2: </span>void Sort::shellSort(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>  for (int h = (last - first) / 2; h &gt; 0; h /= 2) {
<span class="linenr"> 5: </span>    for (auto p = first + h; p != last; ++p) {
<span class="linenr"> 6: </span>      auto temp = std::move(*p);
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>      auto j = p;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>      for (; j &gt;= first + h &amp;&amp; !comp(*(j - h), temp); j -= h)
<span class="linenr">11: </span>	*j = std::move(*(j - h));
<span class="linenr">12: </span>
<span class="linenr">13: </span>      *j = std::move(temp);
<span class="linenr">14: </span>    }
<span class="linenr">15: </span>  }
<span class="linenr">16: </span>}
</pre>
</div>
</div>
</div>
<div id="outline-container-org9982f92" class="outline-4">
<h4 id="org9982f92"><span class="section-number-4">2.3.3</span> Worst-Case (Shell's increment sequence)</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
<b>Proof</b> the upper bound of Shell sort using Shell's increment sequence is \(O(N^2)\).
</p>

<p>
We proof this by the following steps:
</p>
<ul class="org-ul">
<li>calculate the complexity to sort the array for a single pass (\(h = h_k\)).</li>
<li>add them together over all passes (\(h_t, h_{t - 1}, ..., h_1\)).</li>
</ul>

<p>
Assume the current increment size is \(h_k (h_k < N)\). Then, we have a total of \(h_k\) subarrays to be sorted. The first element for each subarray is:
</p>
<ul class="org-ul">
<li><code>array[0]</code>: first element of subarray 1</li>
<li><code>array[0 + 1]</code>: first element of subarray 2</li>
<li><code>array[0 + 2]</code>: first element of subarray 3</li>
<li><code>array[0 + 3]</code>: first element of subarray 4</li>
<li>&#x2026;</li>
<li><code>array[0 + hk - 1]</code>: first element of subarray \(h_k\)</li>
</ul>

<p>
The total element number is \(N\), the average element number in each subarray is \(N/h_k\). We will perform insertion sort for each subarray. The complexity for insertion sort is \(O(n^2)\), where \(n\) is the size of array to be sorted. In our case:
\[
n = \frac {N} {h_k}
\]
</p>

<p>
So, the complexity for sorting each subarray using insertion sort is:
\[
O[(\frac {N} {h_k})^2]
\]
</p>

<p>
As mentioned before, the number of subarrays in this pass is \(h_k\). Thus, total complexity for this pass (\(h = h _k\)) is:
\[
O[h_k\cdot(\frac {N} {h_k})^2] = O(\frac {N^2} {h_k})
\]
</p>

<p>
Now, we can add them togheter over all passes (\(h_t, h_{t - 1}, ..., h_1\)) to give the total time complexity:
\[
O(\sum_{i = 1}^{t}\frac {N^2} {h_i}) = O(N^2\sum_{i = 1}^{t} \frac {1} {h_i})
\]
</p>

<p>
For Shell's original increment sequence, \(h_{i + 1} = 2h_i\), thus:
\[
\frac {1} {h_{i + 1}} = \frac {1} {2} \cdot \frac {1} {h_i} \Rightarrow
\sum_{i = 1}^{t} \frac {1} {h_i} = 2 - (\frac {1} {2})^{t - 1}) < 2 \text { (using } h_1 = 1 \text {)}
\]
</p>

<p>
Thus:
\[
O(N^2\sum_{i = 1}^{t} \frac {1} {h_i}) \sim O(N^2)
\]
</p>

<p>
The problem with Shell's original increment is that pairs of increments (\(h_k, h_{k + 1}\)) are not necessarily relatively prime: they may have common factor. One smaller increment may be the factor of previously larger increment, so it is spending time to sort elements already sorted by the larger increment (notice that checking if elements are sorted also takes time). This causes the smaller increment can have little effect in sorting array.
</p>
</div>
</div>
<div id="outline-container-org5f6d7ff" class="outline-4">
<h4 id="org5f6d7ff"><span class="section-number-4">2.3.4</span> Hibbard's increment sequence</h4>
<div class="outline-text-4" id="text-2-3-4">
<p>
In the following discussion, we'll assume sorting the array in ascending order.
</p>

<p>
Hibbard's increment sequence is as follows:
\[
h_k = 2^k - 1
\]
</p>

<p>
For a given array, with \(N\) elements, the largest step size \(h_t\) should be chosen that is smaller than \(N\). For example, if an array has 9 elements, then the largest increment \(h_t\) should be: \(2^3 - 1 = 7\).
</p>

<p>
Now, we focus on calculating the upper bound of Shellsort that sorts an array with \(N\) elements using Hibbard's increment sequence. We use the same strategy as before to calculate this:
</p>
<ul class="org-ul">
<li>calculate the complexity to sort the array for a single pass (\(h = h_k\)).</li>
<li>add them together over all passes (\(h_t, h_{t - 1}, ..., h_1\)).</li>
</ul>

<p>
For a single pass with \(h_k\), we have already proved that the upper bound is \(O(\frac {N^2} {h_k})\). This is valid for any sequence you use as long as you use sorting algorithm that has \(O(N^2)\) complexity to sort the subarrays. Take insertion sort as an example. During derivation of this result, we have assumed that when sorting each subarray, we have to traverse back to the beginning of the subarray to insert the new item. i.e. this is a worst case. We have to assume this because we don't know the characteristic of our increment sequence \(h_1, h_2, ..., h_t\). So we have no idea whether the insertion will stop <b>BEFORE</b> reaching the beginning or not. Thus, it is reasonable to make this worst case assumption.
</p>

<p>
However, since we know the characteristic of Hibbard's increment sequence, we can explore if there is any chance of finding the appropriate place to insert <b>BEFORE</b> we reach the beginning of the sorted-subsection. To put it in an Intuitively way, we must take advantage of the fact that the Hibbard's increment sequence is special.
</p>

<p>
Now, let's take a look at how we can take advantage of the characteristic of Hibbard's increment sequence. First, consider the following case. When we come to \(h_k\)-sort the input array, we know that is has already been \(h_{k + 1}\)-sorted and \(h_{k + 2}\)-sorted prior to the current \(h_k\)-sort. Let's consider elements in position \(p\) and \(p - i\), where \(i \leq p\). We can say:
</p>
<ul class="org-ul">
<li>if \(i\) is a multiple of \(h_{k + 1}\) or \(h_{k + 2}\), then <code>array[p - i]</code> and <code>array[p]</code> are sorted.</li>
<li>if \(i\) can be linearly expressed by \(h_{k + 1}\) and \(h_{k + 2}\), then <code>array[p - i]</code> and <code>array[p]</code> are sorted.</li>
</ul>

<p>
The first one is obvious: it is just saying that the distance between <code>array[p - i]</code> and <code>array[p]</code> is multiples of \(h_{k + 1}\) or \(h_{k + 2}\). So, they must be sorted after \(h_{k + 1}\)-sort and \(h_{k + 2}\)-sort. For the second one, we can see the following example.
</p>

<p>
Imagine we finished 7-sort and 15-sort (for Hibbard's increment, \(h_3 = 7, h_4 = 15\)), now we are going to do 3-sort (\(h_2 = 3\)). Let's consider \(i = 52\). It can be linearly expressed by 15 and 7: \(52 = 1 \times 7 + 3 \times 15\). Let \(p = 152\), then we can say that <code>array[152 - 52]</code> and <code>array[152]</code> are sorted. This is because:
</p>
<ul class="org-ul">
<li><code>array[100]</code> and <code>array[100 + 7]</code> are sorted</li>
<li><code>array[107]</code> and <code>array[107 + 15]</code> are sorted</li>
<li><code>array[122]</code> and <code>array[122 + 15]</code> are sorted</li>
<li><code>array[137]</code> and <code>array[137 + 15], or array[152]</code> are sorted</li>
</ul>

<p>
Generally, if \(i\) can be linearyly expressed by \(h_{k + 1}\) and \(h_{k + 2}\), then you can perform the chain conparing shown above using the linear combination and find the sorted pair.
</p>

<p>
So, if \(i\) can be linearly expressed by \(h_{k + 1}\) and \(h_{k + 2}\), then we can expect finding an sorted pair <code>array[p - i]</code> and <code>array[p]</code>. Once we find an sorted pair, we find a proper position to insert <code>array[p]</code> without having to traverse all the way back to the beginning of array.
</p>

<p>
Now, let's take a look at the characteristic of Hibbard's increment sequence:
\[
h_k = 2^k - 1
\]
</p>

<p>
Using this, we have:
\[
h_{k + 2} = 2h_{k + 1} + 1
\]
</p>

<p>
This suggests that \(h_{k + 1}\) and \(h_{k + 2}\) are relatively prime&#x2014;they can't share a common factor. It can be shown that:
</p>
<blockquote>
<p>
if \(a\) and \(b\) are relative prime, then \(a\) and \(b\) can be used as a pair of base to linearly express any integer that is as large as \((a - 1)(b - 1)\)
</p>
</blockquote>

<p>
In our case, we know that if a distance \(i\) is larger than \((h_{k + 1} - 1)(h_{k + 2} - 1)\), it can be linearly expressed by \(h_{k + 1}\) and \(h_{k + 2}\). (And this is why we only consider two passes prior to \(h_k\), since \((h_{k + 1} - 1)(h_{k + 2} - 1)\) is the smallest integer, when we are looking proper position for <code>array[p]</code> in the sorted section, \(i\) will first reach \((h_{k + 1} - 1)(h_{k + 2} - 1)\)).
</p>

<p>
Now plug in \(h_{k + 1} = 2^{k + 1} - 1\) and \(h_{k + 2} = 2^{k + 2} - 1\) into \((h_{k + 1} - 1)(h_{k + 2} - 1)\), we have:
\[
(h_{k + 1} - 1)(h_{k + 2} - 1) = (8h_k + 4)h_k
\]
</p>

<p>
When trying to insert <code>temp = array[p]</code> into the sorted section, we are comparing the following paris:
</p>
<ul class="org-ul">
<li><code>&lt;array[p - hk], temp&gt;</code></li>
<li><code>&lt;array[p - 2 * hk], temp&gt;</code></li>
<li><code>&lt;array[p - 3 * hk], temp&gt;</code></li>
<li>&#x2026;</li>
<li><code>&lt;array[p - j * hk], temp&gt;</code></li>
</ul>

<p>
If \(j = (8h_k + 4)\), \(j \cdot h_k = (8h_k + 4) h_k = (h_{k + 1} - 1)(h_{k + 2} - 1)\), so it is guaranteed that it can be linearly expressed by \(h_{k + 1}\) and \(h_{k + 2}\). So after we reach this point, we <b>KNOW</b> that we don't have to continue to the begining of the sorted section, we can stop at here.
</p>

<p>
Thus, we need at most \(j = 8h_k + 4\) steps to insert an unsorted element into the sorted section of the subarray. And the total number of unsorted elements at \(h_k\)-sort is \(N - h_k\) (the first \(h_k\) elements are sorted in nature, they are the first elements of each \(h_k\) subarray). Thus, for each pass \(h_k\), the bound should be:
\[
(8h_k + 4)(N - h_k) \sim O(Nh_k)
\]
</p>

<p>
Is this bound suitable for all passes from \(h_t\) to \(h_1\), so the total bound is \(\sum_{i = 1}^{t}O(Nh_i)\)?
</p>

<p>
Actually, not really. Intuitively, we can think that, as \(h_i\) becomes large, \((8h_i + 4)h_i\) will become so large, that <code>a[p - hi * (8 * hi + 4)]</code> goes beyond the beginning position, i.e. you will reach beginning before you reach a point whose distance bwteen <code>*p</code> can be linearyly expressed by \((h_{k + 1} - 1)(h_{k + 2} - 1)\). Our question becomes, how large \(h_k\) should bem if the "linear-combination sorted" case can be reached earlier than the worst-case of general insertion sort (reaching the begining)?
</p>

<p>
To answer this question, let's consider an array of size \(N\). If \(N = 2^t\), then \(h_t = 2^t - 1\) is the largest step size in the increment sequence. The complexity of insertion sort is:
\[
O(\frac {N^2} {h_k})
\]
</p>

<p>
The complexity of "linear combination sorted" case is:
\[
O(Nh_k)
\]
</p>

<p>
Let:
\[
\frac {N^2} {h_k} = Nh_k
\]
</p>

<p>
solve it, we have:
\[
h_k = N^{\frac {1} {2}}
\]
</p>

<p>
This means, when \(h_k < N^{\frac {1} {2}}\), the "linear combination" case will apprear first before reaching to the beginning of the array. When \(h_k < N^{\frac {1} {2}}\), original insertion sort will be faster to reach the begining. Plug in \(N = 2^t\) into \(h_k = N^{\frac {1} {2}}\):
\[
h_k = 2^{\frac {t} {2}} \sim 2^{\frac {t} {2}} - 1 \sim \text {roughly } k = \frac {t} {2}
\]
</p>

<p>
Thus, roughly, about half of the increments (\(h_k\)s) satisfy \(h_k < N^{\frac {1} {2}}\).
</p>

<p>
So, we have to calculate the upper bound in two sections:
</p>
<ol class="org-ol">
<li>\(h_k \leq N^{\frac {1} {2}}\). In this section, the upper bound is \(O(Nh_k)\)</li>
<li>\(h_k > N^{\frac {1} {2}}\). In this section, the upper bound is \(O(\frac {N^2} {h_k})\)</li>
</ol>

<p>
Assume \(t\) is even, then we have:
\[
O(\sum_{k = 1}^{\frac {t} {2}}Nh_k + \sum_{k = \frac {t} {2} + 1}^{t}\frac {N^2} {h_k}) = O(N\sum_{k = 1}^{\frac {t} {2}}h_k + N^2\sum_{k = \frac {t} {2} + 1}^{t}\frac {1} {h_k})
\]
</p>

<p>
Pay attention that, both sums are geometric series (the latter is semi-geometric). So in the first sum, the last term dominates (because \(h_t\) is the largest), so:
\[
O(N\sum_{k = 1}^{\frac {t} {2}}h_k) = O(Nh_{\frac {t} {2}})
\]
</p>

<p>
In the second sum, the first term dominates (because \(h_{\frac {t} {2}}\) is the smallest, so \(\frac {1} {h_{\frac {t} {2}}}\) is the largest), so we have:
\[
O(N^2\sum_{k = \frac {t} {2} + 1}^{t}\frac {1} {h_k}) = O(\frac {N^2} {h_{\frac {t} {2}}})
\]
</p>

<p>
The combined upper bound is :
\[
O(Nh_{\frac {t} {2}}) + O(\frac {N^2} {h_{\frac {t} {2}}})
\]
</p>

<p>
Since \(h_{\frac {t} {2}} = 2^{\frac {t} {2}} - 1 \sim N^{\frac {1} {2}} \Rightarrow h_{\frac {t} {2}} = \Theta (N^{\frac {1} {2}})\), we have:
\[
O(Nh_{\frac {t} {2}}) + O(\frac {N^2} {h_{\frac {t} {2}}}) = O(N^{\frac {3} {2}})
\]
</p>

<p>
The upper bound of Shell sort, using Hibbard's increments, is \(O(N^{\frac {3} {2}})\).
</p>
</div>
</div>
</div>

<div id="outline-container-orgbdadc39" class="outline-3">
<h3 id="orgbdadc39"><span class="section-number-3">2.4</span> Heap Sort</h3>
<div class="outline-text-3" id="text-2-4">
</div>
<div id="outline-container-org17aa484" class="outline-4">
<h4 id="org17aa484"><span class="section-number-4">2.4.1</span> General Idea</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
For an unordered array, we can first build heap order in it (by the <code>buildHeap()</code> routine). This step takes \(O(N)\) time. Then, we can perform \(N\) <code>deleteMin()</code> operations to extract the elements in the array in order. For each <code>deleteMin()</code>, time required is \(O(\log{N})\). So the total time required to "delete" all elements is \(O(N\log{N})\). We can move the deleted item into the last slot of the current array (where hole is created, of course, we still have to <code>currentSize--</code>). In this way, we can sort the array in place, no need of extra memory space to hold the temporary array.
</p>
</div>
</div>
<div id="outline-container-orge9795f9" class="outline-4">
<h4 id="orge9795f9"><span class="section-number-4">2.4.2</span> Implementation</h4>
<div class="outline-text-4" id="text-2-4-2">
</div>
<div id="outline-container-org4be4f52" class="outline-5">
<h5 id="org4be4f52"><span class="section-number-5">2.4.2.1</span> Analysis</h5>
<div class="outline-text-5" id="text-2-4-2-1">
<p>
In this example, we assume the internal complete binary tree starts at <code>array[0]</code>.
The header for my <code>heapSort()</code> function is as follows (which is part of <code>Sort</code> class):
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;class Iterator, class Compare&gt;
<span class="linenr">2: </span>void heapSort(Iterator first, Iterator last, Compare comp);
</pre>
</div>
<p>
This function will sort the array in the range defined by <code>[first, last)</code>. The object <code>comp</code> will be used to give order to the elements in the range. This object is assumed to have operator() (the function call operator) overloaded to give proper ordering information.
</p>

<p>
We implement the routine in the following steps:
</p>
<ul class="org-ul">
<li>build up a heap order in the range. We'll use <code>comp</code> to determine the relative order of the elements: to determine which will be at the root.</li>
<li>take away element at the root (the smallest or biggest element at the time of being deleted from the original array, this operation will create a hole in root). You also have to move the element at the last slot to the hole. Take together, what you should do is <code>std::swap(array[root], array[currentSize-1])</code>.</li>
<li><code>percolateDown()</code> the root (to restore the heap order).</li>
<li>continue these steps until you traversed the range, sorting complete.</li>
</ul>
</div>
</div>
<div id="outline-container-orgd7301c0" class="outline-5">
<h5 id="orgd7301c0"><span class="section-number-5">2.4.2.2</span> Build up heap order</h5>
<div class="outline-text-5" id="text-2-4-2-2">
<p>
Before diving into details, one thing must be made clear. From the function header, we know that we want to <b>SORT</b> the range by the logic defined by <code>comp</code>. However, as we can see from the mechanism of heap sort, the actual sequence is the inverse of the target sequence. In order to address this issue, we can build a heap order that is the inverse of the order defined by <code>comp</code>. In the following section, we'll apply this idea.
</p>


<p>
To build up heap order, we start from the first node that has child in the range, percolate down one by one until we percolate down the root. The number of node that has at least one child in a heap of size \(N\) with root at <code>array[1]</code> is \(N/2\) (integer division). For a heap of size \(N\) with root at <code>array[0]</code> is \(N/2-1\). So, we start from <code>array[N/2-1]</code>, all the way until we percolate down <code>array[0]</code>.
</p>

<div class="org-src-container">
<pre class="src src-C++"><span class="linenr">1: </span>//get the size of the range 
<span class="linenr">2: </span>int currentSize = last - first;
<span class="linenr">3: </span>for (int i = currentSize/2-1; i &gt;= 0; --i) {
<span class="linenr">4: </span>  percolateDown(first, last, comp, i);
<span class="linenr">5: </span>}
<span class="linenr">6: </span>
</pre>
</div>
<p>
We used a routine <code>percolateDown()</code> in the above code. What it does is to check if element at <code>*(first + i)</code> is violating the heap property (i.e. greater or smaller than its child or children, depending on what <code>comp</code> is). If it violates, then We'll move the child to its position and continue checking if it violating heap property again (with its new child). We continue this process until:
</p>
<ul class="org-ul">
<li>we find a proper position that it does not violate the heap property. Or:</li>
<li>the hole reached bottom (i.e. there is no child, can't go further down)</li>
</ul>

<p>
We declare the <code>percolateDown()</code> routine as follows:
</p>
<div class="org-src-container">
<pre class="src src-C++"><span class="linenr"> 1: </span>template &lt;class Iterator, class Compare&gt;
<span class="linenr"> 2: </span>void percolateDown(Iterator first, Iterator class, Compare comp, int hole ) {
<span class="linenr"> 3: </span>  int child;
<span class="linenr"> 4: </span>  int currentSize;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  auto tmp = std::move(*(first + hole));
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  for (; hole * 2 + 1 &lt;= currentSize; hole = child) {
<span class="linenr"> 9: </span>    child = hole * 2 + 1; //left child
<span class="linenr">10: </span>
<span class="linenr">11: </span>    // check right child's existence
<span class="linenr">12: </span>    // if it exists, pick the child according to comp
<span class="linenr">13: </span>    // pay attention that the order is the inverse of what comp() defined
<span class="linenr">14: </span>    if (child != currentSize &amp;&amp; comp(*(first + child), *(first + child + 1)))
<span class="linenr">15: </span>      ++child;
<span class="linenr">16: </span>
<span class="linenr">17: </span>    //if the value in hole violated heap property
<span class="linenr">18: </span>    //percolate hole down
<span class="linenr">19: </span>    if (comp(tmp, *(first + child)))
<span class="linenr">20: </span>      *(first + hole) = std::move(*(first + child));
<span class="linenr">21: </span>    else //heap property not violated, proper position found
<span class="linenr">22: </span>      break;
<span class="linenr">23: </span>  }
<span class="linenr">24: </span>
<span class="linenr">25: </span>  *(first + hole) = std::move(tmp);  
<span class="linenr">26: </span>}
<span class="linenr">27: </span>
<span class="linenr">28: </span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org18a4293" class="outline-5">
<h5 id="org18a4293"><span class="section-number-5">2.4.2.3</span> Sort Using Heap Order</h5>
<div class="outline-text-5" id="text-2-4-2-3">
<p>
We need a routine to take away the element at the root and re-build the heap. This is similar with <code>deleteMin()</code> in binary heap class. The difference is that we keep the "deleted" element to build up a sorted array. The working steps are as follows:
</p>
<ul class="org-ul">
<li>define an integer, <code>currentSize</code>, to hold the number of unsorted elements. Pay attention that we don't need to move the last element (its already in sorted position).</li>
<li>use a for loop to operate <code>currentSize - 1</code> times. (begin at  <code>currentSize = last - first</code>, stop at <code>currentSize = 1</code>):
<ul class="org-ul">
<li>swap the first and last item in the range (<code>std::swap(*(first), *(first + currentSize - 1))</code>). Now the original root is in sorted section.</li>
<li><code>percolateDown()</code> the first item (which now contains the previously last item) to proper position. This is to restore heap property. The range you pass into <code>percolateDown()</code> should be the shrinked one, because you have to assume the heap size is reduced by one.</li>
<li>decrement <code>currentSize</code> by 1.</li>
</ul></li>
</ul>


<p>
Code for <code>heapSort()</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>void Sort::heapSort(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
<span class="linenr"> 2: </span>  //first step: build up heap order 
<span class="linenr"> 3: </span>  buildHeap(first, last, comp);
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  //begin sorting 
<span class="linenr"> 6: </span>  int currentSize = last - first;
<span class="linenr"> 7: </span>  for (; currentSize &gt; 1; --currentSize) {
<span class="linenr"> 8: </span>    std::swap(*(first), *(first + currentSize - 1));
<span class="linenr"> 9: </span>    if (currentSize &gt; 2)
<span class="linenr">10: </span>      //hole is always the first element 
<span class="linenr">11: </span>      percolateDown(first, first + currentSize - 2, comp, 0);
<span class="linenr">12: </span>  }
<span class="linenr">13: </span>}
<span class="linenr">14: </span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7bb57bf" class="outline-4">
<h4 id="org7bb57bf"><span class="section-number-4">2.4.3</span> Complexity Analysis</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
(this section may be flawed, it is based on my calculation. I couldn't understand the textbook's derivation.)
The heap sort contains two parts: (1) create heap order (heapify) inside the target range; (2) sort the array by repeatedly take the root of the heap (the first term in the array) to build up an ordered array.
</p>
</div>
<div id="outline-container-org8c0f1a5" class="outline-5">
<h5 id="org8c0f1a5"><span class="section-number-5">2.4.3.1</span> Build Heap</h5>
<div class="outline-text-5" id="text-2-4-3-1">
<p>
To build heap order in a random array, we start from the first node that has at least one child. We check if this node violates the heap order. If so, we swap it with one of its child. For a heap with height h, the total height is \(2^{h+1}-(h+1)-1\). This value is the total number of layers to percolate down for all the nodes (the worst case). On the other hand, the height of heap can be expressed by the number in the heap by: \(h = \log(N + 1) - 1\). Plug into the expression of total height, the number of operations is: \(N - \log(N + 1)\).
</p>
</div>
</div>
<div id="outline-container-org2eded4a" class="outline-5">
<h5 id="org2eded4a"><span class="section-number-5">2.4.3.2</span> Sort</h5>
<div class="outline-text-5" id="text-2-4-3-2">
<p>
We assume the worst case, during every time of the iteration, we have to percolate the root down to bottom. Percolating down each layer requires two operations: (1) comparing the children of the node and determine which child to be used to compare with the node; (2) compare the chosen child with the node and determine if we have to swap the two. As analyzed before, for an array of size N, we only need to sort the first \((N - 1)\) elements. For \(i\)th iteration, we moved \(i\) elements to sorted section, and there are \(N - i\) elements unsorted. These \(N - i\) elements composed the remaining heap. Now we have to percolate down the element at root position all the way to bottom (for the worst case). For a <b>FULL</b> complete binary tree with \(N - i\) elements, the relation between height \(h\) and number of elements are: \(2^{h + 1} - 1 = N - i\). Thus: \(h = \log(N - i + 1) - 1\). In reality, the complete binary tree may not be full, so the \(h\) value calculated by the above expression is smaller than the worst case. We can fix that by
\[h = 1 + \lfloor\log(N - i + 1) - 1\rfloor\ = \lfloor\log(N - i + 1)\rfloor\]
Thus, for \(i\)th iteration (i.e. after moving \(i\) elements to the sorted section), the number of operations involved to percolate root down to bottom (the worst case) is:\(\lfloor\log(N - i + 1)\rfloor\). Each percolating down contains 2 operations, so total operations are: \(2\lfloor\log(N - i + 1)\rfloor\).
</p>

<p>
\(i\) is from 1 to \(N - 1\). Thus we sum all the operations:
</p>
\begin{equation*}
\sum_{i = 1}^{N - 1} \lfloor2\log(N - i + 1)\rfloor
\end{equation*}
<p>
(To be continued&#x2026;)
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org70f87d5" class="outline-3">
<h3 id="org70f87d5"><span class="section-number-3">2.5</span> Merge Sort</h3>
<div class="outline-text-3" id="text-2-5">
</div>
<div id="outline-container-org3a6a086" class="outline-4">
<h4 id="org3a6a086"><span class="section-number-4">2.5.1</span> General Idea</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
The foundamental operation in this sorting algorithm is merging two sorted lists <code>A</code> and <code>B</code>. We use another chunk of memory (<code>C</code>) which has the size of <code>A.size() + B.size()</code>. And we have three iterators (<code>a</code>, <code>b</code> and <code>c</code>) pointing to the beginning of <code>A</code>, <code>B</code> and <code>C</code>, respectively. We now start to merge <code>A</code> and <code>B</code> into a single array <code>C</code>. For each element we insert to <code>C</code>, We compare the element pointed by the <code>a</code> and <code>b</code>, and pick the one that satisfy the order into where <code>c</code> is pointing at, then we increment the iterator (which was pointing to the inserted element in <code>A</code> or <code>B</code>) and <code>c</code>, and begin next inserting. If <code>a</code> or <code>b</code> reaches the end, we inserting the remaining elements in the non-empty array into <code>c</code> in its original sequence. After these operations, we have obtained a sorted array <code>C</code>.
</p>

<p>
Merge sort is a fine example of using divide and conquer strategy (with recursive algorithm). For a given array, we can use merge sort to sort its first half, then its second half, then we merge it into one array and copy back to the original array. The problem is <i>divided</i> into smaller problems and solved recursively. The <i>conquering</i> phase consists of patching together the answers.
</p>
</div>
</div>
<div id="outline-container-org2c81953" class="outline-4">
<h4 id="org2c81953"><span class="section-number-4">2.5.2</span> Implementation</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
I'll implement the merge sort which accepts three parameters: two iterators that mark the range of the array to be sorted, and one function object that provides a routine to determine the relative order of elements in the array (with <code>operator()</code> defined). The merge sort function will sort the array marked in <code>[first, last)</code>. The header is as follows:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>template &lt;class RandomAccessIterator, class Compare&gt;
<span class="linenr">2: </span>void Sort::mergeSort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);
</pre>
</div>

<p>
During the sorting, we have to use an extra space to hold the temporary sorted array. If we declare an array in each recursive call of merge sort, it would be a huge cost, roughly \(\log{N}\) in total. Notice that, at any given moment, we only use one temporary array to hold the result (because we'll only proceed to sort next sub-array once we finished current one). This means we can declare an array just for this purpose and pass it into internal private implementation of merge sort. The above header then describes the public routine to be called from outside. Namely:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;class RandomAccessIterator, class Compare&gt;
<span class="linenr"> 2: </span>void Sort::mergeSort(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
<span class="linenr"> 3: </span>  //base case: only one element in the array
<span class="linenr"> 4: </span>  if (first + 1 == last)
<span class="linenr"> 5: </span>    return;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  //as long as element number &gt;= 2, we need to sort
<span class="linenr"> 8: </span>  typename std::vector&lt;typename std::remove_reference&lt;decltype(*first)&gt;::type&gt; sorted_array(last - first);// this vector will be used to hold intermediate merged array for all recursively called function 
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>  //call private version of mergeSort to finish the work 
<span class="linenr">11: </span>  mergeSort(first, last, comp, sorted_array);
<span class="linenr">12: </span>
<span class="linenr">13: </span>}
<span class="linenr">14: </span>
</pre>
</div>
<p>
By the way, the above code shows how to use a generic iterator to create a vector that can hold the same type as <code>*iterator</code>.
</p>

<p>
The base case for merge sort recursive function is <code>first + 1 == last</code>. This means the passed in array has only one element, so it is "naturally" sorted. In this case, there is nothing to be done, just return.
</p>

<p>
We devide the array into two parts:
</p>
<ul class="org-ul">
<li><code>[first, first + (last - first) / 2)</code></li>
<li><code>[first + (last - first) / 2, last)</code></li>
</ul>
<p>
Then, we call merge sort to sort these two parts, then we merge them together (using the passed in array as the temporary storage space).
</p>

<p>
The code for the internal private version of merge sort is as follows:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;class RandomAccessIterator, class Compare, class Element&gt;
<span class="linenr"> 2: </span>void Sort::mergeSort(RandomAccessIterator first, RandomAccessIterator last, Compare comp, std::vector&lt;Element&gt;&amp; sorted_array) {
<span class="linenr"> 3: </span>  // base case 
<span class="linenr"> 4: </span>  if (first + 1 == last)
<span class="linenr"> 5: </span>    return;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  // calculate the size of the array
<span class="linenr"> 8: </span>  int size = last - first;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>  // recursively call itself to sort the first half 
<span class="linenr">11: </span>  mergeSort(first, first + size / 2, comp, sorted_array);
<span class="linenr">12: </span>
<span class="linenr">13: </span>  // recursively call itself to sort the second half 
<span class="linenr">14: </span>  mergeSort(first + size / 2, last, comp, sorted_array);
<span class="linenr">15: </span>
<span class="linenr">16: </span>  // merge the sorted sub-array 
<span class="linenr">17: </span>  auto itr_1 = first; // begin of sub-array_1
<span class="linenr">18: </span>  auto itr_2 = first + size / 2; // begin of sub-array_2
<span class="linenr">19: </span>  auto itr_array = sorted_array.begin(); // begin of temporary array
<span class="linenr">20: </span>
<span class="linenr">21: </span>  while (itr_1 != first + size / 2 &amp;&amp; itr_2 != last) {
<span class="linenr">22: </span>    if (comp(*itr_1, *itr_2))
<span class="linenr">23: </span>      *(itr_array++) = *(itr_1++);
<span class="linenr">24: </span>
<span class="linenr">25: </span>    else 
<span class="linenr">26: </span>      *(itr_array++) = *(itr_2++);    
<span class="linenr">27: </span>  }
<span class="linenr">28: </span>
<span class="linenr">29: </span>  // after the while loop, one itr reached end
<span class="linenr">30: </span>  // dump remaining sorted element into temporary container 
<span class="linenr">31: </span>  if (itr_1 == first + size / 2)
<span class="linenr">32: </span>    while (itr_2 != last)
<span class="linenr">33: </span>      *(itr_array++) = *(itr_2++);
<span class="linenr">34: </span>
<span class="linenr">35: </span>  else
<span class="linenr">36: </span>    while (itr_1 != first + size / 2)
<span class="linenr">37: </span>      *(itr_array++) = *(itr_1++);
<span class="linenr">38: </span>
<span class="linenr">39: </span>  // copy back sorted array
<span class="linenr">40: </span>  for (itr_1 = first, itr_array = sorted_array.begin(); itr_1 != last; ) {
<span class="linenr">41: </span>    *(itr_1++) = *(itr_array++);
<span class="linenr">42: </span>  }
<span class="linenr">43: </span>}
<span class="linenr">44: </span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgcf6ddbc" class="outline-3">
<h3 id="orgcf6ddbc"><span class="section-number-3">2.6</span> Quick Sort</h3>
<div class="outline-text-3" id="text-2-6">
</div>
<div id="outline-container-org390386c" class="outline-4">
<h4 id="org390386c"><span class="section-number-4">2.6.1</span> General Idea</h4>
<div class="outline-text-4" id="text-2-6-1">
<p>
Average running time: \(O(N\log{N})\).
</p>

<p>
Worst-case performance: \(O(N^2)\).
</p>

<p>
Quick sort uses same strategy as merge sort: divide and conquer recursive algorithm. The general idea is this (assume we want sort the array in increasing order). For a given input array, we pick one item in the array, named as <code>pivot</code>. We divide the array into three parts:
</p>
<ul class="org-ul">
<li>subarray <code>s1</code>, which contains all elements that are smaller than <code>pivot</code></li>
<li>the <code>pivot</code></li>
<li>subarray <code>s2</code>, which contains all elements that are larger than <code>pivot</code></li>
</ul>
<p>
The problem has been divided into two sub-problems: sort <code>s1</code> and <code>s2</code>. So, we call quick sort again to deal with <code>s1</code> and <code>s2</code>. After <code>s1</code> and <code>s2</code> are sorted, the whole array has been sorted.
</p>

<p>
The process of dividing the array according to <code>pivot</code> is called <b>partition</b>. During the partition, we may encounter some elements that are equal with <code>pivot</code>. How to partition these elements remained an implementation issue. Intuitively, we would hope that about half of these duplicated elements go into <code>s1</code> and the other half go into <code>s2</code>, so the two sub-arrays are somewhat "balanced".
</p>

<p>
Two differences between quick sort and merge sort are:
</p>
<ol class="org-ol">
<li>quick sort divide the array by pivot value, while merge sort divide the array purely by the middle point.</li>
<li>quick sort doesn't need extra space to <b>merge</b> the sorted subarray into final sorted array, sorting is done in place, while merge sort needs.</li>
</ol>

<p>
The details of how we pick the <code>pivot</code> and how we partition the array can greatly influence the performance of quick sort. There are many ways to do it, in this section, a widely accepted method will be explored. As before, we'll use sorting in increasing order as an example to illustrate.
</p>
</div>
</div>
<div id="outline-container-org8da50cb" class="outline-4">
<h4 id="org8da50cb"><span class="section-number-4">2.6.2</span> Picking the Pivot</h4>
<div class="outline-text-4" id="text-2-6-2">
<p>
For a given array, we find the median of the following three elements:
</p>
<ol class="org-ol">
<li>the first element in array</li>
<li>the center element in array</li>
<li>the last element in array</li>
</ol>
</div>
</div>
<div id="outline-container-orgb679696" class="outline-4">
<h4 id="orgb679696"><span class="section-number-4">2.6.3</span> Partition Strategy</h4>
<div class="outline-text-4" id="text-2-6-3">
<p>
After finding the <code>pivot</code> element, we use following steps to partition the array.
</p>
<ol class="org-ol">
<li>get the pivot element out of the way by swapping it with the last element.</li>
<li>define two iterators <code>i</code> and <code>j</code>. <code>i</code> will be pointing to the first element in the array. <code>j</code> will be pointing to the next-to-last element (i.e. the first element before the <code>pivot</code>). The idea is to put elements that are smaller than the <code>pivot</code> at the front of the array, and elements that are bigger than the <code>pivot</code> at the back of the array.</li>
<li><p>
<code>i</code> start to move toward the end, <code>j</code> start to move toward the beginning. <code>i</code> and <code>j</code> kept moving until they encounter elements that are not supposed to be there&#x2014;i.e. <code>i</code> has met element that is bigger than <code>pivot</code>, <code>j</code> has met element that is smaller than <code>pivot</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">while (*i &lt; pivot)
  ++i;
while (*j &gt; pivot)
  ++j;
</pre>
</div>
<p>
After the above loop, both <code>i</code> and <code>j</code> are pointing to an element. At this moment, if <code>i</code> is still before <code>j</code>, we should swap the elements pointed by <code>i</code> and <code>j</code>, and increment <code>i</code>, <code>j</code>:
</p>
<div class="org-src-container">
<pre class="src src-c++">if (i &lt; j)
  std::swap(*(i++), *(j--));
</pre>
</div></li>
<li>we keep repeating step 3 until <code>i</code> and <code>j</code> crossed each other, i.e. <code>i &gt;= j</code>.</li>
<li><p>
after <code>i</code> and <code>j</code> crossed each other, we swap <code>pivot</code> and <code>*i</code>. Pay attention that now <code>i</code> is pointing to the first element that is larger than <code>pivot</code>. After we do this swapping, the array is in following structure:
</p>

<p>
<code>----- pivot ++++++</code>
</p>

<p>
where <code>-</code> represents elements that are smaller than <code>pivot</code>; <code>+</code> represents elements that are greater than <code>pivot</code>.
</p></li>
</ol>
</div>
</div>
<div id="outline-container-org1736aad" class="outline-4">
<h4 id="org1736aad"><span class="section-number-4">2.6.4</span> Small Arrays</h4>
<div class="outline-text-4" id="text-2-6-4">
<p>
For very small arrays, quick sort does not perform as well as insertion sort. Furthermore, because quick sort is recursive, these cases will occur eventually, even if you are sorting a big array. A common solution is not to use quick sort recursively for small arrays, but instead use a sorting algorithm that is efficient for small arrays. A good cutoff is <code>N == 10</code>.
</p>
</div>
</div>
<div id="outline-container-org78e513d" class="outline-4">
<h4 id="org78e513d"><span class="section-number-4">2.6.5</span> Implementations</h4>
<div class="outline-text-4" id="text-2-6-5">
<p>
Implementation of pivot() function:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;class RandomAccessIterator, class Compare&gt;
<span class="linenr"> 2: </span>void Sort::pivot(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
<span class="linenr"> 3: </span>  auto center = first + (last - first) / 2;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  //rearrange elements at first, center and (last - 1) in order
<span class="linenr"> 6: </span>  if (!comp(*first, *center))
<span class="linenr"> 7: </span>    std::swap(*first, *center);
<span class="linenr"> 8: </span>  if (!comp(*first, *(last - 1)))
<span class="linenr"> 9: </span>    std::swap(*first, *(last - 1));
<span class="linenr">10: </span>  if (!comp(*center, *(last - 1)))
<span class="linenr">11: </span>    std::swap(*center, *(last - 1));
<span class="linenr">12: </span>
<span class="linenr">13: </span>  //after above step, center is pointing to median of the three position
<span class="linenr">14: </span>  //move pivot to the slot before the last slot
<span class="linenr">15: </span>  //this is because pivot and the last slot is already in order
<span class="linenr">16: </span>  std::swap(*center, *(last - 2));  
<span class="linenr">17: </span>}
</pre>
</div>

<p>
Implementation of quick sort:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr"> 1: </span>template &lt;class RandomAccessIterator, class Compare&gt;
<span class="linenr"> 2: </span>void Sort::quickSort(RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
<span class="linenr"> 3: </span>  //base case: small array
<span class="linenr"> 4: </span>  if (last - first &lt; 11) {
<span class="linenr"> 5: </span>    insertionSort(first, last, comp);
<span class="linenr"> 6: </span>    return;
<span class="linenr"> 7: </span>  }
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>  //call a private routine to select pivot and move it to the slot before last 
<span class="linenr">11: </span>  //this is to prepare for partition
<span class="linenr">12: </span>  pivot(first, last, comp);
<span class="linenr">13: </span>
<span class="linenr">14: </span>  //begin partition
<span class="linenr">15: </span>  //notice that, *(last - 2) is the pivot value
<span class="linenr">16: </span>  auto i = first;
<span class="linenr">17: </span>  auto j = last - 3;
<span class="linenr">18: </span>
<span class="linenr">19: </span>  while (i &lt; j) {//begin moving i and j
<span class="linenr">20: </span>    while (comp(*i, *(last - 2)))
<span class="linenr">21: </span>      ++i;
<span class="linenr">22: </span>    while (!comp(*j, *(last - 2)))
<span class="linenr">23: </span>      --j;
<span class="linenr">24: </span>
<span class="linenr">25: </span>    if (i &lt; j) //if i j not crossed yet
<span class="linenr">26: </span>      std::swap(*(i++), *(j--));
<span class="linenr">27: </span>  }
<span class="linenr">28: </span>
<span class="linenr">29: </span>  //after the above loop, i and j crossed
<span class="linenr">30: </span>  //swap *i and pivot to finish partition
<span class="linenr">31: </span>  std::swap(*i, *(last - 2));
<span class="linenr">32: </span>
<span class="linenr">33: </span>  //partition finished, now the loop has the structure:
<span class="linenr">34: </span>  //----- pivot ++++++ or +++++ pivot ------
<span class="linenr">35: </span>  //next step is to call quick sort recursively to sort two sub-arrays
<span class="linenr">36: </span>  quickSort(first, i, comp);
<span class="linenr">37: </span>  quickSort(i + 1, last, comp); 
<span class="linenr">38: </span>}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org82eaa73" class="outline-2">
<h2 id="org82eaa73"><span class="section-number-2">3</span> Gimmicks</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org8c723ba" class="outline-3">
<h3 id="org8c723ba"><span class="section-number-3">3.1</span> C++ Related</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-orgfb3bd67" class="outline-4">
<h4 id="orgfb3bd67"><span class="section-number-4">3.1.1</span> Create a Vector Using its Iterator</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
Demand first encountered: when trying to write iterator implementation of merge sort. I have to define a generic vector, using its iterator. After some search on internet, I found the following tricks to do this:
</p>
<div class="org-src-container">
<pre class="src src-c++"><span class="linenr">1: </span>std::vector&lt;int&gt; v1;
<span class="linenr">2: </span>auto itr = v1.begin();
<span class="linenr">3: </span>std::vector&lt;typename std::remove_reference&lt;decltype(*itr)&gt;::type&gt; v2;
<span class="linenr">4: </span>// after the above declaration, v2 is declared as a vector holding integer type
</pre>
</div>

<p>
Reference:
<a href="https://stackoverflow.com/questions/45217180/initializing-a-vector-of-auto-unknown-type-inside-a-template-function-in-c">Create a vector using its iterator</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-05-07 Tue 10:27</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
