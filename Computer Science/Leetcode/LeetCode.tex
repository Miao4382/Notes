% Created 2019-05-23 Thu 09:16
% Intended LaTeX compiler: pdflatex
\documentclass[12pt]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[margin=1in] {geometry}
\usepackage{parskip}
\setlength\parindent{0pt}
\linespread {1.0}
\setcounter{tocdepth} {3}
\setcounter{secnumdepth} {3}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.2 (Org mode 9.2.3)}, 
 pdflang={English}}
\begin{document}

\tableofcontents


\part{Arrays}
\label{sec:orga679adf}
\chapter{1. Two Sum}
\label{sec:org9144930}
\section{Problem Statement}
\label{sec:orgb9a6c43}
\href{https://leetcode.com/problems/two-sum/}{Link}
\section{Analysis}
\label{sec:orgd807159}

\section{Solution}
\label{sec:orgf82f2a7}
\subsection{C++}
\label{sec:orge3fea3d}
\subsubsection{\(O(N^2)\) Time (35.43\%)}
\label{sec:org308b6d0}
Idea: traverse the vector. For each encountered value, calculate the corresponding value it needs to add up to the target value. And then traverse the vector to look for this value.

The time complexity is \(O(N^2)\), because for each value in the vector, you'll go through the vector and search its corresponding part so they add up to the target. This is linear searching, which has \(O(N)\) complexity.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  vector<int> twoSum(vector<int>& nums, int target) {
    for (auto i = nums.begin(); i != nums.end(); ++i) {
      int other_part = target - (*i);
      auto itr = find(nums.begin(), nums.end(), other_part);

      if (itr != nums.end() && itr != i)
	return {static_cast<int>(i - nums.begin()), static_cast<int>(itr - nums.begin())};
    }

    return {0, 1};
  }
};
\end{minted}
\subsubsection{\(O(N\log{N})\) Time (99.24\%)}
\label{sec:org6291374}
Idea: the searching part is optimized. First we sort the vector. In order to keep the original relative order of each element, we sort a vector of iterators that referring each element in the original vector \texttt{nums}. Then, we can use this sorted vector to perform binary search, whose time complexity is \(\log{N}\). The total time complexity is reduced to \(O(N\log{N})\).

I made some bugs when writting this code, because I didn't realize the following assumption:
\begin{itemize}
\item duplicates allowed
\item each input would have \textbf{\emph{exactly}} one solution
\end{itemize}

Code:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  /*Notes: 
    The compare object used to sort vector of iterators
  */
  struct Compare {
    bool operator()(vector<int>::iterator a, vector<int>::iterator b) {
      return (*a < *b);      
    }

  };

  /*Notes: 
    A binary search to find target value in a vector of iterators;
    if found: return the index value of that iterator 
    if not found: return -1
  */
  int findTarget(int target, const vector<vector<int>::iterator>& itr_vector, const vector<int>::iterator& current_itr) {
    int start_index = 0;
    int end_index = itr_vector.size() - 1;
    int middle;
    int result = -1;

    while (start_index <= end_index) {
      // update middle 
      middle = (start_index + end_index) / 2;
      // check value 
      if (*itr_vector[middle] == target) {
	if (itr_vector[middle] == current_itr) {
	  start_index += 1;
	  end_index += 1;
	  continue;
	}

	result = middle;
	break;
      }

      else if (*itr_vector[middle] > target) {
	end_index = middle - 1;
	continue;
      }

      else if (*itr_vector[middle] < target) {
	start_index = middle + 1;
	continue;
      }

    }

    return result;
  }


  vector<int> twoSum(vector<int>& nums, int target) {
    // create a vector of iterators
    vector<vector<int>::iterator> itr_vector;
    for (auto i = nums.begin(); i != nums.end(); ++i)
      itr_vector.push_back(i);

    // sort the vector of iterators, so the values these iterators referred to 
    // are in ascending order
    sort(itr_vector.begin(), itr_vector.end(), Compare());

    // go over nums, and find the pair
    for (auto i = nums.begin(); i != nums.end() - 1; ++i) {
      int other_part = target - (*i);
      int other_part_index = findTarget(other_part, itr_vector, i);

      if (other_part_index != -1) // found
	return {static_cast<int>(i - nums.begin()), static_cast<int>(itr_vector[other_part_index] - nums.begin())};
    }

    // for syntax
    return {0, 1};

  }
};
\end{minted}
\chapter{461. Hamming Distance \label{org7e98d91}}
\label{sec:org7805d5b}
\section{Problem Statement}
\label{sec:org7f5e807}
\href{https://leetcode.com/problems/hamming-distance/}{Link}
\section{Analysis}
\label{sec:orge462353}
To compare two numbers bitwisely, we may need the fact that a number mod 2 is equal to the last digit of its binary form. For example:
\begin{verbatim}
x = 1 (0 0 0 1)
y = 4 (0 1 0 0)
x % 2 = 1
y % 2 = 0
\end{verbatim}
\section{Solution}
\label{sec:orge5ebf3c}
\subsection{C++}
\label{sec:org5984e69}
\subsubsection{Time(14.63\%)}
\label{sec:orgfd45699}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int hammingDistance(int x, int y) {
    int result = 0;

    while (x != 0 || y != 0) {
      if (x % 2 != y % 2)
	result++;

      x = x >> 1;
      y = y >> 1;
    }

    return result;
  }
};
\end{minted}
\subsubsection{Time(94.5\%)}
\label{sec:orgd8d05f0}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int hammingDistance(int x, int y) {
    int result = 0;
    x ^= y;

    while (x) {
      if (x % 2)
	result++;
      x = x >> 1;
    }

    return result;
  }
};
\end{minted}
\subsubsection{Questions}
\label{sec:orgc549374}
Why the second solution is faster than the previous one?
\begin{itemize}
\item Bitwise XOR used.
\end{itemize}
\subsection{Python}
\label{sec:orgf706170}
\subsubsection{Faster than 97.37\%}
\label{sec:orgb658cbe}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
	result = 0
	while x or y:
	    if x % 2 != y % 2:
		result += 1
	    x = x >> 1
	    y = y >> 1
	return result
\end{minted}
However, this algorithm is exactly the same as C++'s first version. Why such huge speed variance?
\chapter{477. Total Hamming Distance}
\label{sec:org9cf8d0e}
\section{Problem Statement}
\label{sec:org929c7bb}
\href{https://leetcode.com/problems/total-hamming-distance/}{Link}
\section{Analysis}
\label{sec:org8197482}
This problem is similar with P461, but you can't direcly solve it using that idea (see the first solution). The size of the input is large:
\begin{itemize}
\item Elements of the given array are in the range of \(0\) to \(10^9\)
\item Length of the array will not exceed \(10^4\)
\end{itemize}

\subsection{First Attempt (too slow)}
\label{sec:orgcee87f0}
My first attempt is just go over all the combinations in the input array: \((x_i, x_j)\) and call the function that calculate the hamming distance of two integers (\hyperref[org7e98d91]{P461}), the code is shown in solution section. However, this approach is too slow to pass the test.

The time complexity of the function that calculates the hamming distance of two integers is not huge, just \(O(1)\). The real time consuming part is the combination. It is simply:
\[
{N \choose 2} = \frac{N(N-1)}{2} \sim O(N^2)
\]
Inside these combinations, we included many bit-pairs that do not contribute to the total Hamming distance count, for example, the combination of number 91 and 117 is:
\begin{verbatim}
---------------
bit#: 1234 5678
---------------
91:   0101 1011
117:  0111 0101
---------------
\end{verbatim}
The bit at 1, 2, 4, 8 are not contributing to the total Hamming distance count, but we still include it and spend time verifying. This flaw can be solved in the grouping idea.

\subsection{Grouping}
\label{sec:org4c2485d}
\href{https://leetcode.com/problems/total-hamming-distance/discuss/96250/C++-O(n)-runtime-O(1)-space}{Reference}

The idea of grouping is we count the total hamming distance as a whole. Specifically, at any giving time, we devide the array into two groups \(G_0, G_1\). The rule of grouping is:
\begin{itemize}
\item a number \(n\) that \(n \% 2 = 0\), goes to \(G_0\)
\item a number \(n\) that \(n \% 2 = 1\), goes to \(G_1\)
\end{itemize}
The result of \(n\%2\) will give you the least significant bit, or the last bit of an integer in binary form. By the definition of Hamming distance, we know that any combinations that contains number pairs only from \(G_0\) or only from \(G_1\) will not contribute to the total Hamming distance count (just for this grouping round, which only compares the least significant bit of those numbers). On the other hand, any combination that contains one number from \(G_0\) and one number from \(G_1\) will contribute 1 to the total Hamming distance. So, for this round, we only have to count the combination of such case, which is simply:
\[
N_{G_0} \times N_{G_1}
\]
Then, we trim the current least significant bit and re-group the numbers into new \(G_0\) and \(G_1\). This is because at each bit the numbers are different. We do this until \textbf{ALL} numbers are \textbf{ZERO}. For example, if at one round, there are no numbers in \(G_1\), all numbers are in \(G_0\), then although the contribution to total Hamming distance of this round is zero, we have to move on to trim the least significant bit and re-group the numbers.
\section{Solution}
\label{sec:org55db47b}
\subsection{C++}
\label{sec:org2c90b5e}
\subsubsection{Not Accepted (too slow)}
\label{sec:org7c5744c}
This algorithm is too slow.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int hammingDistance(const int& x, const int& y) {
    int result = 0;
    int a = x ^ y;

    while (a != 0) {
      if (a % 2)
	result++;
      a = a >> 1;
    }

    return result;
  }  

  int totalHammingDistance(vector<int>& nums) {
    int count = 0;
    for (int i = 0; i < nums.size() - 1; ++i) {
      for (int j = i + 1; j < nums.size(); ++j)
	count += hammingDistance(nums[i], nums[j]);
    }
    return count;
  }
};
\end{minted}
\subsubsection{Time (6.59\%) Space (5.13\%)}
\label{sec:org7abbbdb}
This is the first version after I read and apply the idea of grouping numbers with different Least Significant bit. Although it is still slow, it is accepted\ldots{}..
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int totalHammingDistance(vector<int>& nums) {
    vector<int> LSB_ones;
    vector<int> LSB_zeros;
    int count = 0;
    int non_zero_count = 1; // loop continue until no non-zero num in nums

    while (non_zero_count) {
      // clear temp container, reset non-zero count
      LSB_ones.clear();
      LSB_zeros.clear();
      non_zero_count = 0;

      // collect number, divide into two groups
      for (auto& i : nums) {
	if (i % 2 == 0)
	  LSB_zeros.push_back(i);
	else 
	  LSB_ones.push_back(i);

	// update i and non_zero_count
	i = i >> 1;
	if (i)
	  non_zero_count++;
      }

      // update count 
      count += LSB_ones.size() * LSB_zeros.size();
    }

    return count;
  }
};
\end{minted}
\section{todos [0/4]}
\label{sec:orge869441}
\begin{itemize}
\item[{$\square$}] Write the analysis of grouping idea and my code
\item[{$\square$}] Read code in reference of grouping idea, make notes
\item[{$\square$}] Check other possible solution and make future plan
\item[{$\square$}] Try to generalize this problem
\end{itemize}
\chapter{771. Jewels and Stones}
\label{sec:org8f369e8}
\section{Problem Statement}
\label{sec:org2e522a7}
\href{https://leetcode.com/problems/jewels-and-stones/}{Link}
\section{Analysis}
\label{sec:org9d8f975}
\section{Solution}
\label{sec:orgacdf539}
\subsection{C++}
\label{sec:org0b30f60}
\subsubsection{\(N^2\) Time (96.35\%) Space (79.64\%)}
\label{sec:org5ecee0f}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int numJewelsInStones(string J, string S) {
    int numJewl = 0;
    for (auto s : S)
      if (isJewels(s, J))
	numJewl++;
    return numJewl;
  }

  bool isJewels(char s, string J) {
    for (auto j : J)
      if (s == j)
	return true;

    return false;
  }
};
\end{minted}
\part{Trees}
\label{sec:orgad9797b}
\chapter{104. Maximum Depth of Binary Tree}
\label{sec:org046c395}
\section{Problem Statement}
\label{sec:org599a3cc}
\href{https://leetcode.com/problems/maximum-depth-of-binary-tree/}{Link}
\section{Analysis}
\label{sec:orgc352fa7}
\subsection{Recursion}
\label{sec:orgada5fcc}
A node's maximum depth, is the larger maximum depth of its left and right subtree plus one. Base case: if a node is nullptr, maximum depth is zero.
\section{Solution}
\label{sec:orgb2ad9d8}
\subsection{C++}
\label{sec:orge890e5c}
\subsubsection{Recursion. Time (88.44\%) Space (91.28\%)}
\label{sec:org52bb576}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  int maxDepth(TreeNode* root) {
    // base case 
    if (root == nullptr)
      return 0;

    int left_depth = maxDepth(root->left);
    int right_depth = maxDepth(root->right);

    return (left_depth >= right_depth ? left_depth + 1 : right_depth + 1);
  }
};
\end{minted}
\section{todos [/]}
\label{sec:org45e577f}
\begin{itemize}
\item[{$\square$}] read about the discussion page for more methods and ideas
\end{itemize}

\chapter{617. Merge Two Binary Trees}
\label{sec:org852d889}
\section{Problem Statement}
\label{sec:org1d743e2}
\href{https://leetcode.com/problems/merge-two-binary-trees/}{Link}
\section{Analysis}
\label{sec:org423c79e}
\subsection{Approach \#1 Recursive Method}
\label{sec:org0e393f2}
Use recursiion to solve this problem.
\subsection{Approach \#2 Iterative Method}
\label{sec:orgbe2dd8d}

\section{Solution}
\label{sec:org7bfa85c}
\subsection{C++}
\label{sec:org96d87c3}
\subsubsection{Recursion Time (97.09\%) Space(37.01\%)}
\label{sec:org24c0f49}
Recursion.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
    if (t1 == nullptr)
      return t2;
    else if (t2 == nullptr)
      return t1;
    else {
      TreeNode* node = new TreeNode(t1->val + t2->val);
      node->left = mergeTrees(t1->left, t2->left);
      node->right = mergeTrees(t1->right, t2->right);
      return node;
    }
  }
};
\end{minted}
\subsubsection{Iterative}
\label{sec:org49bce97}
\section{todos [/]}
\label{sec:org1324ff7}
\begin{itemize}
\item[{$\square$}] read the other solution (iterate the tree using stack), and understand it
\item[{$\square$}] write code based on the other solution
\end{itemize}
\end{document}
