% Created 2019-07-07 Sun 11:30
% Intended LaTeX compiler: pdflatex
\documentclass[12pt]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{minted}
\usepackage[margin=1in] {geometry}
\usepackage{parskip}
\setlength\parindent{0pt}
\linespread {1.0}
\setcounter{tocdepth} {3}
\setcounter{secnumdepth} {3}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.2 (Org mode 9.2.3)}, 
 pdflang={English}}
\begin{document}

\tableofcontents


\part{Arrays}
\label{sec:org961a0a8}
\chapter{1. Two Sum}
\label{sec:org995b05b}
\section{Problem Statement}
\label{sec:org6b7f63f}
\href{https://leetcode.com/problems/two-sum/}{Link}
\section{Analysis}
\label{sec:org49be516}
\subsection{\(O(N^2)\) method}
\label{sec:orge41b2c0}
Each input would have exactly one solution, and no same element can be used twice. We can go through the array. For each element we encountered (\texttt{nums[i]}), we calculate the counter part (the number that is needed so \texttt{nums[i] + counter\_part = target}): simply: \texttt{target - nums[i]}. Then we go through the rest of the array to find out if such element exist. We go from \texttt{i + 1} to the end. We don't have to go from the beginning because if there is such an element, we would find it earlier. If no such element found, we continue to the next element, calculate its counter part and search again.

Strictly speaking, the time required will be smaller than \(O(N^2)\) algorithm. The "inner" iteration's size is not N, its size is decreasing.

\section{Solution}
\label{sec:orgf5cdc94}
\subsection{C++}
\label{sec:org5411238}
\subsubsection{\(O(N^2)\) Time (35.43\%)}
\label{sec:org5d1654e}
Idea: traverse the vector. For each encountered value, calculate the corresponding value it needs to add up to the target value. And then traverse the vector to look for this value.

The time complexity is \(O(N^2)\), because for each value in the vector, you'll go through the vector and search its corresponding part so they add up to the target. This is linear searching, which has \(O(N)\) complexity.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  vector<int> twoSum(vector<int>& nums, int target) {
    for (auto i = nums.begin(); i != nums.end(); ++i) {
      int other_part = target - (*i);
      auto itr = find(nums.begin(), nums.end(), other_part);

      if (itr != nums.end() && itr != i)
	return {static_cast<int>(i - nums.begin()), static_cast<int>(itr - nums.begin())};
    }

    return {0, 1};
  }
};
\end{minted}
\subsubsection{\(O(N^2)\) modified}
\label{sec:org6b7617c}
This is modified implementation. Although the algorithm is the same as the first \(O(N^2)\) solution. This solution is much clearer.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
/*test cases: 
[2,7,11,15]
9

[2,3]
5

[1,113,2,7,9,23,145,11,15]
154

[2,7,11,15,1,8,13]
3
*/


class Solution {
public:
  vector<int> twoSum(vector<int>& nums, int target) {
    int index_1 = -1;
    int index_2 = -1;

    for (int i = 0; i < nums.size(); i++) {
      int other_part = target - nums[i];

      for (int j = i + 1; j < nums.size(); j++) {
	if (nums[j] == other_part) {
	  index_1 = i;
	  index_2 = j;
	  break;
	}
      }

      if (index_1 != -1)
	break;
    }

    return {index_1, index_2};
  }
};
\end{minted}
\subsubsection{\(O(N\log{N})\) Time (99.24\%)}
\label{sec:org0e47730}
Idea: the searching part is optimized. First we sort the vector. In order to keep the original relative order of each element, we sort a vector of iterators that referring each element in the original vector \texttt{nums}. Then, we can use this sorted vector to perform binary search, whose time complexity is \(\log{N}\). The total time complexity is reduced to \(O(N\log{N})\).

I made some bugs when writting this code, because I didn't realize the following assumption:
\begin{itemize}
\item duplicates allowed
\item each input would have \textbf{\emph{exactly}} one solution
\end{itemize}

Code:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  /*Notes: 
    The compare object used to sort vector of iterators
  */
  struct Compare {
    bool operator()(vector<int>::iterator a, vector<int>::iterator b) {
      return (*a < *b);      
    }

  };

  /*Notes: 
    A binary search to find target value in a vector of iterators;
    if found: return the index value of that iterator 
    if not found: return -1
  */
  int findTarget(int target, const vector<vector<int>::iterator>& itr_vector, const vector<int>::iterator& current_itr) {
    int start_index = 0;
    int end_index = itr_vector.size() - 1;
    int middle;
    int result = -1;

    while (start_index <= end_index) {
      // update middle 
      middle = (start_index + end_index) / 2;
      // check value 
      if (*itr_vector[middle] == target) {
	if (itr_vector[middle] == current_itr) {
	  start_index += 1;
	  end_index += 1;
	  continue;
	}

	result = middle;
	break;
      }

      else if (*itr_vector[middle] > target) {
	end_index = middle - 1;
	continue;
      }

      else if (*itr_vector[middle] < target) {
	start_index = middle + 1;
	continue;
      }

    }

    return result;
  }


  vector<int> twoSum(vector<int>& nums, int target) {
    // create a vector of iterators
    vector<vector<int>::iterator> itr_vector;
    for (auto i = nums.begin(); i != nums.end(); ++i)
      itr_vector.push_back(i);

    // sort the vector of iterators, so the values these iterators referred to 
    // are in ascending order
    sort(itr_vector.begin(), itr_vector.end(), Compare());

    // go over nums, and find the pair
    for (auto i = nums.begin(); i != nums.end() - 1; ++i) {
      int other_part = target - (*i);
      int other_part_index = findTarget(other_part, itr_vector, i);

      if (other_part_index != -1) // found
	return {static_cast<int>(i - nums.begin()), static_cast<int>(itr_vector[other_part_index] - nums.begin())};
    }

    // for syntax
    return {0, 1};

  }
};
\end{minted}

\section{todos [1/5]}
\label{sec:orgee18b6f}
\begin{itemize}
\item[{$\boxtimes$}] try sort directly method (using a copy array)
\item[{$\square$}] write down my own analysis: sort copy array and iter\_array
\item[{$\square$}] check the solution and understands, implement each idea
\item[{$\square$}] write the analysis of each idea
\item[{$\square$}] generalize this problem
\end{itemize}
\chapter{136. Single Number}
\label{sec:orgbb5ed07}
\section{Problem Statement}
\label{sec:orgb05e321}
\href{https://leetcode.com/problems/single-number/}{Link
}
\section{Analysis}
\label{sec:orge2b03c6}
\subsection{Use Unordered-set}
\label{sec:orgb8a8d90}
\section{Solution}
\label{sec:org07f331f}
\subsection{C++}
\label{sec:org5e7e5f5}
\subsubsection{Unordered-set. time (16.06\%) space (15.74\%)}
\label{sec:orgcbf5c39}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int singleNumber(vector<int>& nums) {
    unordered_set<int> unique_num;

    for (auto num : nums) {
      auto itr = unique_num.find(num);

      if (itr == unique_num.end())
	unique_num.insert(num);
      else
	unique_num.erase(itr);
    }

    return *unique_num.begin();
  }
};
\end{minted}
\section{todos [0/4]}
\label{sec:orgdae47a0}
\begin{itemize}
\item[{$\square$}] write your solution step (in analysis part), analysis time and space complexity
\item[{$\square$}] think about possible improvements
\item[{$\square$}] read solution, do additional work (internalize it and write analysis and code)
\item[{$\square$}] read discussion, do additional work (internalize it and write analysis and code)
\end{itemize}
\chapter{169. Majority Element}
\label{sec:org46dd921}
\section{Problem Statement}
\label{sec:org7105ee2}
\href{https://leetcode.com/problems/majority-element/}{Link}
\section{Analysis}
\label{sec:org0108d38}
\subsection{\texttt{unordered\_map}}
\label{sec:orgba0db61}
This is a problem that record the frequency of the element. I use the number as key and the appearing times as value, build an unordered\_map that store this information. As long as a number's appearing times is more than \texttt{size / 2}, it will be the majority element.
\section{Solutions}
\label{sec:orgaf4ce93}
\subsection{C++}
\label{sec:org9e5ddee}
\subsubsection{\texttt{unordered\_map} (59\%, 42\%)}
\label{sec:org4d59367}
Not very fast.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int majorityElement(vector<int>& nums) {
    unordered_map<int, int> frequency_count;

    for (auto num : nums) {
      if (frequency_count.find(num) != frequency_count.end()) {
	frequency_count[num] += 1;
	if (frequency_count[num] > nums.size() / 2)
	  return num;
      }

      else
	frequency_count.insert(make_pair(num, 1));
    }

    return nums[0];
  }
};
\end{minted}
\section{todos [/]}
\label{sec:org2e7f12f}
\begin{itemize}
\item[{$\square$}] think about other solution (use about 30 min)
\item[{$\square$}] read discussion and contemplate other solution
\item[{$\square$}] generalize the problem
\end{itemize}
\chapter{283. Move Zeros}
\label{sec:org0b00978}
\section{Problem Statement}
\label{sec:org86b22e7}
\href{https://leetcode.com/problems/move-zeroes/}{Link}
\section{Analysis}
\label{sec:org3244492}
Make sure you know well the problem statement. For example, in this problem, there is no requirement for the zero element be kepted.
\section{Solution}
\label{sec:org3d04b60}
\subsection{C++}
\label{sec:org47d18d1}
\subsubsection{Use bubble sort idea. time (5\%) space (75\%)}
\label{sec:org287da92}
Too slow, time complexity is \(O(N^2)\).
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  void moveZeroes(vector<int>& nums) {
    bool swapped;

    // swap array    
    do {
      swapped = false;      

      for (auto iter = nums.begin(); iter != nums.end() - 1; ++iter) {
	if (*iter == 0) {
	  if (*(iter + 1) == 0)
	    continue;
	  swap(*iter, *(iter + 1));
	  swapped = true;
	}   
      }     
    } while (swapped);
  }
};
\end{minted}
\subsubsection{Use erase(), remove zeros. time (35\%) space (34\%)}
\label{sec:orgc487c27}
Still slow. Since the \texttt{erase()} function will reallocate each element after the deleted one. Worst case time complexity should be \(O(N^2)\).
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:

  void moveZeroes(vector<int>& nums) {
    int zero_count = 0;
    for (auto iter = nums.begin(); iter != nums.end(); ++iter)
      if (*iter == 0)
	zero_count++;

    if (zero_count == 0)
      return;

    auto iter = nums.begin();
    int zero_deleted = 0;

    while (zero_deleted < zero_count) {
      if (*iter == 0) {
	iter = nums.erase(iter);
	nums.push_back(0);
	zero_deleted++;
      }

      else
	++iter;       
    }
  }
};
\end{minted}
\section{todos [0/2]}
\label{sec:orgc5e291a}
\begin{itemize}
\item[{$\square$}] try to think another Solution
\item[{$\square$}] read the solution page and study
\end{itemize}
\chapter{442. Find All Duplicates in an Array\label{orgb2f1edb}}
\label{sec:orgbff3927}
\section{Problem Statement}
\label{sec:orgc09cc6f}
\href{https://leetcode.com/problems/find-all-duplicates-in-an-array/}{Link}
\section{Analysis}
\label{sec:org9d294da}
\subsection{Label Duplicate Number}
\label{sec:org4b58791}
Label the appearing frequency of each element, using the fact that \texttt{1 <= a[i] <= n}, where n is the size of array. Then count the number that appeared twice.
\section{Solution}
\label{sec:orgf2e31dd}
\subsection{C++}
\label{sec:org4575a6b}
\subsubsection{Label duplicate number (96\%, 16\%)}
\label{sec:org682dba4}
This one use an extra vector to hold the labeling information.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  vector<int> findDuplicates(vector<int>& nums) {
    vector<int> duplicate;
    vector<int> frequency_count(nums.size(), 0);

    for (int i = 0; i < nums.size(); i++) {
      frequency_count[nums[i] - 1]++;
    }

    for (int i = 0; i < frequency_count.size(); i++)
      if (frequency_count[i] > 1)
	duplicate.push_back(i + 1);

    return duplicate;
  }
};
\end{minted}

\section{todos [/]}
\label{sec:orge907b64}
\begin{itemize}
\item[{$\square$}] think about the way to use original vector to hold labeling information
\item[{$\square$}] read other solutions
\item[{$\square$}] generalize the problem
\end{itemize}
\chapter{448. Find All Numbers Disappeared in an Array}
\label{sec:orgbacefbe}
\section{Problem Statement}
\label{sec:orgde4502f}
\href{https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/}{Link}
\section{Analysis}
\label{sec:org1df177b}
\subsection{Label Appearance of Numbers}
\label{sec:org3c658f7}
This is similar with \hyperref[orgb2f1edb]{Problem 442}. Label the appearing frequency of each element, using the fact that \texttt{1 <= a[i] <= n}, where n is the size of array. Then count the number that appearing frequency is 0.

You can use either a new vector to hold the labeling information, or the original passed-in vector.

\subsection{Use Unordered-set}
\label{sec:org377d6ef}
Use an unordered-set to store all appeared number. Then traverse from 1 to N to find out if one number is in the set, if not, it is one disappearing number, push to result. This method's time complexity is \(O(N)\) on average, but \(O(N^2)\) for worst cases, due to the time complexity of \texttt{insert()} and \texttt{find()} in unordered-set.

\section{Solution}
\label{sec:org11c52b2}
\subsection{C++}
\label{sec:org1bd74b9}
\subsubsection{Label appearance of numbers (97\%, 15\%)}
\label{sec:org1c45a99}
Space can be optimized by using original passed-in vector.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  vector<int> findDisappearedNumbers(vector<int>& nums) {
    vector<int> appear_label(nums.size(), 0);
    vector<int> disappear;

    // label appeared number
    for (int i = 0; i < nums.size(); i++) {
      appear_label[nums[i] - 1] = 1;
    }

    // find out unlabelled number 
    for (int i = 0; i < appear_label.size(); ++i)
      if (appear_label[i] == 0)
	disappear.push_back(i + 1);

    return disappear;
  }
};
\end{minted}
\subsubsection{Use unordered-set (13\%, 7\%)}
\label{sec:org7944351}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  vector<int> findDisappearedNumbers(vector<int>& nums) {
    vector<int> disappear;
    unordered_set<int> appeared; // extra space used

    for (auto num : nums)  // total average O(N), worst: O(N^2)
      appeared.insert(num);  // average: O(1), worst: O(N)

    for (int i = 1; i <= nums.size(); ++i) {
      if (appeared.find(i) == appeared.end())  // find(), average: O(1), worst: O(N)
	disappear.push_back(i);
    }

    return disappear;
  }
};

// Total complexity: average: O(N), worst: O(N^2), still bound by O(N^2)
\end{minted}
\section{todos [/]}
\label{sec:org8197931}
\begin{itemize}
\item[{$\square$}] think about using the original vector to hold labeling information
\item[{$\square$}] read other solutions
\item[{$\square$}] generalize the problem
\end{itemize}
\chapter{461. Hamming Distance \label{orgf8b6eb9}}
\label{sec:org6b53c07}
\section{Problem Statement}
\label{sec:orga25014e}
\href{https://leetcode.com/problems/hamming-distance/}{Link}
\section{Analysis}
\label{sec:org37dff8e}
To compare two numbers bitwisely, we may need the fact that a number mod 2 is equal to the last digit of its binary form. For example:
\begin{verbatim}
x = 1 (0 0 0 1)
y = 4 (0 1 0 0)
x % 2 = 1
y % 2 = 0
\end{verbatim}
\section{Solution}
\label{sec:org15da427}
\subsection{C++}
\label{sec:orga5e433b}
\subsubsection{Time(14.63\%)}
\label{sec:org3b8a203}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int hammingDistance(int x, int y) {
    int result = 0;

    while (x != 0 || y != 0) {
      if (x % 2 != y % 2)
	result++;

      x = x >> 1;
      y = y >> 1;
    }

    return result;
  }
};
\end{minted}
\subsubsection{Time(94.5\%)}
\label{sec:org5664740}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int hammingDistance(int x, int y) {
    int result = 0;
    x ^= y;

    while (x) {
      if (x % 2)
	result++;
      x = x >> 1;
    }

    return result;
  }
};
\end{minted}
\subsubsection{Questions}
\label{sec:orgee3097b}
Why the second solution is faster than the previous one?
\begin{itemize}
\item Bitwise XOR used.
\end{itemize}
\subsection{Python}
\label{sec:orgbbdbddb}
\subsubsection{Faster than 97.37\%}
\label{sec:orgf4427d0}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{python}
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
	result = 0
	while x or y:
	    if x % 2 != y % 2:
		result += 1
	    x = x >> 1
	    y = y >> 1
	return result
\end{minted}
However, this algorithm is exactly the same as C++'s first version. Why such huge speed variance?
\chapter{477. Total Hamming Distance}
\label{sec:orgc8ecf57}
\section{Problem Statement}
\label{sec:orgbc5a0ed}
\href{https://leetcode.com/problems/total-hamming-distance/}{Link}
\section{Analysis}
\label{sec:org73dcb38}
This problem is similar with \hyperref[orgf8b6eb9]{P461}, but you can't direcly solve it using that idea (see the first solution). The size of the input is large:
\begin{itemize}
\item Elements of the given array are in the range of \(0\) to \(10^9\)
\item Length of the array will not exceed \(10^4\)
\end{itemize}

\subsection{First Attempt (too slow)}
\label{sec:org0bea46c}
My first attempt is just go over all the combinations in the input array: \((x_i, x_j)\) and call the function that calculate the hamming distance of two integers (\hyperref[orgf8b6eb9]{P461}), the code is shown in solution section. However, this approach is too slow to pass the test.

The time complexity of the function that calculates the hamming distance of two integers is not huge, just \(O(1)\). The real time consuming part is the combination. It is simply:
\[
{N \choose 2} = \frac{N(N-1)}{2} \sim O(N^2)
\]
Inside these combinations, we included many bit-pairs that do not contribute to the total Hamming distance count, for example, the combination of number 91 and 117 is:
\begin{verbatim}
---------------
bit#: 1234 5678
---------------
91:   0101 1011
117:  0111 0101
---------------
\end{verbatim}
The bit at 1, 2, 4, 8 are not contributing to the total Hamming distance count, but we still include it and spend time verifying. This flaw can be solved in the grouping idea.

\subsection{Grouping}
\label{sec:orga024ccf}
\href{https://leetcode.com/problems/total-hamming-distance/discuss/96250/C++-O(n)-runtime-O(1)-space}{Reference}

The idea of grouping is we count the total hamming distance as a whole. And we only count those valid bits (bits that will contribute to the total Hamming distance). Specifically, at any giving time, we divide the array into two groups \(G_0, G_1\). The rule of grouping is:
\begin{itemize}
\item a number \(n\) that \(n \% 2 = 0\), goes to \(G_0\)
\item a number \(n\) that \(n \% 2 = 1\), goes to \(G_1\)
\end{itemize}
The result of \(n\%2\) will give you the least significant bit, or the last bit of an integer in binary form. By the definition of Hamming distance, we know that any combinations that contains number pairs only from \(G_0\) or only from \(G_1\) will not contribute to the total Hamming distance count (just for this grouping round, which only compares the least significant bit of those numbers). On the other hand, any combination that contains one number from \(G_0\) and one number from \(G_1\) will contribute 1 to the total Hamming distance. So, for this round, we only have to count the combination of such case, which is simply:
\[
N_{G_0} \times N_{G_1}
\]
Then, we trim the current least significant bit and re-group the numbers into new \(G_0\) and \(G_1\). This is because at each bit the numbers are different. We do this until \textbf{ALL} numbers are \textbf{ZERO}. For example, if at one round, there are no numbers in \(G_1\), all numbers are in \(G_0\), then although the contribution to total Hamming distance of this round is zero, we have to move on to trim the least significant bit and re-group the numbers. Another confusing case is when some numbers are trimmed to zero during the process. We still keep those zeros in array, because they still can be used to count total Hamming distance. For example, number 9 and 13317:
\begin{verbatim}
---------------------------
bit#:   1234 5678 9abc defg
---------------------------
9:      0000 0000 0000 1001
13317:  0011 0100 0000 0101
---------------------------
\end{verbatim}
After four times of trimming:
\begin{verbatim}
-----------------------
bit#:   1234 5678 9abc 
-----------------------
9:      0000 0000 0000 
13317:  0011 0100 0000 
-----------------------
\end{verbatim}
The difference at bit 3, 4, 6 should still be counted toward the total Hamming distance.

At each round, we first go over the list and divide the numbers into two groups. This process is \(O(N)\). To calculate the contribution to total Hamming distance at this round is just a matter of multiplication, so the time complexity is \(O(1)\). Thus, for one round, time complexity is \(O(N)\). There are potentially \texttt{8 * sizeof(int)} bits to be trimmed, this is the number of rounds we are going to run, which is a constant not related to \(N\). Thus the total complexity is: \(O(N)\).

\textbf{Additional notes (2019/5/26)} It is not a good idea to \textbf{TRIM} the numbers, which may add additional complexities. We can just use a for loop to compare all \texttt{8 * sizeof(int)} bits on integer. The range of iterating number (i) is from 0 to 31. At each iteration, we compare the value at i-th bit (starting from zero) with 1. To achieve this, we need use two operators (bitwise \textbf{AND} and left shift). Notice that the bitwise \textbf{AND} is 1 only if both bits are 1.
\section{Solution}
\label{sec:org874df3e}
\subsection{C++}
\label{sec:org145d32f}
\subsubsection{Not Accepted (too slow)}
\label{sec:orgb97cf70}
This algorithm is too slow.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int hammingDistance(const int& x, const int& y) {
    int result = 0;
    int a = x ^ y;

    while (a != 0) {
      if (a % 2)
	result++;
      a = a >> 1;
    }

    return result;
  }  

  int totalHammingDistance(vector<int>& nums) {
    int count = 0;
    for (int i = 0; i < nums.size() - 1; ++i) {
      for (int j = i + 1; j < nums.size(); ++j)
	count += hammingDistance(nums[i], nums[j]);
    }
    return count;
  }
};
\end{minted}
\subsubsection{Grouping. time (6.59\%) space (5.13\%)}
\label{sec:org8f02171}
This is the first version after I read and apply the idea of grouping numbers with different Least Significant bit. Although it is still slow, it is accepted\ldots{}..
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int totalHammingDistance(vector<int>& nums) {
    vector<int> LSB_ones;
    vector<int> LSB_zeros;
    int count = 0;
    int non_zero_count = 1; // loop continue until no non-zero num in nums

    while (non_zero_count) {
      // clear temp container, reset non-zero count
      LSB_ones.clear();
      LSB_zeros.clear();
      non_zero_count = 0;

      // collect number, divide into two groups
      for (auto& i : nums) {
	if (i % 2 == 0)
	  LSB_zeros.push_back(i);
	else 
	  LSB_ones.push_back(i);

	// update i and non_zero_count
	i = i >> 1;
	if (i)
	  non_zero_count++;
      }

      // update count 
      count += LSB_ones.size() * LSB_zeros.size();
    }

    return count;
  }
};
\end{minted}

There are many reasons why this solution is expensive. Some of them are listed below:
\begin{itemize}
\item There is no need to actually use two vectors to \textbf{STORE} each number in two vectors. You just need to count the number.
\end{itemize}
\subsubsection{Grouping\_example. time (88.24\%, 49.76\%)}
\label{sec:org17f5241}
This is from the discussion (grouping idea).
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int totalHammingDistance(vector<int>& nums) {
    if (nums.size() <= 0) return 0;

    int res = 0;

    for(int i=0;i<32;i++) {
      int setCount = 0;
      for(int j=0;j<nums.size();j++) {
	  if ( nums[j] & (1 << i) ) setCount++;
      }

      res += setCount * (nums.size() - setCount);
    }

    return res;
  }
};
\end{minted}

This solution is a lot faster than my version, altough we use the same idea. I used a lot more steps to do the book keeping, which the example solution uses spaces and time efficiently. Specifically:
\begin{itemize}
\item I have defined two vectors to actually store the \textbf{TWO} groups. My thinking is simple: if the idea involves two groups, then I want to actually implement two groups to closely follow the idea. This reflects the lack of ability to generalize a problem and find what matters most to solve the problem. In this specific example, what matters most, is to \textbf{KNOW} the number of element in just \textbf{ONE} group, there are ways to know this without actually spending time and spaces to keep the whole record of the two groups.
\item my end point would be "there is no non-zero number in the array", I have to declare a new integer to keep track of the number of non-zero number, and I have to use an if expression to determine if a number is non-zero after trimming the least significant bit.  The example code only traverse all the bits of an integer (i.e. 32 bits in total, or 4 bytes) using a for loop.
\end{itemize}

In line 11, the code reads: \texttt{if ( nums[j] \& (1 << i) ) setCount++;}. The operators used are bitwise AND, bitwise left shift. This is to compare the i-th bit of \texttt{num[j]} with 1. If it is 1, then at this bit, the number should be counted in group \(G_1\). For example, if \texttt{num[j] == 113}, \texttt{i == 5}, then we compare:
\begin{verbatim}
           ↓
113:     0111 0001
1 << i:  0010 0000
\end{verbatim}

Also, we don't have to count integer numbers in \(G_0\), since: \(N_{G_0} = N - N_{G_1}\), where \(N\) is the total number of integers, which is equal to \texttt{nums.size()}.

\section{todos [3/4]}
\label{sec:org58c2ec4}
\begin{itemize}
\item[{$\boxtimes$}] Write the analysis of grouping idea and my code
\item[{$\boxtimes$}] Read code in reference of grouping idea, make notes
\item[{$\boxtimes$}] Check other possible solution and make future plan
\item[{$\square$}] Try to generalize this problem
\end{itemize}
\chapter{581. Shortest Unsorted Continuous Subarray}
\label{sec:org5910d1c}
\section{Problem Statement}
\label{sec:orgee657d2}
\href{https://leetcode.com/problems/shortest-unsorted-continuous-subarray/}{Link}
\section{Analysis}
\label{sec:org8deac3d}
\subsection{Use sorting}
\label{sec:orge8df85e}
Let's compare the original array with its sorted version. For example, we have:
\begin{verbatim}
original: 2 6 4 8 10  9  15
sorted:   2 4 6 8  9 10  15
            ↑            ↑
            1            6
\end{verbatim}
They started to differ at 1, and ended differ at 6. The continuous unsorted subarray is bound to this range, thus we can calculate the length by \texttt{end\_differ\_index - start\_differ\_index}.

Steps to solve this problem:
\begin{enumerate}
\item build a sorted array
\item create two integers: \texttt{end\_differ\_index - start\_differ\_index}, they represent the position where differ between original array and sorted array starts and ends. The default value would be zero, which means no difference.
\item start from beginning, traverse the array to find out the first position where two arrays differ. Store it in \texttt{start\_differ\_index}.
\item start from ending, traverse the array (to the beginning) to find out the last position where two arrays are the same. Store it in \texttt{end\_differ\_index}.
\item return \texttt{end\_differ\_index - start\_differ\_index}, which is the length of the shortest unsorted continuous subarray. If the original array is already sorted, this value would be zero.
\end{enumerate}

\section{Solution}
\label{sec:orgd19f201}
\subsection{C++}
\label{sec:org73418da}
\subsubsection{use sorting}
\label{sec:orgab4662b}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int findUnsortedSubarray(vector<int>& nums) {
    vector<int> nums_sorted = nums;
    sort(nums_sorted.begin(), nums_sorted.end());

    int start_differ_index = 0;
    int end_differ_index = 0;

    // determine start_differ_index
    for (int i = 0; i < nums.size(); i++) {
      if (nums[i] != nums_sorted[i]) {
	start_differ_index = i;
	break;
      }
    }

    // determine end_differ_index
    for (int i = nums.size() - 1; i >= 0; i--) {
      if (nums[i] != nums_sorted[i]) {
	end_differ_index = i + 1;
	break;
      }
    }

    // return result 
    return end_differ_index - start_differ_index;
  }
};
\end{minted}
\section{todos [1/3]}
\label{sec:orgc1e12b5}
\begin{itemize}
\item[{$\boxtimes$}] write down your analysis and solution
\item[{$\square$}] check solution page, study, understand and implement them
\item[{$\square$}] study first solution (brutal force)
\end{itemize}
\chapter{771. Jewels and Stones}
\label{sec:org734b68b}
\section{Problem Statement}
\label{sec:org85ca26d}
\href{https://leetcode.com/problems/jewels-and-stones/}{Link}
\section{Analysis}
\label{sec:org6c148a5}
\section{Solution}
\label{sec:org129ee00}
\subsection{C++}
\label{sec:org24b0b9d}
\subsubsection{\(N^2\) Time (96.35\%) Space (79.64\%)}
\label{sec:org98d4a98}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int numJewelsInStones(string J, string S) {
    int numJewl = 0;
    for (auto s : S)
      if (isJewels(s, J))
	numJewl++;
    return numJewl;
  }

  bool isJewels(char s, string J) {
    for (auto j : J)
      if (s == j)
	return true;

    return false;
  }
};
\end{minted}
\part{Hash Table}
\label{sec:org9e5e372}
\chapter{242. Valid Anagram}
\label{sec:org2572a84}
\section{Problem Statement}
\label{sec:org0a240f2}
\href{https://leetcode.com/problems/valid-anagram/}{Link}
\section{Analysis}
\label{sec:org8ae84ae}
\subsection{Sort}
\label{sec:org6977146}
\subsection{Hash Table}
\label{sec:orgce2a463}
\section{Solution}
\label{sec:orge71012d}
\section{todos [/]}
\label{sec:org6184054}
\begin{itemize}
\item[{$\square$}] write down your analysis and solution
\item[{$\square$}] check solution and discussion section, read and understand other ideas and implement them
\item[{$\square$}] generalize the problem
\end{itemize}
\part{Linked List}
\label{sec:orgc7c22e0}
\chapter{160. Intersection of Two Linked Lists}
\label{sec:orgfff395f}
\section{Problem Statement}
\label{sec:orga182f0d}
\href{https://leetcode.com/problems/intersection-of-two-linked-lists/}{Link}
\section{Analysis}
\label{sec:org0e37333}
Assume the size of list \texttt{A} is \emph{(m}), and the size of list \texttt{B} is \emph{(n}).
\subsection{Brutal force}
\label{sec:orgc7570fb}
We can traverse list \texttt{A}. For each encountered node, we traverse list \texttt{B} to find out if there is a same node. The time complexity should be \emph{(O(mn)}). Since we don't use other spaces to store any information, the space complexity is \emph{(O(1)}).

\subsection{Hash table}
\label{sec:org0332e29}
First, we traverse list \texttt{A} to store all the address information of each node in a hash table (e.g. Unordered-set). Then we traverse list \texttt{B} to find out if each node in \texttt{B} is also in the hash table. If so, it is an intersection.

\subsection{Skip longer list}
\label{sec:org618d29b}
Let's consider a simpler situation: list \texttt{A} and list \texttt{B} has the same size. We just need to traverse the two lists one node at a time. If there is an intersection, it must be at the same relative position in the list.

In this problem, we may not have lists that with same size. However, if two linked lists intersect at some point, the merged part's length does not exceed the size of the shorter list. This means we can skip some beginning parts of the longer list because intersection could not possibly happen there. For example:
\begin{verbatim}
List A: 1 5 2 8 6 4 9 7 3
List B:       4 8 1 9 7 3
                    ↑
\end{verbatim}
List \texttt{A} and \texttt{B} intersect at node 9. We can skip the \texttt{[1, 5, 2]} part in list \texttt{A} and then treat them as list with same size:
\begin{verbatim}
List A': 8 6 4 9 7 3
List B : 4 8 1 9 7 3
               ↑
\end{verbatim}

So the steps to solve this problem are:
\begin{enumerate}
\item traverse list \texttt{A} and \texttt{B} to find out the size of two lists
\item skip beginning portion of longer list so that the remaining part of the longer list has the same size as the shorter list
\item check the two lists and find possible intersection
\end{enumerate}

The time complexity: \(O(n)\) or \(O(m)\), depends on which is bigger. The space used is not related to the input size, thus space complexity is \(O(1)\).

\subsection{Two pointer}
\label{sec:orga158047}
\section{Solution}
\label{sec:org109467d}
\subsection{C++}
\label{sec:org1f5d741}
\subsubsection{brutal force}
\label{sec:org64b828f}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
  ListNode* exist(ListNode* ptr, ListNode* head) {
    while (head != nullptr && ptr != head) {
      head = head->next;
    }

    return head;
  }

  ListNode* getIntersectionNode(ListNode *headA, ListNode *headB) {
    while (headA != nullptr) {
      ListNode* result = exist(headA, headB);

      if (result != nullptr)
	return result;

      headA = headA->next;
    }

    return headA;
  }
};
\end{minted}
\subsubsection{hash table}
\label{sec:org43b3ca0}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:

  ListNode* getIntersectionNode(ListNode *headA, ListNode *headB) {
    unordered_set<ListNode*> A_record;

    // record A's node 
    while (headA != nullptr) {
      A_record.insert(headA);
      headA = headA->next;
    }

    // go over B and find if there is any intersection
    while (headB != nullptr) {
      if (A_record.find(headB) != A_record.end())
	return headB;

      headB = headB->next;
    }

    return headB;
  }
};
\end{minted}
\subsubsection{skip longer lists}
\label{sec:orgb8a45f5}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:

  ListNode* getIntersectionNode(ListNode *headA, ListNode *headB) {
    int size_A = 0;
    int size_B = 0;

    ListNode* start_A = headA;
    ListNode* start_B = headB;

    // count the number of nodes in A and B
    while (start_A != nullptr) {
      start_A = start_A -> next;
      size_A++;
    }

    while (start_B != nullptr) {
      start_B = start_B -> next;
      size_B++;
    }

    // skip the first portion of the list
    if (size_A > size_B) {
      int skip = size_A - size_B;

      for (int i = 1; i <= skip; i++)
	headA = headA -> next;
    }

    else if (size_A < size_B) {
      int skip = size_B - size_A;

      for (int i = 1; i <= skip; i++)
	headB = headB -> next;
    }

    // now A and B has same relative length, check possible intersection
    while (headA != nullptr && headA != headB) {
      headA = headA -> next;
      headB = headB -> next;
    }

    return headA;

  }
};
\end{minted}
\section{todos [1/3]}
\label{sec:org3279a86}
\begin{itemize}
\item[{$\boxtimes$}] write down your analysis and solution
\item[{$\square$}] read the two pointer solution, understand, implement, record
\item[{$\square$}] read discussion page to see if there is any other solution
\end{itemize}
\chapter{206. Reverse Linked List}
\label{sec:org862039a}
\section{Problem Statement}
\label{sec:orgfe5c0de}
\href{https://leetcode.com/problems/reverse-linked-list/}{Link}

Notice that the \texttt{head} in this linked list is actually the first node in the list. Not like what you learned in COP 4530.
\section{Analysis}
\label{sec:org95cb6c4}
This problem should have some simpler solution. My two solutions are just akward.
\subsection{Using Stack (my)}
\label{sec:orgc19fb8e}
\subsection{Recursion (my)}
\label{sec:org785bede}
\section{Solution}
\label{sec:org88596be}
\subsection{C++}
\label{sec:org6b9a0ef}
\subsubsection{Using Stack. time (96\%), space (5\%)}
\label{sec:org79f928f}
This method uses a stack to keep the reverse order. Additional memory is required.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
  ListNode* reverseList(ListNode* head) {
    stack<ListNode*> nodes;
    // check if head is nullptr
    if (head == nullptr)
      return head;

    // store the list in stack 
    while (true) {
      if (head->next != nullptr) {
	nodes.push(head);
	head = head->next;
      }

      else { // head is pointing the last node
	nodes.push(head);
	break;
      }
    }

    // start re-connect
    head = nodes.top();
    nodes.pop();
    ListNode* last_node = head;

    while (!nodes.empty()) {
      last_node->next = nodes.top();
      last_node = last_node->next;
      nodes.pop();
    }

    last_node->next = nullptr;

    return head;
  }
};
\end{minted}
\subsubsection{Using Recursion. time (18\%), space (21\%)}
\label{sec:orgd461b89}
This approach is a very "akward" way to use recursion.
\section{todos [/]}
\label{sec:org48cb773}
\begin{itemize}
\item[{$\square$}] try to think another way to work this problem
\item[{$\square$}] read solution, write down thinking process
\item[{$\square$}] time complexity analysis of your code and solution code
\end{itemize}
\part{Trees}
\label{sec:org48ccd39}
\chapter{101. Symmetric Tree}
\label{sec:orgdbd080b}
\section{Problem Statement}
\label{sec:orgf49549d}
\href{https://leetcode.com/problems/symmetric-tree/}{Link}
\section{Analysis}
\label{sec:org29b268b}
\subsection{Recursion}
\label{sec:orgc0d9302}
We need to define a method to describe how two nodes are equal "symmetrically", i.e. if two subtrees with root node \texttt{a} and \texttt{b}, we say subtree \texttt{a} is "equal" with subtree \texttt{b}, if the two subtrees are symmetric.

By this method, we need a helper function that accepts two \texttt{Treenode} pointer (\texttt{a} and \texttt{b}). Its return type is bool. It can tell whether the two subtrees started by the two \texttt{Treenode} passed in are symmetrically equal or not. We use this function recursively. Two subtrees are symmetrically equal, if:
\begin{enumerate}
\item \texttt{a->val == b->val}, the root must have the same value
\item \texttt{a->left} is symmetrically equal to \texttt{b->right}
\item \texttt{a->right} is symmetrically equal to \texttt{b->left}
\end{enumerate}
Case 2, 3 can be determined by calling this function recursively. Case 1 can be determined directly. Also, we have to be aware of the base case (when \texttt{a == nullptr} or \texttt{b == nullptr}.

\section{Solution}
\label{sec:orgfecbba5}
\subsection{C++}
\label{sec:org773df3d}
\subsubsection{recursion (75\%, 64\%)}
\label{sec:org6a4d812}
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  bool isSymmetric(TreeNode* root) {
    if (root == nullptr)
      return true;

    return isSym(root->left, root->right);
  }

  bool isSym(TreeNode* a, TreeNode* b) {
    if (a == nullptr) {
      if (b == nullptr)
	return true;
      return false;
    }

    if (b == nullptr)
      return false;

    if (a->val != b->val)
      return false;

    if (isSym(a->left, b->right) && isSym(a->right, b->left))
      return true;

    return false;
  }
};

\end{minted}
\section{todos [1/5]}
\label{sec:org00fd1c5}
\begin{itemize}
\item[{$\boxtimes$}] write down your analysis (recursion)
\item[{$\square$}] think about iterative solution
\item[{$\square$}] write down analysis (iterative solution)
\item[{$\square$}] check solution and discussion to find out any other idea
\item[{$\square$}] generalize this problem
\end{itemize}

\chapter{104. Maximum Depth of Binary Tree}
\label{sec:orgd686b86}
\section{Problem Statement}
\label{sec:orgcf39d53}
\href{https://leetcode.com/problems/maximum-depth-of-binary-tree/}{Link}
\section{Analysis}
\label{sec:org9553636}
\subsection{Recursion}
\label{sec:org82d2ff4}
A node's maximum depth, is the larger maximum depth of its left and right subtree plus one. Base case: if a node is nullptr, maximum depth is zero.
\section{Solution}
\label{sec:org3ad9961}
\subsection{C++}
\label{sec:orgc1d1910}
\subsubsection{Recursion. Time (88.44\%) Space (91.28\%)}
\label{sec:org097e431}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  int maxDepth(TreeNode* root) {
    // base case 
    if (root == nullptr)
      return 0;

    int left_depth = maxDepth(root->left);
    int right_depth = maxDepth(root->right);

    return (left_depth >= right_depth ? left_depth + 1 : right_depth + 1);
  }
};
\end{minted}
\section{todos [0/1]}
\label{sec:orgc612c48}
\begin{itemize}
\item[{$\square$}] read about the discussion page for more methods and ideas
\item[{$\square$}] read about traversal method
\item[{$\square$}] make notes in your data structure notes about DFS abd BFS
\end{itemize}
\chapter{112. Path Sum}
\label{sec:orgeaca132}
\section{Problem Statement}
\label{sec:org50e228f}
\href{https://leetcode.com/problems/path-sum/}{Link}
\section{Analysis}
\label{sec:org8bf7fd5}
\subsection{Recursion}
\label{sec:org70868b9}
The goal is to find a root-to-leaf path such that sum of all values stored in node is the given sum: \texttt{sum}. We can start from root. Notice that, if \texttt{root->left} or \texttt{root->right} has a path that can add up to \texttt{sum - root->val}, a path is found. This implies that we can recursively call the function itself and find if there is any path that can have \texttt{sum - root->val} target.

One thing should be noticed that is, we have to go down all the way to a leaf to find out the final answer that whether the path of this leaf to root satisfies or not. So there is only two base cases:
\begin{enumerate}
\item the pointer passed in is \texttt{nullptr}: return false
\item the pointer passed in is leaf: check if passed in \texttt{sum} is equal to \texttt{root->val}, if so, return true. Otherwise, return false.
\end{enumerate}

For other situations, we continue call the function. Do not pass in \texttt{nullptr}.

\section{Solution}
\label{sec:org39128e9}
\subsection{C++}
\label{sec:org9a6f387}
\subsubsection{recursion (88\%, 92\%)}
\label{sec:org131ca7c}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
      if (root == nullptr)
	return false;

      if (root->left == nullptr && root->right == nullptr) {
	if (root->val == sum)
	    return true;
	else
	    return false;
      }

      if (root->left == nullptr)
	return hasPathSum(root->right, sum - root->val);
      else if (root->right == nullptr)
	return hasPathSum(root->left, sum - root->val);
      else
	return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
    }
};
\end{minted}
\section{todos [1/3]}
\label{sec:orgb950350}
\begin{itemize}
\item[{$\boxtimes$}] write down your recursion solution and analysis
\item[{$\square$}] work on the DFS approach
\item[{$\square$}] check discussion, find out other ideas, understand and implement them
\end{itemize}

\chapter{113. Path Sum II}
\label{sec:org03ee144}
\section{Problem Statement}
\label{sec:org9284390}
\href{https://leetcode.com/problems/path-sum-ii/}{Link}
\section{Analysis}
\label{sec:orgfebd182}
\subsection{DFS}
\label{sec:orgac1484b}
In DFS, you use a stack to keep track of your path. This problem requires you to find out all the path that satisfies the requirement. So you have to do book-keeping. The basic DFS idea is as follows.
\begin{enumerate}
\item we push the root into a stack: \texttt{v}.
\item use a while loop to find all combinations of root-to-leaf path: \texttt{while (!v.empty())}
\item if the top node in the stack is a leaf, then it suggests the current stack is holding a complete root-to-leaf path. We should check if this path adds to the target sum. If so we have to push this path into the result. Then, we have to trace backward, until we found a previous node that has unvisited child \textbf{OR} the stack is empty. Each time we push a node into the stack, we have to mark it as visited. We achieve this by using an unordered\_set to record these nodes being pushed into the stack. Unordered\_set has fast retrival rate using a key.
\item if the top node in the stack is not a leaf, then we have to continue to push its children into the stack. We first try inserting left child, and then right child. This depends on the visit history of the children. Only one child per loop. After inserting one child, we \texttt{continue}, beginning the next loop.
\item from the above analysis, we can see that we trace back, only when we meet a leaf node. This guarantees that the found path is root-to-leaf path.
\item after the while loop, the stack becomes empty, which means all nodes are visited. Then we return the result.
\end{enumerate}

\section{Solution}
\label{sec:org68baf1a}
\subsection{C++}
\label{sec:orgc979a29}
\subsubsection{DFS (80\%, 40\%)}
\label{sec:org5082df2}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  // member variables
  vector<vector<int>> results;
  unordered_set<TreeNode*> visited_nodes;

  // helper functions
  bool isLeaf(TreeNode* t) {
    return (t->left == nullptr) && (t->right == nullptr);
  }

  void traceBack(vector<TreeNode*>& v) {
    while (!v.empty() && !hasUnvisitedChild(v.back()))
      v.pop_back();
  }

  bool hasUnvisitedChild(TreeNode* t) {
    return !(isVisited(t->left) && isVisited(t->right));
  }

  bool isVisited(TreeNode* t) {
    if (t == nullptr || visited_nodes.find(t) != visited_nodes.end())
      return true;

    return false;
  }

  void checkVal(const vector<TreeNode*>& v, int target) {
    int sum = 0;
    vector<int> result;
    for (auto node : v) {
      result.push_back(node->val);
      sum += node->val;
    }

    if (sum == target)
      results.push_back(result);
  }

  // solution function
  vector<vector<int>> pathSum(TreeNode* root, int sum) {
    if (root == nullptr)
      return results;

    vector<TreeNode*> v{root};
    visited_nodes.insert(root);

    while (!v.empty()) {
      // check the last node: to see if it is leaf 
      if (isLeaf(v.back())) {
	checkVal(v, sum);
	traceBack(v);
	continue;
      }

      if (!isVisited(v.back()->left)) {
	visited_nodes.insert(v.back()->left); // mark as visited
	v.push_back(v.back()->left);
	continue;
      }

      if (!isVisited(v.back()->right)) {
	visited_nodes.insert(v.back()->right); // mark as visited
	v.push_back(v.back()->right);
	continue;
      }
    }

    return results;
  }
};
\end{minted}
\section{todos [1/4]}
\label{sec:orgc13a22f}
\begin{itemize}
\item[{$\boxtimes$}] write down your DFS solution and analysis
\item[{$\square$}] work on the recursion approach
\item[{$\square$}] check discussion, find out other ideas, understand and implement them
\item[{$\square$}] generalize the problem
\end{itemize}

\chapter{226. Invert Binary Tree}
\label{sec:org8006149}
\section{Problem Statement}
\label{sec:orgc0fcf61}
\href{https://leetcode.com/problems/invert-binary-tree/}{Link}
\section{Analysis}
\label{sec:org4629ac4}
\subsection{Recursion}
\label{sec:org2838cb0}
To solve this problem recursively, we first invert the left subtree of a node by calling this function, then we invert the right subtree of this node by calling this function. Then we return a pointer to this node. Base case: \texttt{node == nullptr}, in this case we return the node directly, since the invert of a \texttt{nullptr} tree is itself.
\section{Solution}
\label{sec:org4325789}
\subsection{C++}
\label{sec:org0e05007}
\subsubsection{Recursion. time (91.95\%) space (5.15\%)}
\label{sec:orgef94a57}
I don't understand why my code require this amount of space. Needs to be analyzed.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr)
      return root;

    TreeNode* temp = root->left;
    root->left = invertTree(root->right);
    root->right = invertTree(temp);

    return root;
  }
};
\end{minted}
\section{todos [0/2]}
\label{sec:orgdc6fd83}
\begin{itemize}
\item[{$\square$}] analyze why my code requires a lot more space than the divide and conquer method
\item[{$\square$}] read the discussion page for more solution
\end{itemize}
\chapter{437. Path Sum III}
\label{sec:org26ed16d}
\section{Problem Statement}
\label{sec:orgaf6d229}
\href{https://leetcode.com/problems/path-sum-iii/}{Link}
\section{Analysis}
\label{sec:org83ca097}
\subsection{Double recursion (\textasciitilde{}50\%, 50\%)}
\label{sec:org2de0d79}
The tricky part is that the path does not need to start or end at the root or a leaf. However, it must go downwards (traveling only from parent nodes to child nodes), this is to say that we don't consider the situation that the path is like: \texttt{left\_child -> node -> right\_child}, which makes things easier.

The tricky part means we may have some paths deep below that sum to the target value, these paths are not connected to the root. In fact, we can conclude that, given a tree (or subtree) starting at \texttt{node}, the paths that sum to the target value are composed of following cases:
\begin{enumerate}
\item paths from \textbf{left} subtree of node that sum to the target, they are not connected to \texttt{node} though
\item paths from \textbf{right} subtree of node that sum to the target, they are also not connected to \texttt{node}.
\item any paths that containing \texttt{node} as their starting node. This includes path connecting \texttt{node} and \texttt{node->left}, paths connecting \texttt{node} and \texttt{node->right}, and also \texttt{node} alone if \texttt{node->val == target}.
\end{enumerate}

Pay attention that we don't have to consider paths like \texttt{left->node->right}, as mentioned earlier. The function header of the solution function is:
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
int pathSum(TreeNode* root, int sum)
\end{minted}

We can use this function to get the result of case 1 and case 2. Since these results are \textbf{NOT} containing the root. As for case 3, we can build a helper function \texttt{continuousSum()} to calculate. This function will also use recursive algorithm. The function header is:
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
int continuousSum(TreeNode* root, int sum)
\end{minted}

It will return the total number of path that containing \texttt{root} and sum to the target \texttt{sum}. Pay attention that, these paths do not need to go from \texttt{root} to leaf. The base case is when \texttt{root == nullptr}, in this case, return zero. The total number can be calculated by calling itself, which is composed of following:
\begin{enumerate}
\item \texttt{continuousSum(root->left, sum - root->val)}
\item \texttt{continuousSum(root->right, sum - root->val)}
\item \texttt{+1 if root->val == sum}
\end{enumerate}

Case 3 is when a path only contains the \texttt{root}. Pay attention that if \texttt{root->left} has a path sum to zero, and \texttt{root->val == sum}, then \texttt{left->root} and \texttt{root} are considered two different pathes. If we think in a recursive way, this will account for those paths that from a node but not reaching leaf. The last node in the path is the node that \texttt{node->val is equal to passed in sum}.
\section{Solution}
\label{sec:orgbfc4c32}
\subsection{C++}
\label{sec:org570fb54}
\subsubsection{double recursion}
\label{sec:orgd59e80f}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 /*Notes: 
 calculate continuous sum and un-continuous sum
 */
class Solution {
public:
  int continuousSum(TreeNode* root, int sum) {
    if (root == nullptr)
      return 0;

    int count = continuousSum(root->left, sum - root->val) + continuousSum(root->right, sum - root->val);

    if (sum == root->val)
      count += 1;

    return count;
  }

  int pathSum(TreeNode* root, int sum) {
    if (root == nullptr)
      return 0;

    return continuousSum(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);

  }
};
\end{minted}
\section{todos [1/3]}
\label{sec:org076a830}
\begin{itemize}
\item[{$\boxtimes$}] write down your own solution (including analysis).
\item[{$\square$}] check discussion panel, find out other solutions. Understand and write analysis, implement the solution
\item[{$\square$}] write down these analysis
\end{itemize}
\chapter{543. Diameter of Binary Tree}
\label{sec:orgf6860a9}
\section{Problem Statement}
\label{sec:org3ec5a10}
\href{https://leetcode.com/problems/diameter-of-binary-tree/}{Link}
\section{Analysis}
\label{sec:org2282334}
\subsection{Direct recursion}
\label{sec:orgfcfb08c}
Just as stated in the problem statement, the longest path between any two nodes may not pass through the root. So, for a given node, the longest path of this node may have three cases:
\begin{enumerate}
\item longest path is in its left subtree, and does not pass this node;
\item longest path is in its right subtree, and does not pass this node;
\item longest path passes through this node;
\end{enumerate}

We can calculate the path of the above three cases, and find out which one is the longest. Calculate case 1 and 2 is easy, we can call the function recursively to find out the longest path of the left and right subtree. To calculate case 3, we use the fact that: longest path passing this node = height of left subtree + height of right subtree + 2, where "2" correspondes to the two edges connecting left and right subtree to the root node. The we compare these three values and return the largest one.

Also, we have to consider the base case:
\begin{enumerate}
\item this node is \texttt{nullptr}
\item its left subtree is \texttt{nullptr}
\item its right subtree is \texttt{nullptr}
\end{enumerate}

\section{Solution}
\label{sec:org03cc8e6}
\subsection{C++}
\label{sec:orgaa71056}
\subsubsection{direct recursion (5\%, 5\%)}
\label{sec:orgad65596}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  int height(TreeNode* t) {
    if (t == nullptr || (t->left == nullptr && t->right == nullptr))
      return 0; 
    return max(height(t->left), height(t->right)) + 1;
  }

  int diameterOfBinaryTree(TreeNode* root) {
    if (root == nullptr || (root->left == nullptr && root->right == nullptr))
      return 0;

    if (root->left == nullptr)
      return max(height(root), diameterOfBinaryTree(root->right));
    else if (root->right == nullptr)
      return max(height(root), diameterOfBinaryTree(root->left));
    else
      return max(max(height(root->left) + height(root->right) + 2, diameterOfBinaryTree(root->left)), diameterOfBinaryTree(root->right));
  }
};

\end{minted}

\section{todos [/]}
\label{sec:org5e76a61}
\begin{itemize}
\item[{$\square$}] check solution and study
\item[{$\square$}] implement solution by yourself
\item[{$\square$}] write down different ways of thinking about this problem
\end{itemize}
\chapter{617. Merge Two Binary Trees}
\label{sec:orgf5010d5}
\section{Problem Statement}
\label{sec:orgb2a9ede}
\href{https://leetcode.com/problems/merge-two-binary-trees/}{Link}
\section{Analysis}
\label{sec:orgc850ce8}
\subsection{Recursive Method}
\label{sec:org2438f62}
Use recursiion to solve this problem.
\subsection{Iterative Method (using stack)}
\label{sec:orga72f886}

\section{Solution}
\label{sec:org20e372c}
\subsection{C++}
\label{sec:org4892f6f}
\subsubsection{Recursion Time (97.09\%) Space(37.01\%)}
\label{sec:org2093c0b}
Recursion.
\begin{minted}[linenos,firstnumber=1,breaklines=true,breakanywhere=true]{c++}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
    if (t1 == nullptr)
      return t2;
    else if (t2 == nullptr)
      return t1;
    else {
      TreeNode* node = new TreeNode(t1->val + t2->val);
      node->left = mergeTrees(t1->left, t2->left);
      node->right = mergeTrees(t1->right, t2->right);
      return node;
    }
  }
};
\end{minted}
\subsubsection{Iterative}
\label{sec:org0e0e8e8}
\section{todos [0/2]}
\label{sec:org7c7ce1a}
\begin{itemize}
\item[{$\square$}] read the other solution (iterate the tree using stack), and understand it
\item[{$\square$}] write code based on the other solution
\end{itemize}
\chapter{938. Range Sum of BST}
\label{sec:org6141ee6}
\section{Problem Statement}
\label{sec:orgff8eab8}
\href{https://leetcode.com/problems/range-sum-of-bst/}{Link}
\section{Analysis}
\label{sec:org45e68d8}
\subsection{Recursion (brutal and stupid)}
\label{sec:org16ef3c3}
The tree is composed of left subtree, the node, and the right subtree. The base case is when the root is pointing to \texttt{nullptr}, in this case, we should return 0.

Thus, we call the function itself to find out the range sum of left subtree and right subtree first, then we check the \texttt{node->val}. If it is within the range, we add it to the whole sum, otherwise, we ignore it.

This algorithmm is easy to follow, but it does a lot of unnecessary work (didn't use the fact that this is a binary search tree, which satisfies: \texttt{node->left->val < node->val < node->right->val}, given "the binary search tree is guaranteed to have unique values"). If \texttt{node->val} is smaller than \texttt{L}, then we have no reason to check \texttt{rangeSumBST(node->left, L, R)}, since any value contained in this branch of subtree is bound to be smaller than \texttt{node->val}, thus not within the range \texttt{[L, R]}. Similarliy if \texttt{node->val} is greater than \texttt{R}, we don't have to check \texttt{rangeSumBST(node->right, L, R)}. This thought gives a better recursion algorithm.
\subsection{DFS}
\label{sec:orga054ba0}
DFS allows us to traverse the tree in a deapth first manner (go deep first). It will eventually go over all the nodes one by one. We use a stack to perform the DFS, we also need an associative container to hold record of visited nodes. The basic steps is this:
\begin{enumerate}
\item create a stack and an unordered\_set
\item push the root (if it is not nullptr) into the stack
\item while the stack is not empty, we check the top node in the stack
\begin{itemize}
\item if the top node is a leaf, then we check its value (to see if it is within the range, so we can add it to the total sum); Then we pop it ()
\item if the top node is not a leaf, we check if its left node is visited, if not, we visit it by pushing its left child into the stack, and record this in the Unordered\_set, then we go to the next loop. If its left node was already visited, we check right child and do the same thing
\end{itemize}
\item if the top node has no unvisited child, we check its value to see if it satisfies the range, if so, we add it to the sum. Then, we pop it out of the stack, start next loop.
\end{enumerate}

By DFS, we can traverse the whole tree's each node in a depth-first manner. We can get the range sum along the way.

\section{Solution}
\label{sec:org3de7526}

\subsection{C++}
\label{sec:org8ce3785}

\subsubsection{recursion (stupid)}
\label{sec:org82253e9}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int rangeSumBST(TreeNode* root, int L, int R) {
    // base case 
    if (root == nullptr)
      return 0;

    return (root -> val <= R && root -> val >= L ? root -> val + rangeSumBST(root -> left, L, R) + rangeSumBST(root -> right, L, R) : rangeSumBST(root -> left, L, R) + rangeSumBST(root -> right, L, R));
  }
};
\end{minted}

\subsubsection{recursion (better)}
\label{sec:orgee9018f}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int rangeSumBST(TreeNode* root, int L, int R) {
    // base case 
    if (root == nullptr)
      return 0;

    if (root->val < L)
      return rangeSumBST(root -> right, L, R);

    if (root->val > R)
      return rangeSumBST(root->left, L, R);

    return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);
  }
};
\end{minted}

\subsubsection{DFS (slow, 5\% and 6\%)}
\label{sec:org37d68e5}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
class Solution {
public:

  int rangeSumBST(TreeNode* root, int L, int R) {
    if (root == nullptr)
      return 0;

    int sum = 0;

    // use a set to keep track of visited nodes 
    unordered_set<TreeNode*> visited_nodes;
    // use a stack to do DFS
    stack<TreeNode*> nodes;
    nodes.push(root);

    while (!nodes.empty()) {
      // check if top node is leaf or not
      if (nodes.top()->left == nodes.top()->right) {
	if (nodes.top()->val >= L && nodes.top()->val <= R) {
	  sum += nodes.top()->val;
	  nodes.pop();
	  continue;
	}
      }

      // check if nodes.top() has unvisited child (first check left, then right)
      // if so, push it into the stack 
      // otherwise, calculate sum 
      if (nodes.top()->left != nullptr && visited_nodes.find(nodes.top()->left) == visited_nodes.end()) {
	visited_nodes.insert(nodes.top()->left);  // mark as visited 
	nodes.push(nodes.top()->left);
	continue;
      }

      if (nodes.top()->right != nullptr && visited_nodes.find(nodes.top()->right) == visited_nodes.end()) {
	visited_nodes.insert(nodes.top()->right);
	nodes.push(nodes.top()->right);
	continue;
      }

      // up to here, both child of the nodes.top() node has been visited
      // add to sum if nodes.top()->val satisfies the condition 
      if (nodes.top()->val >= L && nodes.top()->val <= R)
	sum += nodes.top()->val;

      nodes.pop();
    }

    return sum;

  }
};
\end{minted}

\section{todos [1/3]}
\label{sec:org7a4de63}
\begin{itemize}
\item[{$\boxtimes$}] write down your analysis and solution (recursion and DFS)
\item[{$\square$}] check solution's DFS, study and re-implement
\item[{$\square$}] read discussion page, to gain more understanding of possible solution
\item[{$\square$}] re-implement and write down analysis
\end{itemize}
\part{Other}
\label{sec:orgb986af3}
\chapter{70. Climbing Stairs}
\label{sec:org25a9093}
\section{Problem Statement}
\label{sec:org65b3a4c}
\href{https://leetcode.com/problems/climbing-stairs/}{Link}
\section{Analysis}
\label{sec:orgfd8de4e}
This problem can be analyzed backward. Assume we have two steps left, we can use two 1 step to finish, or one 2 steps to finish. So the total number of ways to finish is: [number of ways to finish n - 1 stairs] + [number of ways to finish n - 2 stairs].

It is easy to think using recursion to do this, but it will cause a lot of unnecessary calculation (redundant calculation). This problem is identical to calculate Fibonacci number. Recursion is a bad implementation. The good way is to \textbf{Store} the intermediate results, so we can calculate next term easily.

\section{Solution}
\label{sec:org823db24}
\subsection{C++}
\label{sec:orga1be6e5}
\subsubsection{use a vector to hold intermediate result (77\%, 64\%)}
\label{sec:org352bcbc}
\begin{minted}[breaklines=true,breakanywhere=true]{c++}
class Solution {
public:
  int climbStairs(int n) {
    if (n == 1)
      return 1;
    else if (n == 2)
      return 2;

    vector<int> steps;
    steps.push_back(1);
    steps.push_back(2);  // steps required when n = 1 & 2

    int step;
    for (int i = 2; i < n; i++) {
      steps.push_back(steps[i - 1] + steps[i - 2]);
    }

    return steps[n - 1];
  }
};
\end{minted}

\section{todos [/]}
\label{sec:org47e7b0d}
\begin{itemize}
\item[{$\square$}] read each solution carefully, try to understand the idea and implement by yourself.
\item[{$\square$}] generalize the problem
\end{itemize}
\end{document}
