#+STARTUP: indent
#+OPTIONS: H:6
#+LATEX_HEADER: \usepackage[margin=1in] {geometry}
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \setlength\parindent{0pt}
#+LATEX_HEADER: \linespread {1.0}
#+LATEX_HEADER: \setcounter{tocdepth} {3}
#+LATEX_HEADER: \setcounter{secnumdepth} {3}
#+LATEX_CLASS: book
#+LATEX_CLASS_OPTIONS: [12pt]

* Arrays
** 1. Two Sum
*** Problem Statement
[[https://leetcode.com/problems/two-sum/][Link]]
*** Analysis

*** Solution
**** C++
***** \(O(N^2)\) Time (35.43%)
Idea: traverse the vector. For each encountered value, calculate the corresponding value it needs to add up to the target value. And then traverse the vector to look for this value.

The time complexity is \(O(N^2)\), because for each value in the vector, you'll go through the vector and search its corresponding part so they add up to the target. This is linear searching, which has \(O(N)\) complexity.
#+begin_src c++ -n
class Solution {
public:
  vector<int> twoSum(vector<int>& nums, int target) {
    for (auto i = nums.begin(); i != nums.end(); ++i) {
      int other_part = target - (*i);
      auto itr = find(nums.begin(), nums.end(), other_part);
      
      if (itr != nums.end() && itr != i)
        return {static_cast<int>(i - nums.begin()), static_cast<int>(itr - nums.begin())};
    }
    
    return {0, 1};
  }
};
#+end_src
***** \(O(N\log{N})\) Time (99.24%)
Idea: the searching part is optimized. First we sort the vector. In order to keep the original relative order of each element, we sort a vector of iterators that referring each element in the original vector ~nums~. Then, we can use this sorted vector to perform binary search, whose time complexity is \(\log{N}\). The total time complexity is reduced to \(O(N\log{N})\).

I made some bugs when writting this code, because I didn't realize the following assumption:
- duplicates allowed
- each input would have */exactly/* one solution

Code:
#+begin_src c++ -n
class Solution {
public:
  /*Notes: 
    The compare object used to sort vector of iterators
  */
  struct Compare {
    bool operator()(vector<int>::iterator a, vector<int>::iterator b) {
      return (*a < *b);      
    }

  };
  
  /*Notes: 
    A binary search to find target value in a vector of iterators;
    if found: return the index value of that iterator 
    if not found: return -1
  */
  int findTarget(int target, const vector<vector<int>::iterator>& itr_vector, const vector<int>::iterator& current_itr) {
    int start_index = 0;
    int end_index = itr_vector.size() - 1;
    int middle;
    int result = -1;
    
    while (start_index <= end_index) {
      // update middle 
      middle = (start_index + end_index) / 2;
      // check value 
      if (*itr_vector[middle] == target) {
        if (itr_vector[middle] == current_itr) {
          start_index += 1;
          end_index += 1;
          continue;
        }
        
        result = middle;
        break;
      }

      else if (*itr_vector[middle] > target) {
        end_index = middle - 1;
        continue;
      }
      
      else if (*itr_vector[middle] < target) {
        start_index = middle + 1;
        continue;
      }
      
    }
    
    return result;
  }

  
  vector<int> twoSum(vector<int>& nums, int target) {
    // create a vector of iterators
    vector<vector<int>::iterator> itr_vector;
    for (auto i = nums.begin(); i != nums.end(); ++i)
      itr_vector.push_back(i);
    
    // sort the vector of iterators, so the values these iterators referred to 
    // are in ascending order
    sort(itr_vector.begin(), itr_vector.end(), Compare());
    
    // go over nums, and find the pair
    for (auto i = nums.begin(); i != nums.end() - 1; ++i) {
      int other_part = target - (*i);
      int other_part_index = findTarget(other_part, itr_vector, i);
      
      if (other_part_index != -1) // found
        return {static_cast<int>(i - nums.begin()), static_cast<int>(itr_vector[other_part_index] - nums.begin())};
    }
    
    // for syntax
    return {0, 1};
    
  }
};
#+end_src
** 136. Single Number
*** Problem Statement
[[https://leetcode.com/problems/single-number/][Link
]]
*** Analysis
**** Use Unordered-set
*** Solution
**** C++
***** Unordered-set. time (16.06%) space (15.74%)
#+begin_src c++ -n
class Solution {
public:
  int singleNumber(vector<int>& nums) {
    unordered_set<int> unique_num;
    
    for (auto num : nums) {
      auto itr = unique_num.find(num);
      
      if (itr == unique_num.end())
        unique_num.insert(num);
      else
        unique_num.erase(itr);
    }
    
    return *unique_num.begin();
  }
};
#+end_src
*** todos [0/4]
- [ ] write your solution step (in analysis part), analysis time and space complexity
- [ ] think about possible improvements
- [ ] read solution, do additional work (internalize it and write analysis and code)
- [ ] read discussion, do additional work (internalize it and write analysis and code)
** 461. Hamming Distance <<P461>>
*** Problem Statement
[[https://leetcode.com/problems/hamming-distance/][Link]]
*** Analysis
To compare two numbers bitwisely, we may need the fact that a number mod 2 is equal to the last digit of its binary form. For example:
#+BEGIN_EXAMPLE
x = 1 (0 0 0 1)
y = 4 (0 1 0 0)
x % 2 = 1
y % 2 = 0
#+END_EXAMPLE
*** Solution
**** C++
***** Time(14.63%)
#+begin_src c++ -n
class Solution {
public:
  int hammingDistance(int x, int y) {
    int result = 0;

    while (x != 0 || y != 0) {
      if (x % 2 != y % 2)
        result++;

      x = x >> 1;
      y = y >> 1;
    }

    return result;
  }
};
#+end_src
***** Time(94.5%)
#+begin_src c++ -n
class Solution {
public:
  int hammingDistance(int x, int y) {
    int result = 0;
    x ^= y;

    while (x) {
      if (x % 2)
        result++;
      x = x >> 1;
    }

    return result;
  }
};
#+end_src
***** Questions
Why the second solution is faster than the previous one?
- Bitwise XOR used.
**** Python
***** Faster than 97.37%
#+begin_src python -n
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        result = 0
        while x or y:
            if x % 2 != y % 2:
                result += 1
            x = x >> 1
            y = y >> 1
        return result
#+end_src
However, this algorithm is exactly the same as C++'s first version. Why such huge speed variance?
** 477. Total Hamming Distance
*** Problem Statement
[[https://leetcode.com/problems/total-hamming-distance/][Link]]
*** Analysis
This problem is similar with [[P461][P461]], but you can't direcly solve it using that idea (see the first solution). The size of the input is large:
- Elements of the given array are in the range of \(0\) to \(10^9\)
- Length of the array will not exceed \(10^4\)

**** First Attempt (too slow)
My first attempt is just go over all the combinations in the input array: \((x_i, x_j)\) and call the function that calculate the hamming distance of two integers ([[P461][P461]]), the code is shown in solution section. However, this approach is too slow to pass the test.

The time complexity of the function that calculates the hamming distance of two integers is not huge, just \(O(1)\). The real time consuming part is the combination. It is simply:
\[
{N \choose 2} = \frac{N(N-1)}{2} \sim O(N^2)
\]
Inside these combinations, we included many bit-pairs that do not contribute to the total Hamming distance count, for example, the combination of number 91 and 117 is:
#+BEGIN_EXAMPLE
---------------
bit#: 1234 5678
---------------
91:   0101 1011
117:  0111 0101
---------------
#+END_EXAMPLE
The bit at 1, 2, 4, 8 are not contributing to the total Hamming distance count, but we still include it and spend time verifying. This flaw can be solved in the grouping idea.

**** Grouping
[[https://leetcode.com/problems/total-hamming-distance/discuss/96250/C%2B%2B-O(n)-runtime-O(1)-space][Reference]]

The idea of grouping is we count the total hamming distance as a whole. And we only count those valid bits (bits that will contribute to the total Hamming distance). Specifically, at any giving time, we divide the array into two groups \(G_0, G_1\). The rule of grouping is:
- a number \(n\) that \(n \% 2 = 0\), goes to \(G_0\)
- a number \(n\) that \(n \% 2 = 1\), goes to \(G_1\)
The result of \(n\%2\) will give you the least significant bit, or the last bit of an integer in binary form. By the definition of Hamming distance, we know that any combinations that contains number pairs only from \(G_0\) or only from \(G_1\) will not contribute to the total Hamming distance count (just for this grouping round, which only compares the least significant bit of those numbers). On the other hand, any combination that contains one number from \(G_0\) and one number from \(G_1\) will contribute 1 to the total Hamming distance. So, for this round, we only have to count the combination of such case, which is simply:
\[
N_{G_0} \times N_{G_1}
\]
Then, we trim the current least significant bit and re-group the numbers into new \(G_0\) and \(G_1\). This is because at each bit the numbers are different. We do this until *ALL* numbers are *ZERO*. For example, if at one round, there are no numbers in \(G_1\), all numbers are in \(G_0\), then although the contribution to total Hamming distance of this round is zero, we have to move on to trim the least significant bit and re-group the numbers. Another confusing case is when some numbers are trimmed to zero during the process. We still keep those zeros in array, because they still can be used to count total Hamming distance. For example, number 9 and 13317:
#+BEGIN_EXAMPLE
---------------------------
bit#:   1234 5678 9abc defg
---------------------------
9:      0000 0000 0000 1001
13317:  0011 0100 0000 0101
---------------------------
#+END_EXAMPLE
After four times of trimming:
#+BEGIN_EXAMPLE
-----------------------
bit#:   1234 5678 9abc 
-----------------------
9:      0000 0000 0000 
13317:  0011 0100 0000 
-----------------------
#+END_EXAMPLE
The difference at bit 3, 4, 6 should still be counted toward the total Hamming distance.

At each round, we first go over the list and divide the numbers into two groups. This process is \(O(N)\). To calculate the contribution to total Hamming distance at this round is just a matter of multiplication, so the time complexity is \(O(1)\). Thus, for one round, time complexity is \(O(N)\). There are potentially ~8 * sizeof(int)~ bits to be trimmed, this is the number of rounds we are going to run, which is a constant not related to \(N\). Thus the total complexity is: \(O(N)\).
*** Solution
**** C++
***** Not Accepted (too slow)
This algorithm is too slow.
#+begin_src c++ -n
class Solution {
public:
  int hammingDistance(const int& x, const int& y) {
    int result = 0;
    int a = x ^ y;

    while (a != 0) {
      if (a % 2)
        result++;
      a = a >> 1;
    }

    return result;
  }  

  int totalHammingDistance(vector<int>& nums) {
    int count = 0;
    for (int i = 0; i < nums.size() - 1; ++i) {
      for (int j = i + 1; j < nums.size(); ++j)
        count += hammingDistance(nums[i], nums[j]);
    }
    return count;
  }
};
#+end_src
***** Grouping. time (6.59%) space (5.13%)
This is the first version after I read and apply the idea of grouping numbers with different Least Significant bit. Although it is still slow, it is accepted.....
#+begin_src c++ -n
class Solution {
public:
  int totalHammingDistance(vector<int>& nums) {
    vector<int> LSB_ones;
    vector<int> LSB_zeros;
    int count = 0;
    int non_zero_count = 1; // loop continue until no non-zero num in nums
    
    while (non_zero_count) {
      // clear temp container, reset non-zero count
      LSB_ones.clear();
      LSB_zeros.clear();
      non_zero_count = 0;
      
      // collect number, divide into two groups
      for (auto& i : nums) {
        if (i % 2 == 0)
          LSB_zeros.push_back(i);
        else 
          LSB_ones.push_back(i);
        
        // update i and non_zero_count
        i = i >> 1;
        if (i)
          non_zero_count++;
      }
      
      // update count 
      count += LSB_ones.size() * LSB_zeros.size();
    }
    
    return count;
  }
};
#+end_src
***** Grouping_example. time (88.24%, 49.76%)
This is from the discussion (grouping idea).
#+begin_src c++ -n
class Solution {
public:
  int totalHammingDistance(vector<int>& nums) {
    if (nums.size() <= 0) return 0;
    
    int res = 0;
    
    for(int i=0;i<32;i++) {
      int setCount = 0;
      for(int j=0;j<nums.size();j++) {
          if ( nums[j] & (1 << i) ) setCount++;
      }
      
      res += setCount * (nums.size() - setCount);
    }
    
    return res;
  }
};
#+end_src

This solution is a lot faster than my version, altough we use the same idea. I used a lot more steps to do the book keeping, which the example solution uses spaces and time efficiently. Specifically:
- I have defined two vectors to actually store the *TWO* groups. My thinking is simple: if the idea involves two groups, then I want to actually implement two groups to closely follow the idea. This reflects the lack of ability to generalize a problem and find what matters most to solve the problem. In this specific example, what matters most, is to *KNOW* the number of element in just *ONE* group, there are ways to know this without actually spending time and spaces to keep the whole record of the two groups.
- my end point would be "there is no non-zero number in the array", I have to declare a new integer to keep track of the number of non-zero number, and I have to use an if expression to determine if a number is non-zero after trimming the least significant bit.  The example code only traverse all the bits of an integer (i.e. 32 bits in total, or 4 bytes) using a for loop.

In line 11, the code reads: ~if ( nums[j] & (1 << i) ) setCount++;~. The operators used are bitwise AND, bitwise left shift. This is to compare the i-th bit of ~num[j]~ with 1. If it is 1, then at this bit, the number should be counted in group \(G_1\). For example, if ~num[j] == 113~, ~i == 5~, then we compare:
#+BEGIN_EXAMPLE
           â†“
113:     0111 0001
1 << i:  0010 0000
#+END_EXAMPLE

Also, we don't have to count integer numbers in \(G_0\), since: \(N_{G_0} = N - N_{G_1}\), where \(N\) is the total number of integers, which is equal to ~nums.size()~.

*** todos [2/4]
- [X] Write the analysis of grouping idea and my code
- [X] Read code in reference of grouping idea, make notes
- [ ] Check other possible solution and make future plan
- [ ] Try to generalize this problem 
** 771. Jewels and Stones
*** Problem Statement
[[https://leetcode.com/problems/jewels-and-stones/][Link]]
*** Analysis
*** Solution
**** C++
***** \(N^2\) Time (96.35%) Space (79.64%)
#+begin_src c++ -n
class Solution {
public:
  int numJewelsInStones(string J, string S) {
    int numJewl = 0;
    for (auto s : S)
      if (isJewels(s, J))
        numJewl++;
    return numJewl;
  }
  
  bool isJewels(char s, string J) {
    for (auto j : J)
      if (s == j)
        return true;
    
    return false;
  }
};
#+end_src
* Trees
** 104. Maximum Depth of Binary Tree
*** Problem Statement
[[https://leetcode.com/problems/maximum-depth-of-binary-tree/][Link]]
*** Analysis
**** Recursion
A node's maximum depth, is the larger maximum depth of its left and right subtree plus one. Base case: if a node is nullptr, maximum depth is zero.
*** Solution
**** C++
***** Recursion. Time (88.44%) Space (91.28%)
#+begin_src c++ -n
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  int maxDepth(TreeNode* root) {
    // base case 
    if (root == nullptr)
      return 0;
    
    int left_depth = maxDepth(root->left);
    int right_depth = maxDepth(root->right);
    
    return (left_depth >= right_depth ? left_depth + 1 : right_depth + 1);
  }
};
#+end_src
*** todos [/]
- [ ] read about the discussion page for more methods and ideas
  
** 617. Merge Two Binary Trees
*** Problem Statement
[[https://leetcode.com/problems/merge-two-binary-trees/][Link]]
*** Analysis
**** Approach #1 Recursive Method
Use recursiion to solve this problem.
**** Approach #2 Iterative Method

*** Solution
**** C++
***** Recursion Time (97.09%) Space(37.01%)
Recursion.
#+begin_src c++ -n
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
    if (t1 == nullptr)
      return t2;
    else if (t2 == nullptr)
      return t1;
    else {
      TreeNode* node = new TreeNode(t1->val + t2->val);
      node->left = mergeTrees(t1->left, t2->left);
      node->right = mergeTrees(t1->right, t2->right);
      return node;
    }
  }
};
#+end_src
***** Iterative
*** todos [/]
- [ ] read the other solution (iterate the tree using stack), and understand it
- [ ] write code based on the other solution
