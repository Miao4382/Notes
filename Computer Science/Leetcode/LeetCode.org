#+STARTUP: indent
#+OPTIONS: H:6
#+LATEX_HEADER: \usepackage[margin=1in] {geometry}
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \setlength\parindent{0pt}
#+LATEX_HEADER: \linespread {1.0}
#+LATEX_HEADER: \setcounter{tocdepth} {3}
#+LATEX_HEADER: \setcounter{secnumdepth} {3}
#+LATEX_CLASS: book
#+LATEX_CLASS_OPTIONS: [12pt]

* Arrays
** 1. Two Sum
*** Problem Statement
[[https://leetcode.com/problems/two-sum/][Link]]
*** Analysis

*** Solution
**** C++
***** \(O(N^2)\) Time (35.43%)
Idea: traverse the vector. For each encountered value, calculate the corresponding value it needs to add up to the target value. And then traverse the vector to look for this value.

The time complexity is \(O(N^2)\), because for each value in the vector, you'll go through the vector and search its corresponding part so they add up to the target. This is linear searching, which has \(O(N)\) complexity.
#+begin_src c++ -n
class Solution {
public:
  vector<int> twoSum(vector<int>& nums, int target) {
    for (auto i = nums.begin(); i != nums.end(); ++i) {
      int other_part = target - (*i);
      auto itr = find(nums.begin(), nums.end(), other_part);
      
      if (itr != nums.end() && itr != i)
        return {static_cast<int>(i - nums.begin()), static_cast<int>(itr - nums.begin())};
    }
    
    return {0, 1};
  }
};
#+end_src
***** \(O(N\log{N})\) Time (99.24%)
Idea: the searching part is optimized. First we sort the vector. In order to keep the original relative order of each element, we sort a vector of iterators that referring each element in the original vector ~nums~. Then, we can use this sorted vector to perform binary search, whose time complexity is \(\log{N}\). The total time complexity is reduced to \(O(N\log{N})\).

I made some bugs when writting this code, because I didn't realize the following assumption:
- duplicates allowed
- each input would have */exactly/* one solution

Code:
#+begin_src c++ -n
class Solution {
public:
  /*Notes: 
    The compare object used to sort vector of iterators
  */
  struct Compare {
    bool operator()(vector<int>::iterator a, vector<int>::iterator b) {
      return (*a < *b);      
    }

  };
  
  /*Notes: 
    A binary search to find target value in a vector of iterators;
    if found: return the index value of that iterator 
    if not found: return -1
  */
  int findTarget(int target, const vector<vector<int>::iterator>& itr_vector, const vector<int>::iterator& current_itr) {
    int start_index = 0;
    int end_index = itr_vector.size() - 1;
    int middle;
    int result = -1;
    
    while (start_index <= end_index) {
      // update middle 
      middle = (start_index + end_index) / 2;
      // check value 
      if (*itr_vector[middle] == target) {
        if (itr_vector[middle] == current_itr) {
          start_index += 1;
          end_index += 1;
          continue;
        }
        
        result = middle;
        break;
      }

      else if (*itr_vector[middle] > target) {
        end_index = middle - 1;
        continue;
      }
      
      else if (*itr_vector[middle] < target) {
        start_index = middle + 1;
        continue;
      }
      
    }
    
    return result;
  }

  
  vector<int> twoSum(vector<int>& nums, int target) {
    // create a vector of iterators
    vector<vector<int>::iterator> itr_vector;
    for (auto i = nums.begin(); i != nums.end(); ++i)
      itr_vector.push_back(i);
    
    // sort the vector of iterators, so the values these iterators referred to 
    // are in ascending order
    sort(itr_vector.begin(), itr_vector.end(), Compare());
    
    // go over nums, and find the pair
    for (auto i = nums.begin(); i != nums.end() - 1; ++i) {
      int other_part = target - (*i);
      int other_part_index = findTarget(other_part, itr_vector, i);
      
      if (other_part_index != -1) // found
        return {static_cast<int>(i - nums.begin()), static_cast<int>(itr_vector[other_part_index] - nums.begin())};
    }
    
    // for syntax
    return {0, 1};
    
  }
};
#+end_src
** 136. Single Number
*** Problem Statement
[[https://leetcode.com/problems/single-number/][Link
]]
*** Analysis
**** Use Unordered-set
*** Solution
**** C++
***** Unordered-set. time (16.06%) space (15.74%)
#+begin_src c++ -n
class Solution {
public:
  int singleNumber(vector<int>& nums) {
    unordered_set<int> unique_num;
    
    for (auto num : nums) {
      auto itr = unique_num.find(num);
      
      if (itr == unique_num.end())
        unique_num.insert(num);
      else
        unique_num.erase(itr);
    }
    
    return *unique_num.begin();
  }
};
#+end_src
*** todos [0/4]
- [ ] write your solution step (in analysis part), analysis time and space complexity
- [ ] think about possible improvements
- [ ] read solution, do additional work (internalize it and write analysis and code)
- [ ] read discussion, do additional work (internalize it and write analysis and code)
** 283. Move Zeros
*** Problem Statement
[[https://leetcode.com/problems/move-zeroes/][Link]]
*** Analysis
Make sure you know well the problem statement. For example, in this problem, there is no requirement for the zero element be kepted.
*** Solution
**** C++
***** Use bubble sort idea. time (5%) space (75%)
Too slow, time complexity is \(O(N^2)\).
#+begin_src c++ -n
class Solution {
public:
  void moveZeroes(vector<int>& nums) {
    bool swapped;

    // swap array    
    do {
      swapped = false;      
      
      for (auto iter = nums.begin(); iter != nums.end() - 1; ++iter) {
        if (*iter == 0) {
          if (*(iter + 1) == 0)
            continue;
          swap(*iter, *(iter + 1));
          swapped = true;
        }   
      }     
    } while (swapped);
  }
};
#+end_src
***** Use erase(), remove zeros. time (35%) space (34%)
Still slow. Since the ~erase()~ function will reallocate each element after the deleted one. Worst case time complexity should be \(O(N^2)\).
#+begin_src c++ -n
class Solution {
public:
  
  void moveZeroes(vector<int>& nums) {
    int zero_count = 0;
    for (auto iter = nums.begin(); iter != nums.end(); ++iter)
      if (*iter == 0)
        zero_count++;
    
    if (zero_count == 0)
      return;
    
    auto iter = nums.begin();
    int zero_deleted = 0;
    
    while (zero_deleted < zero_count) {
      if (*iter == 0) {
        iter = nums.erase(iter);
        nums.push_back(0);
        zero_deleted++;
      }
      
      else
        ++iter;       
    }
  }
};
#+end_src
*** todos [0/2]
- [ ] try to think another Solution
- [ ] read the solution page and study
** 442. Find All Duplicates in an Array<<P442>>
*** Problem Statement
[[https://leetcode.com/problems/find-all-duplicates-in-an-array/][Link]]
*** Analysis
**** Label Duplicate Number
Label the appearing frequency of each element, using the fact that ~1 <= a[i] <= n~, where n is the size of array. Then count the number that appeared twice.
*** Solution
**** C++
***** Label duplicate number (96%, 16%)
This one use an extra vector to hold the labeling information.
#+begin_src c++ -n
class Solution {
public:
  vector<int> findDuplicates(vector<int>& nums) {
    vector<int> duplicate;
    vector<int> frequency_count(nums.size(), 0);
    
    for (int i = 0; i < nums.size(); i++) {
      frequency_count[nums[i] - 1]++;
    }
    
    for (int i = 0; i < frequency_count.size(); i++)
      if (frequency_count[i] > 1)
        duplicate.push_back(i + 1);
    
    return duplicate;
  }
};
#+end_src

*** todos [/]
- [ ] think about the way to use original vector to hold labeling information
- [ ] read other solutions
- [ ] generalize the problem
** 448. Find All Numbers Disappeared in an Array
*** Problem Statement
[[https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/][Link]]
*** Analysis
**** Label Appearance of Numbers
This is similar with [[P442][Problem 442]]. Label the appearing frequency of each element, using the fact that ~1 <= a[i] <= n~, where n is the size of array. Then count the number that appearing frequency is 0.

You can use either a new vector to hold the labeling information, or the original passed-in vector.

**** Use Unordered-set
Use an unordered-set to store all appeared number. Then traverse from 1 to N to find out if one number is in the set, if not, it is one disappearing number, push to result. This method's time complexity is \(O(N)\) on average, but \(O(N^2)\) for worst cases, due to the time complexity of ~insert()~ and ~find()~ in unordered-set.

*** Solution
**** C++
***** Label appearance of numbers (97%, 15%)
Space can be optimized by using original passed-in vector.
#+begin_src c++ -n
class Solution {
public:
  vector<int> findDisappearedNumbers(vector<int>& nums) {
    vector<int> appear_label(nums.size(), 0);
    vector<int> disappear;
    
    // label appeared number
    for (int i = 0; i < nums.size(); i++) {
      appear_label[nums[i] - 1] = 1;
    }
    
    // find out unlabelled number 
    for (int i = 0; i < appear_label.size(); ++i)
      if (appear_label[i] == 0)
        disappear.push_back(i + 1);
    
    return disappear;
  }
};
#+end_src
***** Use unordered-set (13%, 7%)
#+begin_src c++ -n
class Solution {
public:
  vector<int> findDisappearedNumbers(vector<int>& nums) {
    vector<int> disappear;
    unordered_set<int> appeared; // extra space used
    
    for (auto num : nums)  // total average O(N), worst: O(N^2)
      appeared.insert(num);  // average: O(1), worst: O(N)
    
    for (int i = 1; i <= nums.size(); ++i) {
      if (appeared.find(i) == appeared.end())  // find(), average: O(1), worst: O(N)
        disappear.push_back(i);
    }
    
    return disappear;
  }
};

// Total complexity: average: O(N), worst: O(N^2), still bound by O(N^2)
#+end_src
*** todos [/]
- [ ] think about using the original vector to hold labeling information
- [ ] read other solutions
- [ ] generalize the problem
** 461. Hamming Distance <<P461>>
*** Problem Statement
[[https://leetcode.com/problems/hamming-distance/][Link]]
*** Analysis
To compare two numbers bitwisely, we may need the fact that a number mod 2 is equal to the last digit of its binary form. For example:
#+BEGIN_EXAMPLE
x = 1 (0 0 0 1)
y = 4 (0 1 0 0)
x % 2 = 1
y % 2 = 0
#+END_EXAMPLE
*** Solution
**** C++
***** Time(14.63%)
#+begin_src c++ -n
class Solution {
public:
  int hammingDistance(int x, int y) {
    int result = 0;

    while (x != 0 || y != 0) {
      if (x % 2 != y % 2)
        result++;

      x = x >> 1;
      y = y >> 1;
    }

    return result;
  }
};
#+end_src
***** Time(94.5%)
#+begin_src c++ -n
class Solution {
public:
  int hammingDistance(int x, int y) {
    int result = 0;
    x ^= y;

    while (x) {
      if (x % 2)
        result++;
      x = x >> 1;
    }

    return result;
  }
};
#+end_src
***** Questions
Why the second solution is faster than the previous one?
- Bitwise XOR used.
**** Python
***** Faster than 97.37%
#+begin_src python -n
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        result = 0
        while x or y:
            if x % 2 != y % 2:
                result += 1
            x = x >> 1
            y = y >> 1
        return result
#+end_src
However, this algorithm is exactly the same as C++'s first version. Why such huge speed variance?
** 477. Total Hamming Distance
*** Problem Statement
[[https://leetcode.com/problems/total-hamming-distance/][Link]]
*** Analysis
This problem is similar with [[P461][P461]], but you can't direcly solve it using that idea (see the first solution). The size of the input is large:
- Elements of the given array are in the range of \(0\) to \(10^9\)
- Length of the array will not exceed \(10^4\)

**** First Attempt (too slow)
My first attempt is just go over all the combinations in the input array: \((x_i, x_j)\) and call the function that calculate the hamming distance of two integers ([[P461][P461]]), the code is shown in solution section. However, this approach is too slow to pass the test.

The time complexity of the function that calculates the hamming distance of two integers is not huge, just \(O(1)\). The real time consuming part is the combination. It is simply:
\[
{N \choose 2} = \frac{N(N-1)}{2} \sim O(N^2)
\]
Inside these combinations, we included many bit-pairs that do not contribute to the total Hamming distance count, for example, the combination of number 91 and 117 is:
#+BEGIN_EXAMPLE
---------------
bit#: 1234 5678
---------------
91:   0101 1011
117:  0111 0101
---------------
#+END_EXAMPLE
The bit at 1, 2, 4, 8 are not contributing to the total Hamming distance count, but we still include it and spend time verifying. This flaw can be solved in the grouping idea.

**** Grouping
[[https://leetcode.com/problems/total-hamming-distance/discuss/96250/C%2B%2B-O(n)-runtime-O(1)-space][Reference]]

The idea of grouping is we count the total hamming distance as a whole. And we only count those valid bits (bits that will contribute to the total Hamming distance). Specifically, at any giving time, we divide the array into two groups \(G_0, G_1\). The rule of grouping is:
- a number \(n\) that \(n \% 2 = 0\), goes to \(G_0\)
- a number \(n\) that \(n \% 2 = 1\), goes to \(G_1\)
The result of \(n\%2\) will give you the least significant bit, or the last bit of an integer in binary form. By the definition of Hamming distance, we know that any combinations that contains number pairs only from \(G_0\) or only from \(G_1\) will not contribute to the total Hamming distance count (just for this grouping round, which only compares the least significant bit of those numbers). On the other hand, any combination that contains one number from \(G_0\) and one number from \(G_1\) will contribute 1 to the total Hamming distance. So, for this round, we only have to count the combination of such case, which is simply:
\[
N_{G_0} \times N_{G_1}
\]
Then, we trim the current least significant bit and re-group the numbers into new \(G_0\) and \(G_1\). This is because at each bit the numbers are different. We do this until *ALL* numbers are *ZERO*. For example, if at one round, there are no numbers in \(G_1\), all numbers are in \(G_0\), then although the contribution to total Hamming distance of this round is zero, we have to move on to trim the least significant bit and re-group the numbers. Another confusing case is when some numbers are trimmed to zero during the process. We still keep those zeros in array, because they still can be used to count total Hamming distance. For example, number 9 and 13317:
#+BEGIN_EXAMPLE
---------------------------
bit#:   1234 5678 9abc defg
---------------------------
9:      0000 0000 0000 1001
13317:  0011 0100 0000 0101
---------------------------
#+END_EXAMPLE
After four times of trimming:
#+BEGIN_EXAMPLE
-----------------------
bit#:   1234 5678 9abc 
-----------------------
9:      0000 0000 0000 
13317:  0011 0100 0000 
-----------------------
#+END_EXAMPLE
The difference at bit 3, 4, 6 should still be counted toward the total Hamming distance.

At each round, we first go over the list and divide the numbers into two groups. This process is \(O(N)\). To calculate the contribution to total Hamming distance at this round is just a matter of multiplication, so the time complexity is \(O(1)\). Thus, for one round, time complexity is \(O(N)\). There are potentially ~8 * sizeof(int)~ bits to be trimmed, this is the number of rounds we are going to run, which is a constant not related to \(N\). Thus the total complexity is: \(O(N)\).

*Additional notes (2019/5/26)* It is not a good idea to *TRIM* the numbers, which may add additional complexities. We can just use a for loop to compare all ~8 * sizeof(int)~ bits on integer. The range of iterating number (i) is from 0 to 31. At each iteration, we compare the value at i-th bit (starting from zero) with 1. To achieve this, we need use two operators (bitwise *AND* and left shift). Notice that the bitwise *AND* is 1 only if both bits are 1.
*** Solution
**** C++
***** Not Accepted (too slow)
This algorithm is too slow.
#+begin_src c++ -n
class Solution {
public:
  int hammingDistance(const int& x, const int& y) {
    int result = 0;
    int a = x ^ y;

    while (a != 0) {
      if (a % 2)
        result++;
      a = a >> 1;
    }

    return result;
  }  

  int totalHammingDistance(vector<int>& nums) {
    int count = 0;
    for (int i = 0; i < nums.size() - 1; ++i) {
      for (int j = i + 1; j < nums.size(); ++j)
        count += hammingDistance(nums[i], nums[j]);
    }
    return count;
  }
};
#+end_src
***** Grouping. time (6.59%) space (5.13%)
This is the first version after I read and apply the idea of grouping numbers with different Least Significant bit. Although it is still slow, it is accepted.....
#+begin_src c++ -n
class Solution {
public:
  int totalHammingDistance(vector<int>& nums) {
    vector<int> LSB_ones;
    vector<int> LSB_zeros;
    int count = 0;
    int non_zero_count = 1; // loop continue until no non-zero num in nums
    
    while (non_zero_count) {
      // clear temp container, reset non-zero count
      LSB_ones.clear();
      LSB_zeros.clear();
      non_zero_count = 0;
      
      // collect number, divide into two groups
      for (auto& i : nums) {
        if (i % 2 == 0)
          LSB_zeros.push_back(i);
        else 
          LSB_ones.push_back(i);
        
        // update i and non_zero_count
        i = i >> 1;
        if (i)
          non_zero_count++;
      }
      
      // update count 
      count += LSB_ones.size() * LSB_zeros.size();
    }
    
    return count;
  }
};
#+end_src

There are many reasons why this solution is expensive. Some of them are listed below:
- There is no need to actually use two vectors to *STORE* each number in two vectors. You just need to count the number.
***** Grouping_example. time (88.24%, 49.76%)
This is from the discussion (grouping idea).
#+begin_src c++ -n
class Solution {
public:
  int totalHammingDistance(vector<int>& nums) {
    if (nums.size() <= 0) return 0;
    
    int res = 0;
    
    for(int i=0;i<32;i++) {
      int setCount = 0;
      for(int j=0;j<nums.size();j++) {
          if ( nums[j] & (1 << i) ) setCount++;
      }
      
      res += setCount * (nums.size() - setCount);
    }
    
    return res;
  }
};
#+end_src

This solution is a lot faster than my version, altough we use the same idea. I used a lot more steps to do the book keeping, which the example solution uses spaces and time efficiently. Specifically:
- I have defined two vectors to actually store the *TWO* groups. My thinking is simple: if the idea involves two groups, then I want to actually implement two groups to closely follow the idea. This reflects the lack of ability to generalize a problem and find what matters most to solve the problem. In this specific example, what matters most, is to *KNOW* the number of element in just *ONE* group, there are ways to know this without actually spending time and spaces to keep the whole record of the two groups.
- my end point would be "there is no non-zero number in the array", I have to declare a new integer to keep track of the number of non-zero number, and I have to use an if expression to determine if a number is non-zero after trimming the least significant bit.  The example code only traverse all the bits of an integer (i.e. 32 bits in total, or 4 bytes) using a for loop.

In line 11, the code reads: ~if ( nums[j] & (1 << i) ) setCount++;~. The operators used are bitwise AND, bitwise left shift. This is to compare the i-th bit of ~num[j]~ with 1. If it is 1, then at this bit, the number should be counted in group \(G_1\). For example, if ~num[j] == 113~, ~i == 5~, then we compare:
#+BEGIN_EXAMPLE
           ↓
113:     0111 0001
1 << i:  0010 0000
#+END_EXAMPLE

Also, we don't have to count integer numbers in \(G_0\), since: \(N_{G_0} = N - N_{G_1}\), where \(N\) is the total number of integers, which is equal to ~nums.size()~.

*** todos [3/4]
- [X] Write the analysis of grouping idea and my code
- [X] Read code in reference of grouping idea, make notes
- [X] Check other possible solution and make future plan
- [ ] Try to generalize this problem 
** 771. Jewels and Stones
*** Problem Statement
[[https://leetcode.com/problems/jewels-and-stones/][Link]]
*** Analysis
*** Solution
**** C++
***** \(N^2\) Time (96.35%) Space (79.64%)
#+begin_src c++ -n
class Solution {
public:
  int numJewelsInStones(string J, string S) {
    int numJewl = 0;
    for (auto s : S)
      if (isJewels(s, J))
        numJewl++;
    return numJewl;
  }
  
  bool isJewels(char s, string J) {
    for (auto j : J)
      if (s == j)
        return true;
    
    return false;
  }
};
#+end_src
* Linked List
** 206. Reverse Linked List
*** Problem Statement
[[https://leetcode.com/problems/reverse-linked-list/][Link]]

Notice that the ~head~ in this linked list is actually the first node in the list. Not like what you learned in COP 4530.
*** Analysis
This problem should have some simpler solution. My two solutions are just akward.
**** Using Stack (my)
**** Recursion (my)
*** Solution
**** C++
***** Using Stack. time (96%), space (5%)
This method uses a stack to keep the reverse order. Additional memory is required.
#+begin_src c++ -n
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
  ListNode* reverseList(ListNode* head) {
    stack<ListNode*> nodes;
    // check if head is nullptr
    if (head == nullptr)
      return head;
    
    // store the list in stack 
    while (true) {
      if (head->next != nullptr) {
        nodes.push(head);
        head = head->next;
      }
      
      else { // head is pointing the last node
        nodes.push(head);
        break;
      }
    }
    
    // start re-connect
    head = nodes.top();
    nodes.pop();
    ListNode* last_node = head;
    
    while (!nodes.empty()) {
      last_node->next = nodes.top();
      last_node = last_node->next;
      nodes.pop();
    }
    
    last_node->next = nullptr;
    
    return head;
  }
};
#+end_src
***** Using Recursion. time (18%), space (21%)
This approach is a very "akward" way to use recursion.
*** todos [/]
- [ ] try to think another way to work this problem
- [ ] read solution, write down thinking process
- [ ] time complexity analysis of your code and solution code 
* Trees
** 104. Maximum Depth of Binary Tree
*** Problem Statement
[[https://leetcode.com/problems/maximum-depth-of-binary-tree/][Link]]
*** Analysis
**** Recursion
A node's maximum depth, is the larger maximum depth of its left and right subtree plus one. Base case: if a node is nullptr, maximum depth is zero.
*** Solution
**** C++
***** Recursion. Time (88.44%) Space (91.28%)
#+begin_src c++ -n
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  int maxDepth(TreeNode* root) {
    // base case 
    if (root == nullptr)
      return 0;
    
    int left_depth = maxDepth(root->left);
    int right_depth = maxDepth(root->right);
    
    return (left_depth >= right_depth ? left_depth + 1 : right_depth + 1);
  }
};
#+end_src
*** todos [0/1]
- [ ] read about the discussion page for more methods and ideas
- [ ] read about traversal method
- [ ] make notes in your data structure notes about DFS abd BFS
** 226. Invert Binary Tree
*** Problem Statement
[[https://leetcode.com/problems/invert-binary-tree/][Link]]
*** Analysis
**** Recursion
To solve this problem recursively, we first invert the left subtree of a node by calling this function, then we invert the right subtree of this node by calling this function. Then we return a pointer to this node. Base case: ~node == nullptr~, in this case we return the node directly, since the invert of a ~nullptr~ tree is itself.
*** Solution
**** C++
***** Recursion. time (91.95%) space (5.15%)
I don't understand why my code require this amount of space. Needs to be analyzed.
#+begin_src c++ -n
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr)
      return root;
    
    TreeNode* temp = root->left;
    root->left = invertTree(root->right);
    root->right = invertTree(temp);
    
    return root;
  }
};
#+end_src
*** todos [0/2]
- [ ] analyze why my code requires a lot more space than the divide and conquer method
- [ ] read the discussion page for more solution
** 617. Merge Two Binary Trees
*** Problem Statement
[[https://leetcode.com/problems/merge-two-binary-trees/][Link]]
*** Analysis
**** Recursive Method
Use recursiion to solve this problem.
**** Iterative Method (using stack)

*** Solution
**** C++
***** Recursion Time (97.09%) Space(37.01%)
Recursion.
#+begin_src c++ -n
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
  TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
    if (t1 == nullptr)
      return t2;
    else if (t2 == nullptr)
      return t1;
    else {
      TreeNode* node = new TreeNode(t1->val + t2->val);
      node->left = mergeTrees(t1->left, t2->left);
      node->right = mergeTrees(t1->right, t2->right);
      return node;
    }
  }
};
#+end_src
***** Iterative
*** todos [0/2]
- [ ] read the other solution (iterate the tree using stack), and understand it
- [ ] write code based on the other solution
